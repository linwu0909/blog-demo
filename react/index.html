<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶之路</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/icon.png">
    <meta name="description" content="linwu0909个人站点">
    
    <link rel="preload" href="/assets/css/0.styles.d6ad21ed.css" as="style"><link rel="preload" href="/assets/js/app.a4ba95f7.js" as="script"><link rel="preload" href="/assets/js/2.67e62386.js" as="script"><link rel="preload" href="/assets/js/26.78631bc5.js" as="script"><link rel="prefetch" href="/assets/js/10.a509ebb0.js"><link rel="prefetch" href="/assets/js/11.f6c7ea4e.js"><link rel="prefetch" href="/assets/js/12.d41f06f2.js"><link rel="prefetch" href="/assets/js/13.c3e870d4.js"><link rel="prefetch" href="/assets/js/14.30322894.js"><link rel="prefetch" href="/assets/js/15.86aa2619.js"><link rel="prefetch" href="/assets/js/16.c3bf8266.js"><link rel="prefetch" href="/assets/js/17.558a6e40.js"><link rel="prefetch" href="/assets/js/18.7260607d.js"><link rel="prefetch" href="/assets/js/19.610728e5.js"><link rel="prefetch" href="/assets/js/20.9a25090f.js"><link rel="prefetch" href="/assets/js/21.8265851e.js"><link rel="prefetch" href="/assets/js/22.07a30c30.js"><link rel="prefetch" href="/assets/js/23.0bd65a47.js"><link rel="prefetch" href="/assets/js/24.484698e4.js"><link rel="prefetch" href="/assets/js/25.9c781b1b.js"><link rel="prefetch" href="/assets/js/27.eafd817a.js"><link rel="prefetch" href="/assets/js/3.758fc587.js"><link rel="prefetch" href="/assets/js/4.8afd5cf5.js"><link rel="prefetch" href="/assets/js/5.4f1a5aca.js"><link rel="prefetch" href="/assets/js/6.cc47db6f.js"><link rel="prefetch" href="/assets/js/7.64d96c12.js"><link rel="prefetch" href="/assets/js/8.64e93bc9.js"><link rel="prefetch" href="/assets/js/9.ae8eb319.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d6ad21ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端进阶之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/react/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端综合" class="dropdown-title"><span class="title">前端综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端综合" class="mobile-dropdown-title"><span class="title">前端综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front/html.html" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front/js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/front/es6.html" class="nav-link">
  ES6+
</a></li><li class="dropdown-item"><!----> <a href="/front/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构和算法" class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据结构和算法" class="mobile-dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/base.html" class="nav-link">
  经典排序算法+数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/leetCode100.html" class="nav-link">
  LeetCode100
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/handWrite.html" class="nav-link">
  手写各种实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工程化" class="dropdown-title"><span class="title">前端工程化</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端工程化" class="mobile-dropdown-title"><span class="title">前端工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/engineer/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/engineer/webpack.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/engineer/pack.html" class="nav-link">
  Gulp
</a></li></ul></div></div> <a href="https://github.com/linwu0909" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/react/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端综合" class="dropdown-title"><span class="title">前端综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端综合" class="mobile-dropdown-title"><span class="title">前端综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front/html.html" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front/js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/front/es6.html" class="nav-link">
  ES6+
</a></li><li class="dropdown-item"><!----> <a href="/front/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构和算法" class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据结构和算法" class="mobile-dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/base.html" class="nav-link">
  经典排序算法+数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/leetCode100.html" class="nav-link">
  LeetCode100
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/handWrite.html" class="nav-link">
  手写各种实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工程化" class="dropdown-title"><span class="title">前端工程化</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端工程化" class="mobile-dropdown-title"><span class="title">前端工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/engineer/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/engineer/webpack.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/engineer/pack.html" class="nav-link">
  Gulp
</a></li></ul></div></div> <a href="https://github.com/linwu0909" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/#react" class="sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/#_1-diff算法-及虚拟dom" class="sidebar-link">1.diff算法？及虚拟dom？</a></li><li class="sidebar-sub-header"><a href="/react/#_2-fiber是什么" class="sidebar-link">2.fiber是什么？</a></li><li class="sidebar-sub-header"><a href="/react/#_3-setstate是同步还是异步-私下简单记忆-同步逻辑中就异步-异步逻辑中就同步" class="sidebar-link">3.setState是同步还是异步？(私下简单记忆：同步逻辑中就异步，异步逻辑中就同步)</a></li><li class="sidebar-sub-header"><a href="/react/#_4-ui组件与容器组件" class="sidebar-link">4.UI组件与容器组件？</a></li><li class="sidebar-sub-header"><a href="/react/#_5-todo" class="sidebar-link">5.//TODO</a></li><li class="sidebar-sub-header"><a href="/react/#_6-生命周期-只针对类-函数式组件无生命周期-》括号里都是react16以后的钩子" class="sidebar-link">6.生命周期(只针对类，函数式组件无生命周期)=》括号里都是react16以后的钩子</a></li><li class="sidebar-sub-header"><a href="/react/#_7-react脚手架" class="sidebar-link">7.react脚手架</a></li><li class="sidebar-sub-header"><a href="/react/#_8-shouldcomponentupdate" class="sidebar-link">8.shouldComponentUpdate？</a></li><li class="sidebar-sub-header"><a href="/react/#_9-react-router-dom和react-router区别" class="sidebar-link">9.react-router-dom和react-router区别？</a></li><li class="sidebar-sub-header"><a href="/react/#_10-setstate时发生了什么" class="sidebar-link">10.setState时发生了什么？</a></li><li class="sidebar-sub-header"><a href="/react/#_11-怎么理解在react中-一切都是属性" class="sidebar-link">11.怎么理解在react中，一切都是属性？</a></li><li class="sidebar-sub-header"><a href="/react/#_12-todo" class="sidebar-link">12.//TODO</a></li><li class="sidebar-sub-header"><a href="/react/#_13-常见hooks功能-react-16-8引入了hooks" class="sidebar-link">13.常见hooks功能(react 16.8引入了hooks)</a></li><li class="sidebar-sub-header"><a href="/react/#_14-hooks如何模拟componentdidmount" class="sidebar-link">14.hooks如何模拟componentDidMount？</a></li><li class="sidebar-sub-header"><a href="/react/#_15-hooks如何部分替代redux功能" class="sidebar-link">15.hooks如何部分替代redux功能？</a></li><li class="sidebar-sub-header"><a href="/react/#_16-react函数式组件优点" class="sidebar-link">16.react函数式组件优点？</a></li><li class="sidebar-sub-header"><a href="/react/#_17-react在1s内点击按钮多次-怎么获得最后一次的更新状态" class="sidebar-link">17.react在1s内点击按钮多次，怎么获得最后一次的更新状态？</a></li><li class="sidebar-sub-header"><a href="/react/#_18-react和vue中受控组件和不受控组件区别" class="sidebar-link">18.react和vue中受控组件和不受控组件区别？</a></li><li class="sidebar-sub-header"><a href="/react/#_19-说说对redux了解" class="sidebar-link">19.说说对redux了解？</a></li><li class="sidebar-sub-header"><a href="/react/#_20-react17-》最新是18-22年三月发布" class="sidebar-link">20.react17=》最新是18(22年三月发布)</a></li><li class="sidebar-sub-header"><a href="/react/#_21-useeffect和componentdidmount差异" class="sidebar-link">21.useEffect和componentDidMount差异？</a></li><li class="sidebar-sub-header"><a href="/react/#_22-ref" class="sidebar-link">22.ref？</a></li><li class="sidebar-sub-header"><a href="/react/#_23-组件通信" class="sidebar-link">23.组件通信</a></li><li class="sidebar-sub-header"><a href="/react/#_24-父组件如何调用子组件方法" class="sidebar-link">24.父组件如何调用子组件方法？</a></li><li class="sidebar-sub-header"><a href="/react/#_25-性能优化" class="sidebar-link">25.性能优化</a></li><li class="sidebar-sub-header"><a href="/react/#_26-react如何区分类组件和函数组件" class="sidebar-link">26.react如何区分类组件和函数组件？</a></li><li class="sidebar-sub-header"><a href="/react/#_27-jsx原理" class="sidebar-link">27.jsx原理？</a></li><li class="sidebar-sub-header"><a href="/react/#_28-props透传" class="sidebar-link">28.props透传？</a></li><li class="sidebar-sub-header"><a href="/react/#_29-空标签的作用" class="sidebar-link">29.空标签的作用？</a></li><li class="sidebar-sub-header"><a href="/react/#_30-属性和状态的区别" class="sidebar-link">30.属性和状态的区别？</a></li><li class="sidebar-sub-header"><a href="/react/#_31-插槽" class="sidebar-link">31.插槽？</a></li><li class="sidebar-sub-header"><a href="/react/#_32-声明式导航和编程式导航区别" class="sidebar-link">32.声明式导航和编程式导航区别？</a></li><li class="sidebar-sub-header"><a href="/react/#_33-反向代理" class="sidebar-link">33.反向代理？</a></li><li class="sidebar-sub-header"><a href="/react/#_34-说说对cssmodule" class="sidebar-link">34.说说对cssModule？</a></li><li class="sidebar-sub-header"><a href="/react/#_35-immutable作用" class="sidebar-link">35.immutable作用？</a></li><li class="sidebar-sub-header"><a href="/react/#_36-mobx和redux区别-都是react状态管理工具" class="sidebar-link">36.mobx和redux区别(都是react状态管理工具)？</a></li><li class="sidebar-sub-header"><a href="/react/#_37-了解过style-components吗-将html标签包装成组件" class="sidebar-link">37.了解过style-components吗？(将html标签包装成组件)</a></li><li class="sidebar-sub-header"><a href="/react/#_38-createportal作用" class="sidebar-link">38.createPortal作用？</a></li><li class="sidebar-sub-header"><a href="/react/#_39-react的lazy和suspense作用-路由懒加载" class="sidebar-link">39.react的lazy和suspense作用？(路由懒加载)</a></li><li class="sidebar-sub-header"><a href="/react/#_40-forwardref用过吗" class="sidebar-link">40.forwardRef用过吗？</a></li><li class="sidebar-sub-header"><a href="/react/#_41-dva" class="sidebar-link">41.dva</a></li><li class="sidebar-sub-header"><a href="/react/#_42-umi-乌米" class="sidebar-link">42.umi(乌米)</a></li><li class="sidebar-sub-header"><a href="/react/#_43-hooks实现一个计数器组件" class="sidebar-link">43.hooks实现一个计数器组件？</a></li><li class="sidebar-sub-header"><a href="/react/#_44-createelement和cloneelement区别" class="sidebar-link">44.createElement和cloneElement区别？</a></li><li class="sidebar-sub-header"><a href="/react/#_45-usestate和setstate区别" class="sidebar-link">45.useState和setState区别？</a></li><li class="sidebar-sub-header"><a href="/react/#_46-使用hooks有什么常见的问题" class="sidebar-link">46.使用hooks有什么常见的问题？</a></li><li class="sidebar-sub-header"><a href="/react/#_47-hoc-higher-order-component" class="sidebar-link">47.HOC(Higher Order Component)</a></li><li class="sidebar-sub-header"><a href="/react/#_48-jsx和fiber有什么关系" class="sidebar-link">48.jsx和Fiber有什么关系？</a></li><li class="sidebar-sub-header"><a href="/react/#_49-react17之前jsx文件为什么要声明import-react-from-react-之后为什么不需要了" class="sidebar-link">49.react17之前jsx文件为什么要声明import React from 'react'，之后为什么不需要了？</a></li><li class="sidebar-sub-header"><a href="/react/#_50-react中怎么使用async-await" class="sidebar-link">50.react中怎么使用async/await？</a></li><li class="sidebar-sub-header"><a href="/react/#_51-为什么hooks不能写在条件判断中" class="sidebar-link">51.为什么hooks不能写在条件判断中？</a></li><li class="sidebar-sub-header"><a href="/react/#_52-render作用" class="sidebar-link">52.render作用？</a></li><li class="sidebar-sub-header"><a href="/react/#_53-react怎么区分class组件和function组件" class="sidebar-link">53.react怎么区分Class组件和Function组件？</a></li><li class="sidebar-sub-header"><a href="/react/#_54-请说一下react的渲染过程" class="sidebar-link">54.请说一下react的渲染过程？</a></li><li class="sidebar-sub-header"><a href="/react/#_55-react有哪些优化手段" class="sidebar-link">55.react有哪些优化手段？</a></li><li class="sidebar-sub-header"><a href="/react/#_56-我们写的事件是绑定在dom上么-如果不是绑定在哪里" class="sidebar-link">56.我们写的事件是绑定在dom上么，如果不是绑定在哪里？</a></li><li class="sidebar-sub-header"><a href="/react/#_57-为什么我们的事件手动绑定this" class="sidebar-link">57.为什么我们的事件手动绑定this？</a></li><li class="sidebar-sub-header"><a href="/react/#_58-为什么不能用-return-false-来阻止事件的默认行为" class="sidebar-link">58.为什么不能用 return false 来阻止事件的默认行为？</a></li><li class="sidebar-sub-header"><a href="/react/#_59-react怎么通过dom元素-找到与之对应的-fiber对象的" class="sidebar-link">59.react怎么通过dom元素，找到与之对应的 fiber对象的？</a></li><li class="sidebar-sub-header"><a href="/react/#_60-react-hooks比较比的是值还是内存地址" class="sidebar-link">60.react Hooks比较比的是值还是内存地址？</a></li><li class="sidebar-sub-header"><a href="/react/#_61-手写防抖节流hook-》不使用usecallback-因为会把处理函数一起缓存起来-这样比如搜索用防抖节流-搜素值变化由于函数被缓存-就无法实时搜索" class="sidebar-link">61.手写防抖节流hook=》不使用useCallback，因为会把处理函数一起缓存起来，这样比如搜索用防抖节流，搜素值变化由于函数被缓存，就无法实时搜索</a></li><li class="sidebar-sub-header"><a href="/react/#_62-如何理解不可变值-性-数据-immutable" class="sidebar-link">62.如何理解不可变值｜性｜数据(immutable)？</a></li><li class="sidebar-sub-header"><a href="/react/#_63-如何在react中创建组件" class="sidebar-link">63.如何在react中创建组件？</a></li><li class="sidebar-sub-header"><a href="/react/#_64-状态提升" class="sidebar-link">64.状态提升？</a></li><li class="sidebar-sub-header"><a href="/react/#_65-react中为什么使用classname而不是class" class="sidebar-link">65.react中为什么使用className而不是class？</a></li><li class="sidebar-sub-header"><a href="/react/#_66-react的super和super-props-区别" class="sidebar-link">66.react的super和super(props)区别？</a></li><li class="sidebar-sub-header"><a href="/react/#_67-如何编写mapdispatchtoprops" class="sidebar-link">67.如何编写mapDispatchToProps()？</a></li><li class="sidebar-sub-header"><a href="/react/#_68-react事件绑定原理" class="sidebar-link">68.react事件绑定原理？</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#react">React</a><ul><li><a href="#_1-diff算法-及虚拟dom">1.diff算法？及虚拟dom？</a></li><li><a href="#_2-fiber是什么">2.fiber是什么？</a></li><li><a href="#_3-setstate是同步还是异步-私下简单记忆-同步逻辑中就异步-异步逻辑中就同步">3.setState是同步还是异步？(私下简单记忆：同步逻辑中就异步，异步逻辑中就同步)</a></li><li><a href="#_4-ui组件与容器组件">4.UI组件与容器组件？</a></li><li><a href="#_5-todo">5.//TODO</a></li><li><a href="#_6-生命周期-只针对类-函数式组件无生命周期-》括号里都是react16以后的钩子">6.生命周期(只针对类，函数式组件无生命周期)=》括号里都是react16以后的钩子</a></li><li><a href="#_7-react脚手架">7.react脚手架</a></li><li><a href="#_8-shouldcomponentupdate">8.shouldComponentUpdate？</a></li><li><a href="#_9-react-router-dom和react-router区别">9.react-router-dom和react-router区别？</a></li><li><a href="#_10-setstate时发生了什么">10.setState时发生了什么？</a></li><li><a href="#_11-怎么理解在react中-一切都是属性">11.怎么理解在react中，一切都是属性？</a></li><li><a href="#_12-todo">12.//TODO</a></li><li><a href="#_13-常见hooks功能-react-16-8引入了hooks">13.常见hooks功能(react 16.8引入了hooks)</a></li><li><a href="#_14-hooks如何模拟componentdidmount">14.hooks如何模拟componentDidMount？</a></li><li><a href="#_15-hooks如何部分替代redux功能">15.hooks如何部分替代redux功能？</a></li><li><a href="#_16-react函数式组件优点">16.react函数式组件优点？</a></li><li><a href="#_17-react在1s内点击按钮多次-怎么获得最后一次的更新状态">17.react在1s内点击按钮多次，怎么获得最后一次的更新状态？</a></li><li><a href="#_18-react和vue中受控组件和不受控组件区别">18.react和vue中受控组件和不受控组件区别？</a></li><li><a href="#_19-说说对redux了解">19.说说对redux了解？</a></li><li><a href="#_20-react17-》最新是18-22年三月发布">20.react17=》最新是18(22年三月发布)</a></li><li><a href="#_21-useeffect和componentdidmount差异">21.useEffect和componentDidMount差异？</a></li><li><a href="#_22-ref">22.ref？</a></li><li><a href="#_23-组件通信">23.组件通信</a></li><li><a href="#_24-父组件如何调用子组件方法">24.父组件如何调用子组件方法？</a></li><li><a href="#_25-性能优化">25.性能优化</a></li><li><a href="#_26-react如何区分类组件和函数组件">26.react如何区分类组件和函数组件？</a></li><li><a href="#_27-jsx原理">27.jsx原理？</a></li><li><a href="#_28-props透传">28.props透传？</a></li><li><a href="#_29-空标签的作用">29.空标签的作用？</a></li><li><a href="#_30-属性和状态的区别">30.属性和状态的区别？</a></li><li><a href="#_31-插槽">31.插槽？</a></li><li><a href="#_32-声明式导航和编程式导航区别">32.声明式导航和编程式导航区别？</a></li><li><a href="#_33-反向代理">33.反向代理？</a></li><li><a href="#_34-说说对cssmodule">34.说说对cssModule？</a></li><li><a href="#_35-immutable作用">35.immutable作用？</a></li><li><a href="#_36-mobx和redux区别-都是react状态管理工具">36.mobx和redux区别(都是react状态管理工具)？</a></li><li><a href="#_37-了解过style-components吗-将html标签包装成组件">37.了解过style-components吗？(将html标签包装成组件)</a></li><li><a href="#_38-createportal作用">38.createPortal作用？</a></li><li><a href="#_39-react的lazy和suspense作用-路由懒加载">39.react的lazy和suspense作用？(路由懒加载)</a></li><li><a href="#_40-forwardref用过吗">40.forwardRef用过吗？</a></li><li><a href="#_41-dva">41.dva</a></li><li><a href="#_42-umi-乌米">42.umi(乌米)</a></li><li><a href="#_43-hooks实现一个计数器组件">43.hooks实现一个计数器组件？</a></li><li><a href="#_44-createelement和cloneelement区别">44.createElement和cloneElement区别？</a></li><li><a href="#_45-usestate和setstate区别">45.useState和setState区别？</a></li><li><a href="#_46-使用hooks有什么常见的问题">46.使用hooks有什么常见的问题？</a></li><li><a href="#_47-hoc-higher-order-component">47.HOC(Higher Order Component)</a></li><li><a href="#_48-jsx和fiber有什么关系">48.jsx和Fiber有什么关系？</a></li><li><a href="#_49-react17之前jsx文件为什么要声明import-react-from-react-之后为什么不需要了">49.react17之前jsx文件为什么要声明import React from 'react'，之后为什么不需要了？</a></li><li><a href="#_50-react中怎么使用async-await">50.react中怎么使用async/await？</a></li><li><a href="#_51-为什么hooks不能写在条件判断中">51.为什么hooks不能写在条件判断中？</a></li><li><a href="#_52-render作用">52.render作用？</a></li><li><a href="#_53-react怎么区分class组件和function组件">53.react怎么区分Class组件和Function组件？</a></li><li><a href="#_54-请说一下react的渲染过程">54.请说一下react的渲染过程？</a></li><li><a href="#_55-react有哪些优化手段">55.react有哪些优化手段？</a></li><li><a href="#_56-我们写的事件是绑定在dom上么-如果不是绑定在哪里">56.我们写的事件是绑定在dom上么，如果不是绑定在哪里？</a></li><li><a href="#_57-为什么我们的事件手动绑定this">57.为什么我们的事件手动绑定this？</a></li><li><a href="#_58-为什么不能用-return-false-来阻止事件的默认行为">58.为什么不能用 return false 来阻止事件的默认行为？</a></li><li><a href="#_59-react怎么通过dom元素-找到与之对应的-fiber对象的">59.react怎么通过dom元素，找到与之对应的 fiber对象的？</a></li><li><a href="#_60-react-hooks比较比的是值还是内存地址">60.react Hooks比较比的是值还是内存地址？</a></li><li><a href="#_61-手写防抖节流hook-》不使用usecallback-因为会把处理函数一起缓存起来-这样比如搜索用防抖节流-搜素值变化由于函数被缓存-就无法实时搜索">61.手写防抖节流hook=》不使用useCallback，因为会把处理函数一起缓存起来，这样比如搜索用防抖节流，搜素值变化由于函数被缓存，就无法实时搜索</a></li><li><a href="#_62-如何理解不可变值-性-数据-immutable">62.如何理解不可变值｜性｜数据(immutable)？</a></li><li><a href="#_63-如何在react中创建组件">63.如何在react中创建组件？</a></li><li><a href="#_64-状态提升">64.状态提升？</a></li><li><a href="#_65-react中为什么使用classname而不是class">65.react中为什么使用className而不是class？</a></li><li><a href="#_66-react的super和super-props-区别">66.react的super和super(props)区别？</a></li><li><a href="#_67-如何编写mapdispatchtoprops">67.如何编写mapDispatchToProps()？</a></li><li><a href="#_68-react事件绑定原理">68.react事件绑定原理？</a></li></ul></li></ul></div><p></p> <h2 id="react"><a href="#react" class="header-anchor">#</a> React</h2> <h3 id="_1-diff算法-及虚拟dom"><a href="#_1-diff算法-及虚拟dom" class="header-anchor">#</a> 1.diff算法？及虚拟dom？</h3> <p>diff算法本质就是找出虚拟dom和真实dom的差异</p> <h4 id="什么是调和-协调-reconciliation"><a href="#什么是调和-协调-reconciliation" class="header-anchor">#</a> 什么是调和(协调)=&gt;reconciliation？</h4> <p>将虚拟dom转成真实dom的过程叫做调和。diff算法就是调和的具体表现</p> <h4 id="react源码划分"><a href="#react源码划分" class="header-anchor">#</a> react源码划分</h4> <p>分成core，renderer，reconciler(包括了组件的挂载，卸载，更新等过程)</p> <h3 id="_2-fiber是什么"><a href="#_2-fiber是什么" class="header-anchor">#</a> 2.fiber是什么？</h3> <p>调和算法=&gt;用来解决大量同步计算阻塞浏览器UI渲染的问题=&gt;fiber本身可以看作一个js对象，fiber是链表结构(环形链表)
是一种基于浏览器的单线程调度算法。主要用来做异步diff(虚拟dom渐进式渲染)，类似链表=》将原来的递归diff变成了遍历diff</p> <h4 id="fiber结构"><a href="#fiber结构" class="header-anchor">#</a> fiber结构</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const fiber = {
    stateNode, // 节点实例
    child,     // 子节点 =&gt; 指向当前节点的第一个子节点
    sibling,   // 兄弟节点 =&gt; 指向当前节点下一个兄弟节点
    return     // 父节点 =&gt; 指向当前节点的父节点
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="scheduler-调度器实现任务分配-6种优先级"><a href="#scheduler-调度器实现任务分配-6种优先级" class="header-anchor">#</a> scheduler=&gt;调度器实现任务分配=&gt;6种优先级</h4> <ul><li>synchronous =&gt; 同Stack Reconciler 同步执行</li> <li>task =&gt; next tick之前执行</li> <li>animation =&gt; 下一帧之前执行</li> <li>high =&gt; 不久的将来立即执行</li> <li>low =&gt; 稍微延迟执行也可以</li> <li>offscreen =&gt; 下一次render时或者scroll时才执行</li></ul> <h4 id="fiber影响"><a href="#fiber影响" class="header-anchor">#</a> fiber影响</h4> <p>fiber异步diff，任务的更新过程可能会被打断，所以在更新过程中，render及其之前的生命周期函数可能会被调用多次
以下生命周期中不应出现副作用=&gt;是unsafe的原因，也是钩子废弃原因</p> <ul><li>shouldComponentUpdate</li> <li>componentWillMount(UNSAFE_componentWillMount)</li> <li>componentWillReceiveProps(UNSAFE_componentWillReceiveProps)</li> <li>componentWillUpdate(UNSAFE_componentWillUpdate)</li></ul> <h4 id="react内部分层"><a href="#react内部分层" class="header-anchor">#</a> react内部分层</h4> <p>virtual dom 层 =&gt; 负责页面样式
reconciler 层 =&gt; 负责调用组件生命周期方法，进行diff计算
renderer 层 =&gt; 根据不同平台，渲染相同的页面 =&gt; 如reactDom和reactNative</p> <h4 id="fiber原理"><a href="#fiber原理" class="header-anchor">#</a> fiber原理</h4> <ul><li>在react16之前(使用stack reconciler(栈协调器))，当react要更新dom时，从diff到更新dom，整个过程一气呵成，不能被打断。
当更新组件比较复杂，层级过深，此时如果用户点击了页面某个按钮，可能会因为批量更新dom还未完成，导致按钮无法响应的问题</li> <li>react16之后使用的是fiber reconciler(纤维协调器)，将递归中无法中断的更新重构为迭异步可中断过程，这样就能更好的控制组件的渲染。
可以分段执行(链表结构)</li></ul> <h4 id="双缓存是什么"><a href="#双缓存是什么" class="header-anchor">#</a> 双缓存是什么？</h4> <p>react维护了两个fiber树</p> <ul><li>current Fiber 用于渲染页面</li> <li>workingProgress Fiber 用在内存构建中，构建完成后直接替换current Fiber树</li></ul> <h4 id="diff算法如何从o-n3-优化到o-n-的-》可以理解为o-n3-是传统树递归diff的时间复杂度-》基于哪两个假设"><a href="#diff算法如何从o-n3-优化到o-n-的-》可以理解为o-n3-是传统树递归diff的时间复杂度-》基于哪两个假设" class="header-anchor">#</a> diff算法如何从O(n3)优化到O(n)的=》可以理解为O(n3)是传统树递归diff的时间复杂度=》基于哪两个假设</h4> <ol><li>两个不同类型的元素会产生不同的树</li> <li>同一层级的一组节点，他们可以通过唯一的id进行区分</li></ol> <h4 id="如何从o-n-3-转成o-n-》基于两大假设通过三大策略来优化"><a href="#如何从o-n-3-转成o-n-》基于两大假设通过三大策略来优化" class="header-anchor">#</a> 如何从O(n^3)转成O(n)=》基于两大假设通过三大策略来优化</h4> <p>React用三大策略将O(n^3)转成O(n)复杂度</p> <ol><li>tree diff
只比较同一层的dom节点(忽略dom节点的跨层级移动，如果发生会直接删除旧节点使用新节点)=》只需要对树进行一次遍历就可以完成整棵树的比较</li> <li>component diff (同一类型的组件会继续比较，不同类型的直接替换)
同一类型的两个组件按原来层级比较的方式继续比较即可(shouldComponentUpdate可以判断是否需要计算)
不同类型组件，会把将要被改变组件判断为脏组件(dirtyComponent)，从而替换整个组件的所有节点</li> <li>element diff
同一层级的一组子节点，通过唯一ID区分即key(diff提供三种节点操作：删除，移动，插入)</li></ol> <h3 id="_3-setstate是同步还是异步-私下简单记忆-同步逻辑中就异步-异步逻辑中就同步"><a href="#_3-setstate是同步还是异步-私下简单记忆-同步逻辑中就异步-异步逻辑中就同步" class="header-anchor">#</a> 3.setState是同步还是异步？(私下简单记忆：同步逻辑中就异步，异步逻辑中就同步)</h3> <p>在生命周期函数和合成事件中是异步的，在原生事件和setTimeout中是同步的</p> <ul><li>在react事件中是异步</li> <li>在setTimeout或者自定义dom事件中都是同步</li></ul> <h4 id="为什么不直接都同步"><a href="#为什么不直接都同步" class="header-anchor">#</a> 为什么不直接都同步？</h4> <p>做成异步是为了减少频繁setState带来的性能损耗=》setState会重新渲染页面</p> <h4 id="什么是合成事件"><a href="#什么是合成事件" class="header-anchor">#</a> 什么是合成事件？</h4> <ul><li>提供统一API去抹平浏览器差异，所有事件都绑定在React根元素(Root Element)进行事件委托，不是绑在元素上</li> <li>比如onChange事件就是合成事件(在react中onChange也有OnInput的功能，多个原生js事件的合成事件)</li></ul> <h4 id="为什么不能直接更新状态"><a href="#为什么不能直接更新状态" class="header-anchor">#</a> 为什么不能直接更新状态？</h4> <p>不能触发UI重新渲染=》setState里面有做处理</p> <h3 id="_4-ui组件与容器组件"><a href="#_4-ui组件与容器组件" class="header-anchor">#</a> 4.UI组件与容器组件？</h3> <ul><li>UI组件： 只负责UI，没有业务逻辑，没有状态，数据由props提供，不使用redux的api</li> <li>容器组件：负责管理数据和业务逻辑，不负责UI，有内部状态，使用redux的api
=》容器组件用来处理获取数据，订阅redux存储等的组件，里面没有html</li></ul> <h3 id="_5-todo"><a href="#_5-todo" class="header-anchor">#</a> 5.//TODO</h3> <h3 id="_6-生命周期-只针对类-函数式组件无生命周期-》括号里都是react16以后的钩子"><a href="#_6-生命周期-只针对类-函数式组件无生命周期-》括号里都是react16以后的钩子" class="header-anchor">#</a> 6.生命周期(只针对类，函数式组件无生命周期)=》括号里都是react16以后的钩子</h3> <h4 id="初始化-挂载期-一个组件实例初次被创建的过程"><a href="#初始化-挂载期-一个组件实例初次被创建的过程" class="header-anchor">#</a> 初始化(挂载期)：一个组件实例初次被创建的过程</h4> <ul><li>constructor:(先super(props))初始化state
(static getDerivedStateFromProps替代componentWillMount，旧的即将废弃)</li> <li>componentWillMount:render前最后一次修改状态的机会，可以用来做状态计算或处理，只走一次，在渲染前调用=&gt;过时</li> <li>render:只能访问this.props和this.stat，不允许修改状态和dom</li> <li>componentDidMount(CDM):成功render并渲染完成真实dom之后会触发(第一次渲染后调用)，可以修改dom，只走一次，可以用来放setTimeout，setInterval或者ajax请求</li></ul> <h4 id="源码过程"><a href="#源码过程" class="header-anchor">#</a> 源码过程</h4> <p>constructor(构造函数，初始化状态值)-&gt;getInitialState(设置状态机)-&gt;getDefaultProps(获取默认的props)-&gt;UNSAFE_componentWillMount(首次渲染前执行)
-&gt;render(渲染组件)-&gt;componentDidMount(render渲染之后执行的操作)</p> <h4 id="运行中-更新期-组件在创建后再次渲染的过程"><a href="#运行中-更新期-组件在创建后再次渲染的过程" class="header-anchor">#</a> 运行中(更新期)：组件在创建后再次渲染的过程</h4> <p>(static getDerivedStateFromProps 替代componentWillReceiveProps， 旧的即将废弃)</p> <ul><li>componentWillReceiveProps:父组件修改属性触发，会最先获得父组件传来的属性=&gt;提供了最新的props，此时的this.props是老的=》过时
=》在组件收到一个新props(更新后)调用，初始化render时不调用</li> <li>shouldComponentUpdate(SCU):返回boolean值，返回false阻止render调用，在组件接受到新props或state时调用(初始化或者forceUpdate时不调用)
=》通俗来说状态不变不更新false，状态改变要更新true=》提供了最新的props和最新的state，此时的this.state是老状态
(getSnapshotBeforeUpdate替代componentWillUpdate， 旧的即将废弃)</li> <li>componentWillUpdate:不能修改属性和状态，在组件收到新props或者state但还没render时调用，初始化不调用=&gt;过时</li> <li>render:只能访问this.props和this.stat，不能修改状态和dom</li> <li>componentDidUpdate(CDU):组件更新完成后立即调用，初始化不调用可以修改dom=》该方法还提供了老的props和老的state=》可以通过比较新老数据异同来决定是否触发操作</li></ul> <h4 id="源码过程-2"><a href="#源码过程-2" class="header-anchor">#</a> 源码过程</h4> <p>UNSAFE_componentsWillReceiveProps(当父组件更新子组件state时，该方法会被调用)
-&gt;shouldComponentUpdate(该方法决定组件state或props的改变是否需要重新渲染组件)
-&gt;UNSAFE_componentWillUpdate(在组件接收新的state或者props时，重新渲染之前调用该方法)
-&gt;componentDidUpdate(在组件重新渲染后调用该方法)</p> <h4 id="销毁-卸载期-组件在使用完被销毁的过程"><a href="#销毁-卸载期-组件在使用完被销毁的过程" class="header-anchor">#</a> 销毁(卸载期)：组件在使用完被销毁的过程</h4> <ul><li>componentWillUnmount(用来将组件从DOM树删除):组件从dom移除时立即调用=》在删除组件之前进行清理操作，清除计时器或事件监听</li></ul> <h4 id="unsafe"><a href="#unsafe" class="header-anchor">#</a> UNSAFE</h4> <p>unsafe的生命周期都属于fiber的第一阶段，这个阶段优先级都比较低，有可能被打断，将来可能被执行多次，所以不安全</p> <h4 id="新生命周期-目的就是解决老生命周期三个unsafe生命周期的问题"><a href="#新生命周期-目的就是解决老生命周期三个unsafe生命周期的问题" class="header-anchor">#</a> 新生命周期=&gt;目的就是解决老生命周期三个unsafe生命周期的问题</h4> <p>getDerivedStateFromProps()会在初始化挂载和更新(自身状态更新或父状态更新)时触发，在dom渲染前调用=》可以获取最新的props和state，是类属性，前面要加static，没有this，需要返回值没有就返回null
=&gt;在初始化可以代替componentWillMount,在父传子的时候可以代替componentWillReceiveProps
getSnapshotBeforeUpdate代替componentWillUpdate(不能同时使用)，在update发生时，在render之后dom渲染前返回值，作为componentDidUpdate的第三个参数
=》可以用来做滚动条定位，页面刷新仍然保持原来的滚动条</p> <h4 id="错误阶段"><a href="#错误阶段" class="header-anchor">#</a> 错误阶段</h4> <p>(static getDerivedStateFromError)
(componentDidCatch)</p> <h3 id="_7-react脚手架"><a href="#_7-react脚手架" class="header-anchor">#</a> 7.react脚手架</h3> <ul><li>create-react-app(npx create-react-app 项目名)</li> <li>umijs</li></ul> <h4 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h4> <ul><li>create-react-app不包含路由，但是在webpack打包层的优化做了比较多</li> <li>而umi是以路由为基础的(实现了完整的生命周期),但兼容性不如create-react-app(不支持ie8以下，react16.8以下也不支持)</li> <li>umi创建的项目结构更复杂，原来的会更简单些=&gt;umi开箱即用</li></ul> <h4 id="react最流行的css-in-js库"><a href="#react最流行的css-in-js库" class="header-anchor">#</a> react最流行的css in js库</h4> <p>emotion，styled-components</p> <h3 id="_8-shouldcomponentupdate"><a href="#_8-shouldcomponentupdate" class="header-anchor">#</a> 8.shouldComponentUpdate？</h3> <ul><li>render()函数决定组件该渲染什么，shouldComponentUpdate决定组件什么时候不需要渲染</li> <li>react的component提供了shouldComponentUpdate的默认实现，会返回一个true代表每次更新都要调用所有生命周期函数=》</li> <li>所以我们通过自定义shouldComponentUpdate方法，使它在需要更新的时候才返回true，这样达到一个性能优化的效果</li> <li>只要组件的completed和text没变，就可以让shouldComponentUpdate返回false</li> <li>react-redux默认实现对比props方面采用了浅比较(不采用深比较是因为性能消耗的问题=》可以通过immutable这个库来实现深比较)</li></ul> <h4 id="结论"><a href="#结论" class="header-anchor">#</a> 结论</h4> <p>可以在shouldComponentUpdate使用浅比较来比较prop，深比较通过Immutable这个库来实现</p> <h3 id="_9-react-router-dom和react-router区别"><a href="#_9-react-router-dom和react-router区别" class="header-anchor">#</a> 9.react-router-dom和react-router区别？</h3> <p>react-router-dom是在react-router基础上开发的，额外提供了BrowserRouter,HashRouter,Link,NavLink组件用来路由跳转</p> <ul><li>(browserRouter,hashRouter替代了router，link和NavLink作用类似a标签)</li> <li>browserRouter是history模式，hashRouter是hash模式</li> <li>Redirect用来强制路由重定向</li> <li>Switch用来组合路由</li></ul> <h4 id="react-dom"><a href="#react-dom" class="header-anchor">#</a> react-dom</h4> <p>用来操作dom</p> <h4 id="react-dom常用api"><a href="#react-dom常用api" class="header-anchor">#</a> react-dom常用api</h4> <ul><li>createPortal()=&gt;传送门，该节点在dom组件层次结构外</li> <li>render()用来将react元素渲染到container提供的dom中</li></ul> <h3 id="_10-setstate时发生了什么"><a href="#_10-setstate时发生了什么" class="header-anchor">#</a> 10.setState时发生了什么？</h3> <p>(每次setState，组件会重新渲染)</p> <ul><li>在函数式组件中setState时，如果两次设置的state相同时，组件不会重新渲染</li> <li>在事件中多次调用setState，会批量进行渲染</li> <li>在事件外多次调用setState，不会重新渲染</li> <li>react18后同一函数多次调用setState都会批量渲染</li></ul> <h4 id="setstate之后发生什么"><a href="#setstate之后发生什么" class="header-anchor">#</a> setState之后发生什么？</h4> <ol><li>传入的参数和组件当前状态合并，触发调和</li> <li>根据新状态构建react元素树</li> <li>得到元素树后会重新计算新老树差异，然后按需更新=》不用全部重新渲染</li></ol> <h3 id="_11-怎么理解在react中-一切都是属性"><a href="#_11-怎么理解在react中-一切都是属性" class="header-anchor">#</a> 11.怎么理解在react中，一切都是属性？</h3> <p>组件会将UI分成多个独立的部分，每个组件彼此独立</p> <h3 id="_12-todo"><a href="#_12-todo" class="header-anchor">#</a> 12.//TODO</h3> <h3 id="_13-常见hooks功能-react-16-8引入了hooks"><a href="#_13-常见hooks功能-react-16-8引入了hooks" class="header-anchor">#</a> 13.常见hooks功能(react 16.8引入了hooks)</h3> <p>hook只能在顶层使用，不能在循环，条件或嵌套函数中使用
1.useState声明变量：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class中this.state = {count: 0}
hook中const [count, setCount] = useState(0)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2.useEffect用来处理副作用，useLayoutEffect同步处理副作用=&gt;不能在useEffect中使用useState
=&gt;函数会在组件渲染后执行(网络请求，dom操作都属于副作用)</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>useEffect(()  =&gt;  {
// Async Action
}, [dependencies，为空数组表示不依赖，数组有值该值改变会再次触发useEffect])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果传空数组只执行一次，可以通过return一个函数来对定时器进行销毁</p> <h4 id="useeffect和uselayouteffect区别"><a href="#useeffect和uselayouteffect区别" class="header-anchor">#</a> useEffect和useLayoutEffect区别？</h4> <p>调用时机不同，useLayoutEffect和原来componentDidMount和ComponentDidUpdate一致，在dom更新后马上调用，会阻塞页面渲染，useEffect是等整个页面渲染完才调用，官方建议用useEffect
=》实际开发中，如果useEffect操作dom导致页面抖动，可以把操作dom部分放到useLayoutEffect中，这样就只会触发一次重绘和重排
=》useLayoutEffect先于useEffect执行
3.useCallback</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>useCallback(() =&gt; {
}, [dependencies,为空数组在第一次创建后就被缓存后续不改变，不传入第二个参数每次都会重新调用])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>用来优化性能，能够对函数进行缓存(不执行)，只有依赖的数据发生变化，才会重新缓存新的回调函数
4.useMemo=》不推荐所有组件都进行缓存，大量组件初始化时被缓存，会导致过多的内存消耗，影响初始化渲染速度=&gt;不能进行有副作用的操作，如网络请求
用来优化性能，依赖不变的情况下，会返回相同的引用，避免子组件重复渲染，可以完全替代useCallback，区别是useMemo会直接返回函数结果</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const memoizedValue = useMemo(() =&gt; 计算函数(a, b), [a, b依赖]); 返回一个缓存值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>5.useRef
useRef(0)=》能设置初始值 这个方法用来获取组件实例或dom元素
=》创建ref可以通过createRef和useRef</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const refContainer = useRef(initialValue);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>6.useContext
组件间共享状态，子组件(消费者)可以通过useContext()获取父组件的属性，生产者还是通过React.createContext去创建context对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const value = useContext(MyContext);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>7.useReducer=》先有redux后有useReducer=》不支持异步，异步使用redux=》作用是在复杂场景下替换useState</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const [state, dispatch] = useReducer(reducer函数, 初始值); 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>reducer函数可以获得之前的state和dispatch传递的参数reducer(prevState, 传递的参数)</p> <h4 id="usestate和usereducer区别"><a href="#usestate和usereducer区别" class="header-anchor">#</a> useState和useReducer区别？</h4> <ul><li>useState如果初始值是函数返回值要通过回调函数的方式设置，直接设置会导致没有重新赋值但获取初始值的函数重复执行=&gt;通过getCount获取初始值，重复执行getCount</li> <li>useReducer初始值如果通过函数返回，当组件重新渲染时会重复执行这个函数</li> <li>useState修改状态，同个useState声明的状态会被覆盖，而useReducer会按顺序执行=&gt;setCount(2)两次一个是2，一个是4</li></ul> <h4 id="usememo和usecallback区别"><a href="#usememo和usecallback区别" class="header-anchor">#</a> useMemo和useCallback区别？</h4> <p>useCallback第一次不会执行函数，只是缓存函数，useMemo会执行并把执行结果返回</p> <h4 id="自定义hooks钩子-》作用是逻辑复用-允许没有返回值-》只能在函数组件和其他hooks中调用-同时其他hook也只能在自定义hook内部调用-如果用普通函数抽离逻辑去处理没办法使用hooks"><a href="#自定义hooks钩子-》作用是逻辑复用-允许没有返回值-》只能在函数组件和其他hooks中调用-同时其他hook也只能在自定义hook内部调用-如果用普通函数抽离逻辑去处理没办法使用hooks" class="header-anchor">#</a> 自定义hooks钩子=》作用是逻辑复用，允许没有返回值=》只能在函数组件和其他hooks中调用，同时其他hook也只能在自定义hook内部调用(如果用普通函数抽离逻辑去处理没办法使用hooks)</h4> <p>自定义钩子必须以use开头，函数内部可以调用其他hook</p> <h4 id="实例-》可以自定义逻辑性和功能性的hooks-两组件使用相同的hook不会共享状态"><a href="#实例-》可以自定义逻辑性和功能性的hooks-两组件使用相同的hook不会共享状态" class="header-anchor">#</a> 实例=》可以自定义逻辑性和功能性的hooks=&gt;两组件使用相同的hook不会共享状态</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 逻辑性hooks 获取列表后通过useList()获取返回值
function useList() {
    const [list,setList] = setState([])
    useEffect(()=&gt; {
        axios({}).then(res=&gt; {
            setList(res)
        })
    }, [])
    return {list}
}
function app() {
    const {list} = useList()
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>// 功能性hooks
const useWidth = () =&gt; {
    const [width, setWidth] = useState(window.innerWidth)
    const onResize = () =&gt; {
        setWidth(window.innerWidth)
    }
    useEffect(() =&gt; {
        window.addEventListener('resize', onResize)
        return () =&gt; {
            window.removeEventListener('resize', onResize)
        }
    }, [])
    return {width}
}
// 页面上通过const {width} = useWidth()拿到width 然后在html上使用&lt;button width={width}/&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="usestate为什么要使用数组-不用对象"><a href="#usestate为什么要使用数组-不用对象" class="header-anchor">#</a> *useState为什么要使用数组，不用对象？</h4> <p>降低使用的复杂度，因为使用对象的话使用多次就需要通过取别名的方式</p> <h4 id="为什么使用hooks-官方更推荐用hooks写法"><a href="#为什么使用hooks-官方更推荐用hooks写法" class="header-anchor">#</a> 为什么使用hooks？(官方更推荐用hooks写法)</h4> <ul><li>高阶组件为了复用，使得代码层级更复杂</li> <li>生命周期复杂</li> <li>函数式组件无状态，如果需要状态就要改成类组件，不方便=》主要原因</li> <li>*不用操心this指向问题</li></ul> <h4 id="hooks原理-》基于fiber-在fiber节点上放一个链表"><a href="#hooks原理-》基于fiber-在fiber节点上放一个链表" class="header-anchor">#</a> hooks原理=》基于fiber，在fiber节点上放一个链表</h4> <p>。对于effect副作用钩子，会绑定在workInProgress.updateQueue上，等到commit阶段，dom树会构建完成，再去执行每个effect副作用钩子
核心：hooks主要通过闭包来保存状态，使用链表保存hooks
初始化：renderWithHooks执行函数组件
mount阶段：</p> <ul><li>每个hooks都会通过mountWorkInProgressHook生成一个hook对象，每个hooks以链表的形式保存(.next)，赋值给workInProgress(Fiber节点)的memoizedState属性</li> <li>每个hook对象包含memoizedState(useState保存state|useEffect保存effect对象|useMemo保存缓存值和deps|useRef保存ref对象)，
baseQueue(useState和useReducer中保存最新的更新队列),baseState(useState和useReducer一次更新产生的最新state值),queue(保存待更新队列pendingQueue，更新函数dispatch信息)，
next(指向下一个hooks对象)
(mountState初始化useState，dispatchAction控制无状态组件更新，mountEffect初始化useEffect，mountMemo初始化useMemo，mountRef初始化useRef)
update阶段：</li> <li>通过updateWorkInProgressHook更新hooks链表，找到对应hooks</li> <li>updateState得到最新state</li> <li>updateEffect更新updateQueue</li> <li>updateMemo判断deps，获取/更新缓存</li> <li>updateRef更新ref对象</li></ul> <h4 id="hook中的memoizedstate和fiber中的memoizedstate区别"><a href="#hook中的memoizedstate和fiber中的memoizedstate区别" class="header-anchor">#</a> hook中的memoizedState和fiber中的memoizedState区别？</h4> <p>hook中是用来保存state值，fiber中是指向当前fiber下hook队列的首个hook，因为hook是链表结构，通过这个hook可以访问整个hook队列</p> <h3 id="_14-hooks如何模拟componentdidmount"><a href="#_14-hooks如何模拟componentdidmount" class="header-anchor">#</a> 14.hooks如何模拟componentDidMount？</h3> <p>使用useEffect，把第二个参数设为[] =》useEffect(callback,[])=》只在初次渲染时调用，如果不设置第二个参数每次都会调用</p> <h4 id="useeffect模拟componentdidupdate"><a href="#useeffect模拟componentdidupdate" class="header-anchor">#</a> useEffect模拟componentDidUpdate</h4> <ul><li>使用条件判断依赖是否是初始值，不是就走更新逻辑=》缺点是多个依赖项需要多次比较</li> <li>使用useRef设置一个初始值进行比较</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const mounting = useRef(true);
   useEffect(() =&gt; {
      if (mounting.current) {
          console.log(&quot;初次&quot;)
          mounting.current = false;
          return 
      }
      console.log(&quot;DidUpdated&quot;)
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_15-hooks如何部分替代redux功能"><a href="#_15-hooks如何部分替代redux功能" class="header-anchor">#</a> 15.hooks如何部分替代redux功能？</h3> <p>useReducer + useContext =》 客户端全局store</p> <h3 id="_16-react函数式组件优点"><a href="#_16-react函数式组件优点" class="header-anchor">#</a> 16.react函数式组件优点？</h3> <ul><li>类组件需要创建类实例性能消耗大，函数式组件不需要</li> <li>函数式组件更简单易理解</li></ul> <h3 id="_17-react在1s内点击按钮多次-怎么获得最后一次的更新状态"><a href="#_17-react在1s内点击按钮多次-怎么获得最后一次的更新状态" class="header-anchor">#</a> 17.react在1s内点击按钮多次，怎么获得最后一次的更新状态？</h3> <p>setState支持两种语法</p> <ul><li>setState(updater, cb) =&gt; 接受函数类型，返回一个对象</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>this.setState((state) =&gt; { //没有 this
    return { count: state.count + 1 };   //2
});
this.setState((state) =&gt; { // 没有 this
    return { count: state.count + 1 };   //2
});
结果是+2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>setState(stateChange, cb) =&gt; 接受对象类型=》会对多个setState进行批处理更新</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>this.setState({
    count:this.state.count+1   // 1
})
this.setState({
    count:this.state.count+1    //2
})
结果是+1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>直接通过this.state.count修改值不会触发页面更新</li> <li>state发生变化会触发生命周期，当render(或shouldComponentUpdate返回false)之后this.state才更新</li></ul> <h3 id="_18-react和vue中受控组件和不受控组件区别"><a href="#_18-react和vue中受控组件和不受控组件区别" class="header-anchor">#</a> 18.react和vue中受控组件和不受控组件区别？</h3> <ul><li>受控组件一般需要初始状态和一个状态更新函数(onChange触发)</li> <li>非受控组件只在初始化接受外部数据，通过ref去获取值</li> <li>简单说受控组件由state控制，需要事件去更新，非受控组件比如在input，输入值页面就显示最新值，受控组件就不能显示</li> <li>组件的数据渲染是否被props完全控制，控制则为受控组件，否则为非受控组件</li></ul> <h3 id="_19-说说对redux了解"><a href="#_19-说说对redux了解" class="header-anchor">#</a> 19.说说对redux了解？</h3> <p>redux就是react的状态管理工具=&gt;基于js，其他框架也可以使用=&gt;是flux架构思想的一种实现=》flux由这几部分组成(actions,dispatcher,stores,action，views)</p> <ul><li>flux是单向数据流</li> <li>action中的payload时可选的，type必填，action将其转发给reducer，当reducer收到后，通过switch...case比较action中的type，对相应的内容返回新的state</li> <li>当redux状态更改时，连接到redux的组件将接受新的状态作为props。当组件接受到这些props时，它将进入更新阶段并重新渲染UI</li> <li>ReactComponents=》actions=》Reducers=》store=》ReactComponents</li> <li>通过store存储，createStore来生成store，store.getState就能拿到当前的数据</li> <li>action: {type: ''} type是必有的属性 表示action名称</li> <li>store.dispatch({type: ''})=&gt;里面是action对象</li> <li>reducer是个函数，reducer = (state,action) =&gt; {return newState} 返回的是新的state</li> <li>store.subscribe(listener)=》设置监听函数</li></ul> <h4 id="组件如何与redux连接"><a href="#组件如何与redux连接" class="header-anchor">#</a> 组件如何与redux连接？</h4> <ul><li>mapStateProps：将state映射到props上，只要state发生变化，新state会重新映射props(订阅store方式)</li> <li>mapDispatchToProps:将action creators绑定到props上，可以通过props.actions.xxx来触发</li> <li>connect用来连接store</li></ul> <h4 id="工作流"><a href="#工作流" class="header-anchor">#</a> 工作流</h4> <p>通过dispatch(action)到store，store通过reducer函数根据action进行相应的处理，然后再返回(UI)=》先subscribe订阅后dispatch触发</p> <h4 id="核心原理"><a href="#核心原理" class="header-anchor">#</a> 核心原理</h4> <p>主要是返回三个函数：subscribe订阅，dispatch触发，getState返回最新的状态</p> <ul><li>内部维护了一个数组，subscribe把回调函数保存在数组中</li> <li>内部有老的state，dispatch会根据action在reducer中做相应处理然后更新state(新的state由reducer返回)，再依次执行数组中的回调函数</li> <li>最后可以通过getState获取最新的state</li></ul> <h4 id="redux和react-redux关系"><a href="#redux和react-redux关系" class="header-anchor">#</a> redux和react-redux关系</h4> <p>react-redux目的是在组件上层传入store，下层通过dispatch去更新store的state，与redux本身没有关系</p> <h4 id="redux主要api"><a href="#redux主要api" class="header-anchor">#</a> redux主要api</h4> <ul><li>createStore()创建store</li> <li>combineReducers()组合reduces</li> <li>applyMiddleware()引入中间件</li> <li>getState()</li> <li>dispatch(action)</li> <li>subscribe(listener)</li></ul> <h4 id="react-redux主要api"><a href="#react-redux主要api" class="header-anchor">#</a> react-redux主要api</h4> <ul><li>provider</li> <li>connect组件包裹，被包裹的组件获得redux的state和action，返回一个高阶组件=》通过props.xxx去获得reducer返回的值</li> <li>useStore，useSelector，useDispatch=》要在provider包裹的组件内使用</li></ul> <h4 id="三大原则"><a href="#三大原则" class="header-anchor">#</a> 三大原则</h4> <ol><li>state以单一对象存储在store对象中</li> <li>state只读(每次只返回一个新对象)</li> <li>使用纯函数(reducer)执行state更新</li></ol> <h4 id="纯函数"><a href="#纯函数" class="header-anchor">#</a> 纯函数</h4> <ol><li>对外界没有副作用=》副作用就是调用函数后影响了原来传入的对象，不影响就没有副作用</li> <li>同样的输入得到同样的输出</li></ol> <h4 id="副作用"><a href="#副作用" class="header-anchor">#</a> 副作用</h4> <p>一个函数如果同样的输入得到不同的输出就可以说这个函数是包含副作用的</p> <h4 id="函数式编程核心概念"><a href="#函数式编程核心概念" class="header-anchor">#</a> 函数式编程核心概念</h4> <ul><li>不可变性:数据不可改变，可以通过Object.assign拷贝并返回新对象</li> <li>纯函数</li> <li>数据转换:.join()|.filter()|.map()都是返回新的数组或对象，不改变原有对象</li> <li>高阶函数:将函数作为参数或返回函数的函数</li> <li>递归+组合:将较小函数组合成更大的函数</li></ul> <h4 id="异步中间件"><a href="#异步中间件" class="header-anchor">#</a> 异步中间件</h4> <p>redux-thunk=&gt;是对象就直接向下执行(相当于没做任何处理)，是函数会先执行，在函数内部去调用dispatch=&gt;要在createStore的时候通过applyMiddleware进行配置
=&gt;源码通过typeof action === 'function' 判断是否是函数</p> <h4 id="react-redux"><a href="#react-redux" class="header-anchor">#</a> react-redux</h4> <p>connect高阶组件(HOC=》Higher-order-component)，第二个参数可以传给子组件的回调函数</p> <h4 id="redux-saga-和redux-thunk一样都是异步中间件-使用saga需要去学习-thunk通过promise使用更容易上手"><a href="#redux-saga-和redux-thunk一样都是异步中间件-使用saga需要去学习-thunk通过promise使用更容易上手" class="header-anchor">#</a> redux-saga=&gt;和redux-thunk一样都是异步中间件，使用saga需要去学习，thunk通过promise使用更容易上手</h4> <ul><li>全局监听器和接收器使用generator和saga自身的一些辅助函数实现对整个流程的管控</li> <li>也是中间件需要通过applyMiddleware进行配置=&gt;通过.run(watchSaga)调用监听函数</li> <li>通过all函数可以同时监听多个watchSaga</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>function *watchSaga() {
   while(true) {
       // take监听组件的action
       yield take(action)
       // fork同步执行异步函数getList
       yield fork(getList)
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_20-react17-》最新是18-22年三月发布"><a href="#_20-react17-》最新是18-22年三月发布" class="header-anchor">#</a> 20.react17=》最新是18(22年三月发布)</h3> <p>react使用jsx，jsx的script属性是text/babel，允许html和js混写</p> <h3 id="_21-useeffect和componentdidmount差异"><a href="#_21-useeffect和componentdidmount差异" class="header-anchor">#</a> 21.useEffect和componentDidMount差异？</h3> <p>useEffect会捕获到props和state</p> <h3 id="_22-ref"><a href="#_22-ref" class="header-anchor">#</a> 22.ref？</h3> <ul><li>旧版：组件上 ref=&quot;username&quot;  通过this.refs.username去获取 =&gt;严格模式不允许使用</li> <li>新版：声明myRef = React.createRef()  再组件上 ref={this.myRef} 通过this.myRef.current去获取</li></ul> <h4 id="refs作用"><a href="#refs作用" class="header-anchor">#</a> refs作用</h4> <p>返回对元素的引用=》可以用来操作dom和获取组件实例</p> <h3 id="_23-组件通信"><a href="#_23-组件通信" class="header-anchor">#</a> 23.组件通信</h3> <p>父子通信：props=》父向子 子向父通过调用props传过来的方法，让父组件来更新</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 子组件: Child
const Child = props =&gt;{
  const cb = msg =&gt;{
      return ()=&gt;{
          props.callback(msg)
      }
  }
  return (
      &lt;button onClick={cb(&quot;京程一灯欢迎你!&quot;)}&gt;京程一灯欢迎你&lt;/button&gt;
  )
}
// 父组件 Parent
class Parent extends Component {
    callback(msg){
        console.log(msg)
    }
    render(){
        return &lt;Child callback={this.callback.bind(this)}&gt;&lt;/Child&gt;    
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>非父子：</p> <ol><li>context进行跨层级通信 createContext创建上下文 useContext使用上下文</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>let GlobalContext = React.createContext()
然后在父组件上包装一个provide
&lt;GlobalContext.Provider&gt;
&lt;aa/&gt;
&lt;/GlobalContext.Provider value={{info: 'xx'}}&gt;
接收者通过接收
&lt;GlobalContext.Consumer&gt;
{(value) =&gt; {
    return &lt;div&gt;111&lt;/div&gt;
}}
&lt;/GlobalContext.Consumer&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="2"><li>发布订阅模式 subscribe进行订阅，通过publish进行发布</li> <li>状态提升(中间人模式) =&gt;子传父 再由父传给相应组件</li></ol> <h3 id="_24-父组件如何调用子组件方法"><a href="#_24-父组件如何调用子组件方法" class="header-anchor">#</a> 24.父组件如何调用子组件方法？</h3> <ul><li>react &gt;=16.8 函数中使用通过useRef</li> <li>react &gt;=16.4 类中使用通过createRef</li></ul> <h3 id="_25-性能优化"><a href="#_25-性能优化" class="header-anchor">#</a> 25.性能优化</h3> <h4 id="类组件"><a href="#类组件" class="header-anchor">#</a> 类组件：</h4> <ul><li>shouldComponentUpdate生命周期函数来自定义渲染逻辑</li> <li>pureComponent(纯组件)会自动比较新旧props和state，决定shouldComponentUpdate返回true或false，从而决定要不要render
=》React.component内部没有实现shouldComponentUpdate不会自动比较=》等同于React.memo都是浅比较</li></ul> <h4 id="函数组件"><a href="#函数组件" class="header-anchor">#</a> 函数组件：</h4> <ul><li>react.memo高阶函数包装组件=》HOC=》接收组件A作为参数并返回一个组件B，组件B的props没有改变，组件B就是阻止组件A重新渲染(浅比较)=》也可用于类组件
=&gt;通过React.memo(组件)对组件进行包裹=&gt;第二个参数可以自定义比较函数</li> <li>useMemo原理和pureComponent一样，都是自动比较props</li> <li>useCallBack</li></ul> <h4 id="usememo和react-memo区别"><a href="#usememo和react-memo区别" class="header-anchor">#</a> useMemo和react.memo区别？</h4> <ul><li>react.memo是hoc，useMemo是个hook</li> <li>使用React.memo返回的是一个组件，只要props没有改变就不会重新渲染</li> <li>使用useMemo当依赖项不变返回的就是缓存的值，避免重新渲染</li></ul> <h4 id="什么是memoization-记忆化"><a href="#什么是memoization-记忆化" class="header-anchor">#</a> 什么是memoization(记忆化)？</h4> <p>是个过程，允许缓存函数调用的值，这样下次调用就会直接返回值，不用再进行计算</p> <h4 id="手写usememo"><a href="#手写usememo" class="header-anchor">#</a> 手写useMemo</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>function useMemos(nextCreate, dependencies) {
  if (hookStates[hookIndex]) {   // 说明不是第一次渲染
    let [lastMemo, lastDependencies] = hookStates[hookIndex];
    let same = dependencies.every((item, index) =&gt; item === lastDependencies[index]);
    if (same) {
      hookIndex++;
      return lastMemo;
    } else {
        const newMemo = callBack()
        hookState[hookIndex++] = [newMemo, dependencies]
    }
  } else {
        const newMemo = callBack()
        hookState[hookIndex++] = [newMemo, dependencies]
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="手写usecallback"><a href="#手写usecallback" class="header-anchor">#</a> 手写useCallback</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>let hookStates: any = [];
let hookIndex: number = 0;
function useCallbacks(callback: any, dependencies: any) {
  if (hookStates[hookIndex]) {   // 说明不是第一次渲染
    let [lastCallback, lastDependencies] = hookStates[hookIndex];
    let same = dependencies.every((item: any, index: any) =&gt; item === lastDependencies[index]);
    if (same) {
        hookIndex++;
        return lastCallback;
        }
    }
    // 第一次渲染 或者 不是第一次但是依赖项相同，都返回新的
    hookStates[hookIndex++] = [callback, dependencies];
    return callback
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="_26-react如何区分类组件和函数组件"><a href="#_26-react如何区分类组件和函数组件" class="header-anchor">#</a> 26.react如何区分类组件和函数组件？</h3> <p>通过原型链判断是否有React.Component即可=》Component.prototype.isReactComponent</p> <h3 id="_27-jsx原理"><a href="#_27-jsx原理" class="header-anchor">#</a> 27.jsx原理？</h3> <p>通过babel编译成js对象，然后通过render函数映射成dom节点插入页面=&gt;浏览器不能直接读取jsx</p> <h4 id="自定义组件名为什么要大写"><a href="#自定义组件名为什么要大写" class="header-anchor">#</a> 自定义组件名为什么要大写？</h4> <p>区分是组件还是html(dom)元素，大写是组件，小写是dom元素</p> <h4 id="是否可以不使用jsx"><a href="#是否可以不使用jsx" class="header-anchor">#</a> 是否可以不使用jsx？</h4> <p>可以，但是不使用jsx比如创建一个div就需要通过react.createElement来创建，比较麻烦</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 使用jsx
class Hello extends React.Component {
  render() {
    return &lt;div&gt;Hello {this.props.toWhat}&lt;/div&gt;;
  }
}
// 不使用jsx
class Hello extends React.Component {
  render() {
    return React.createElement('div', null, `Hello ${this.props.toWhat}`);
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="_28-props透传"><a href="#_28-props透传" class="header-anchor">#</a> 28.props透传？</h3> <p>高层级中的props传递到更深层级的组件就是props透传</p> <h3 id="_29-空标签的作用"><a href="#_29-空标签的作用" class="header-anchor">#</a> 29.空标签的作用？</h3> <ul><li>&lt;&gt;表示空标签，react.Fragment()可以用来将子列表分组，并且不在dom中增加额外节点</li> <li>&lt;&gt;&lt;/&gt; 是 &lt;React.Fragment/&gt; 的语法糖。</li> <li>空标签不能接受键值或属性，需要属性通过这种方式&lt;React.Fragment key={item.id}/&gt;</li></ul> <h3 id="_30-属性和状态的区别"><a href="#_30-属性和状态的区别" class="header-anchor">#</a> 30.属性和状态的区别？</h3> <p>属性是props，状态是state。都会触发render更新=》没有state的是无状态组件</p> <h4 id="区别-2"><a href="#区别-2" class="header-anchor">#</a> 区别</h4> <ul><li>属性可以从父组件获取和修改，状态不能</li> <li>属性可以修改子组件值，状态不可以
=》状态只能被组件自身修改不能被外部访问和修改，属性是外部传进来的参数，内部无法修改，只能由外部来修改</li></ul> <h3 id="_31-插槽"><a href="#_31-插槽" class="header-anchor">#</a> 31.插槽？</h3> <p>在定义的插槽内部通过this.props.children获取要填充的内容</p> <h3 id="_32-声明式导航和编程式导航区别"><a href="#_32-声明式导航和编程式导航区别" class="header-anchor">#</a> 32.声明式导航和编程式导航区别？</h3> <ul><li>声明式导航：<a href="/index.html">aaa</a> =&gt;<NavLink to="/index.html"></NavLink></li> <li>编程式:location.href = &quot;/index.html&quot;=&gt;this.props.history.push('index.html')</li> <li>动态路由/a/:id =&gt;然后通过props.match.params.id可以获取到id</li> <li>路由传参：this.props.history.push({pathname:'/user',query: {a: 1}}) =&gt;this.props.location.query.a获取</li> <li>browserRouter路径没有#，会真正向后端发送请求要页面，没有就404。另一种hashRouter带有#</li> <li>withRouter可以把组件包起来，传递history，match，location这些属性=》高阶组件HOC</li></ul> <h3 id="_33-反向代理"><a href="#_33-反向代理" class="header-anchor">#</a> 33.反向代理？</h3> <p>httpProxyMiddleware可以进行代理，使用接近webpack的devServer=》利用后端之间无跨域来实现</p> <h3 id="_34-说说对cssmodule"><a href="#_34-说说对cssmodule" class="header-anchor">#</a> 34.说说对cssModule？</h3> <ul><li>可以将css模块化，通过修改css文件名称，如tab.module.css即可=》生成的样式名会自动拼接随机串防止重复</li> <li>:global(.active样式名)即可实现全局样式定义，即使在module文件中也全局生效</li></ul> <h3 id="_35-immutable作用"><a href="#_35-immutable作用" class="header-anchor">#</a> 35.immutable作用？</h3> <ul><li>深拷贝=》新对象上操作不会影响到原对象的数据，每次修改一个immutable对象都会创建一个新的不可变对象</li> <li>转普通js对象=》immuObj.toJS()</li> <li>fromJS()会自动转成immutable对象</li></ul> <h4 id="常用api"><a href="#常用api" class="header-anchor">#</a> 常用api</h4> <p>set(),setIn(),get(),updateIn()</p> <h4 id="immber和immutable区别"><a href="#immber和immutable区别" class="header-anchor">#</a> immber和immutable区别？</h4> <ul><li>immutable返回的是包装的数据</li> <li>immer是原生数据</li></ul> <h4 id="结合redux"><a href="#结合redux" class="header-anchor">#</a> 结合redux</h4> <p>immutable-redux</p> <h3 id="_36-mobx和redux区别-都是react状态管理工具"><a href="#_36-mobx和redux区别-都是react状态管理工具" class="header-anchor">#</a> 36.mobx和redux区别(都是react状态管理工具)？</h3> <ul><li>mobx可以直接修改数据，不用返回一个新数据</li> <li>mobx没有限制只能一个store，可以有多个</li> <li>redux默认以对象形式存储数据，mobx可以使用可观察对象</li></ul> <h4 id="核心"><a href="#核心" class="header-anchor">#</a> 核心</h4> <ul><li>mobx通过observable可以精准更新</li> <li>redux通过dispatch进行广播，然后provide和connect来对比前后差异控制更新</li></ul> <h4 id="使用"><a href="#使用" class="header-anchor">#</a> 使用</h4> <p>let a = observable({name: 111}) =&gt; a.name = '222' 可以直接修改
=》通过autorun(()=&gt;{})可以监听到改变
=》runInAction(()=&gt;{})</p> <h4 id="mobx-react"><a href="#mobx-react" class="header-anchor">#</a> mobx-react</h4> <p>在render的时候provide()，具体组件@inject(&quot;store&quot;),@observer=&gt;会在this.props获取到store</p> <h4 id="redux有哪些异步中间件"><a href="#redux有哪些异步中间件" class="header-anchor">#</a> redux有哪些异步中间件</h4> <p>redux-sage 借助generator来处理异步，避免回调</p> <h3 id="_37-了解过style-components吗-将html标签包装成组件"><a href="#_37-了解过style-components吗-将html标签包装成组件" class="header-anchor">#</a> 37.了解过style-components吗？(将html标签包装成组件)</h3> <ul><li>声明const stFooter(标签名) = styled.footer<code>background: yellow</code></li> <li>使用<stFooter><a>123</a></stFooter></li> <li>高阶组件，通过props把参数传给子组件，子组件className={props.className}接收</li></ul> <h3 id="_38-createportal作用"><a href="#_38-createportal作用" class="header-anchor">#</a> 38.createPortal作用？</h3> <p>是用来在父组件外创建dom节点的方法=》ReactDom.createPortal(child,container)</p> <h3 id="_39-react的lazy和suspense作用-路由懒加载"><a href="#_39-react的lazy和suspense作用-路由懒加载" class="header-anchor">#</a> 39.react的lazy和suspense作用？(路由懒加载)</h3> <p>懒加载(按需加载)=》webpack解析时会自动进行代码切割(code splitting)，使用的时候才会被加载(异步)</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const LazyLoad = (path) =&gt; {
    const Comp = React.lazy(() =&gt; import('../views/${path}'))
    // 通过Suspense来包裹
    return (
        &lt;React.Suspense fallback={&lt;&gt;加载中...&lt;/&gt;}&gt;
            &lt;Comp/&gt;
        &lt;/React.Suspense&gt;
    )
}
&lt;Route path=&quot;/films&quot; element={LazyLoad(&quot;film&quot;)}&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_40-forwardref用过吗"><a href="#_40-forwardref用过吗" class="header-anchor">#</a> 40.forwardRef用过吗？</h3> <p>用来向子组件传递ref</p> <h3 id="_41-dva"><a href="#_41-dva" class="header-anchor">#</a> 41.dva</h3> <p>dva = React-Router + Redux + Redux-saga</p> <h3 id="_42-umi-乌米"><a href="#_42-umi-乌米" class="header-anchor">#</a> 42.umi(乌米)</h3> <p>在umirc.ts中可以配置路由是否hash通过history，可以配置代理proxy</p> <h4 id="react-router-6更新"><a href="#react-router-6更新" class="header-anchor">#</a> react-router@6更新</h4> <ul><li>用element代替component</li> <li>Routes代替Switch</li> <li>useNavigate代替useHistory</li> <li>通过navigate或redirect组件替代路由重定向</li></ul> <h4 id="自定义redirect组件进行重定向-》官方推荐"><a href="#自定义redirect组件进行重定向-》官方推荐" class="header-anchor">#</a> 自定义redirect组件进行重定向=》官方推荐</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;Route path=&quot;*&quot; element={&lt;Redirect to=&quot;/file&quot;/&gt;}/&gt;
function Redirect({to}) {
    const navigate = useNavigate()
    useEffect(() =&gt; {
        navigate(to,{replace: true})
    })
    return null
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="api"><a href="#api" class="header-anchor">#</a> api</h4> <ul><li>useNavigate()</li> <li>useParams()</li> <li>useLocation()</li> <li>useSearchParams()</li> <li>useRoutes()</li></ul> <h4 id="this-props的三个参数"><a href="#this-props的三个参数" class="header-anchor">#</a> this.props的三个参数</h4> <ul><li>push=&gt;useNavigate()</li> <li>match=&gt;useParams()</li> <li>location=&gt;useLocation()</li></ul> <h4 id="自己封装withrouter"><a href="#自己封装withrouter" class="header-anchor">#</a> 自己封装withRouter</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default function withRouter(Component) {
    return function(props) {
        const push = useNavigate()
        const match = useParams()
        const location = useLocation()
        return &lt;Component {...props} history={{push,match,location}}
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_43-hooks实现一个计数器组件"><a href="#_43-hooks实现一个计数器组件" class="header-anchor">#</a> 43.hooks实现一个计数器组件？</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>function App() {
  const [count, setCount] = useState(0);
  useEffect(() =&gt; {
    const timer = setInterval(() =&gt; {
      setCount((count) =&gt; count + 1);
    }, 1000);

    return () =&gt; {
      clearInterval(timer);
    };
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_44-createelement和cloneelement区别"><a href="#_44-createelement和cloneelement区别" class="header-anchor">#</a> 44.createElement和cloneElement区别？</h3> <ul><li>cloneElement根据element生成新的element=》element是一个react元素=》是不可变对象，只能访问不能修改(可以先拷贝再修改)</li> <li>createElement根据type生成新的element=》type即html标签或react组件</li></ul> <h3 id="_45-usestate和setstate区别"><a href="#_45-usestate和setstate区别" class="header-anchor">#</a> 45.useState和setState区别？</h3> <ul><li>useState只能要在函数组件,setState只能用在类组件</li> <li>useState修改state时，同一个useState声明的值会覆盖，而setState修改state，多次setState的对象会被合并处理=》多个useState声明的值会触发多次渲染
(useState修改state时，设置相同值不会重新渲染，而类组件即使setState相同的值也会重新渲染)</li></ul> <h4 id="直接修改state会有什么影响"><a href="#直接修改state会有什么影响" class="header-anchor">#</a> 直接修改state会有什么影响？</h4> <p>状态发生了变化，但不会重新渲染，必须通过setState去更改才会重新渲染</p> <h3 id="_46-使用hooks有什么常见的问题"><a href="#_46-使用hooks有什么常见的问题" class="header-anchor">#</a> 46.使用hooks有什么常见的问题？</h3> <p>useState的时候，不能使用类似push,pop等来直接修改，否则数组无法获取到新值，要通过析构的方式</p> <h3 id="_47-hoc-higher-order-component"><a href="#_47-hoc-higher-order-component" class="header-anchor">#</a> 47.HOC(Higher Order Component)</h3> <ul><li>是一种基于react组合特性的设计模式</li> <li>用来实现逻辑复用（也可以用来把类组件转成函数组件），增删改props，渲染劫持(控制是否渲染，可以判断当数据加载完成后再去渲染内容-&gt;条件渲染-懒加载，权限控制，节流渲染-useMemo来减少渲染次数)</li> <li>高阶组件是参数为组件，返回值为新组件的函数=》核心思想要是纯函数，没有副作用</li> <li>HOC不会修改传入的组件，是通过将组件包装在容器组件中来组成新的组件</li></ul> <h4 id="应用"><a href="#应用" class="header-anchor">#</a> 应用</h4> <ul><li>利用条件渲染来做权限控制</li> <li>组件复用</li></ul> <h4 id="优缺点"><a href="#优缺点" class="header-anchor">#</a> 优缺点</h4> <p>优点不会影响组件内部状态，缺点是大量使用HOC会产生很多嵌套，不好维护</p> <h4 id="组合-通过connect"><a href="#组合-通过connect" class="header-anchor">#</a> 组合 通过connect</h4> <p>connect是一个返回高阶组件的高阶函数=》输入类型和输出类型相同的函数很容易组合在一起</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 不推荐如下写法...
const EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))

// ... 建议编写组合工具函数
// compose(f, g, h) 等同于 (...args) =&gt; f(g(h(...args)))
const enhance = compose(
  // 这些都是单参数的 HOC
  withRouter,
  connect(commentSelector)
)
const EnhancedComponent = enhance(WrappedComponent)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h4> <p>无法直接通过this.refs.component获取被HOC封装的组件=》可以通过父组件传递一个方法来获取</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ParentCompoent extends React.Component {
  getInstance = (ref)=&gt;{
    this.wrappedInstance = ref;
  }

  render(){
    return &lt;MyComponent getInstance={this.getInstance} /&gt;
  }
}
function HOCFactory(wrappedComponent) {
  return class HOC extends React.Component {
    render(){
      let props = {
        ...this.props
      };

      if(typeof this.props.getInstance === &quot;function&quot;) {
        props.ref = this.props.getInstance;
      }

      return &lt;wrappedComponent {...props} /&gt;
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="_48-jsx和fiber有什么关系"><a href="#_48-jsx和fiber有什么关系" class="header-anchor">#</a> 48.jsx和Fiber有什么关系？</h3> <ul><li>mount阶段通过jsx对象（调用createElement的结果）调用createFiberFromElement生成Fiber</li> <li>update时通过reconcileChildFibers或reconcileChildrenArray对比新jsx和老的Fiber（current Fiber）生成新的wip Fiber树</li></ul> <h3 id="_49-react17之前jsx文件为什么要声明import-react-from-react-之后为什么不需要了"><a href="#_49-react17之前jsx文件为什么要声明import-react-from-react-之后为什么不需要了" class="header-anchor">#</a> 49.react17之前jsx文件为什么要声明import React from 'react'，之后为什么不需要了？</h3> <p>jsx经过编译之后编程React.createElement，不引入React就会报错，react17改变了编译方式，变成了jsx.createElement</p> <h3 id="_50-react中怎么使用async-await"><a href="#_50-react中怎么使用async-await" class="header-anchor">#</a> 50.react中怎么使用async/await？</h3> <ul><li>在官方脚手架搭建的项目可以直接使用</li> <li>自己的项目需要引入babel，在babel中进行配置=&gt;利用babel的transform-async-to-module-method来转成浏览器支持的语法</li></ul> <h3 id="_51-为什么hooks不能写在条件判断中"><a href="#_51-为什么hooks不能写在条件判断中" class="header-anchor">#</a> 51.为什么hooks不能写在条件判断中？</h3> <p>hook会按顺序存储在链表中，如果写在条件判断中，就没法保持链表的顺序</p> <h3 id="_52-render作用"><a href="#_52-render作用" class="header-anchor">#</a> 52.render作用？</h3> <p>必须返回值，无论是否为空</p> <h3 id="_53-react怎么区分class组件和function组件"><a href="#_53-react怎么区分class组件和function组件" class="header-anchor">#</a> 53.react怎么区分Class组件和Function组件？</h3> <p>Class组件prototype上有isReactComponent属性</p> <h3 id="_54-请说一下react的渲染过程"><a href="#_54-请说一下react的渲染过程" class="header-anchor">#</a> 54.请说一下react的渲染过程？</h3> <ul><li>性能瓶颈：cpu io fiber时间片 concurrent mode</li> <li>渲染过程：scheduler render commit Fiber架构</li></ul> <h3 id="_55-react有哪些优化手段"><a href="#_55-react有哪些优化手段" class="header-anchor">#</a> 55.react有哪些优化手段？</h3> <p>shouldComponentUpdate、不可变数据结构、列表key、pureComponent、react.memo、useEffect依赖项、useCallback、useMemo</p> <h3 id="_56-我们写的事件是绑定在dom上么-如果不是绑定在哪里"><a href="#_56-我们写的事件是绑定在dom上么-如果不是绑定在哪里" class="header-anchor">#</a> 56.我们写的事件是绑定在dom上么，如果不是绑定在哪里？</h3> <p>v16绑定在document上，v17绑定在container上</p> <h3 id="_57-为什么我们的事件手动绑定this"><a href="#_57-为什么我们的事件手动绑定this" class="header-anchor">#</a> 57.为什么我们的事件手动绑定this？</h3> <p>合成事件监听函数在执行的时候会丢失上下文，拿到的this就是undefined，需要手动绑定this或者使用箭头函数</p> <h4 id="箭头函数作用"><a href="#箭头函数作用" class="header-anchor">#</a> 箭头函数作用</h4> <p>用来绑定组件的上下文</p> <h3 id="_58-为什么不能用-return-false-来阻止事件的默认行为"><a href="#_58-为什么不能用-return-false-来阻止事件的默认行为" class="header-anchor">#</a> 58.为什么不能用 return false 来阻止事件的默认行为？</h3> <p>合成事件和原生事件触发时机不一样</p> <h3 id="_59-react怎么通过dom元素-找到与之对应的-fiber对象的"><a href="#_59-react怎么通过dom元素-找到与之对应的-fiber对象的" class="header-anchor">#</a> 59.react怎么通过dom元素，找到与之对应的 fiber对象的？</h3> <p>通过internalInstanceKey对应</p> <h3 id="_60-react-hooks比较比的是值还是内存地址"><a href="#_60-react-hooks比较比的是值还是内存地址" class="header-anchor">#</a> 60.react Hooks比较比的是值还是内存地址？</h3> <p>比的是内存地址</p> <h3 id="_61-手写防抖节流hook-》不使用usecallback-因为会把处理函数一起缓存起来-这样比如搜索用防抖节流-搜素值变化由于函数被缓存-就无法实时搜索"><a href="#_61-手写防抖节流hook-》不使用usecallback-因为会把处理函数一起缓存起来-这样比如搜索用防抖节流-搜素值变化由于函数被缓存-就无法实时搜索" class="header-anchor">#</a> 61.手写防抖节流hook=》不使用useCallback，因为会把处理函数一起缓存起来，这样比如搜索用防抖节流，搜素值变化由于函数被缓存，就无法实时搜索</h3> <ul><li>直接使用防抖函数，这样搜索的时候，就可以每隔几秒才进行搜索</li> <li>如果是固定的值可以使用useCallback缓存</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>function useDebounce(fn, wait) { // 自研最优防抖
    let timer = useRef()
    return () =&gt; {
        if (timer.current) {
            clearTimeout(timer.current)
        }
        timer.current = setTimeout(() =&gt; {
            fn.apply(this, arguments)
        }, wait)
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>function useDebounce(fn, wait) { // 自研最优节流
    let timer = useRef();
    return () =&gt;{
        if (!timer.current) {
            timer.current = setTimeout(() =&gt; {
                timer.current = null
                fn.apply(this, arguments)
            }, wait)
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_62-如何理解不可变值-性-数据-immutable"><a href="#_62-如何理解不可变值-性-数据-immutable" class="header-anchor">#</a> 62.如何理解不可变值｜性｜数据(immutable)？</h3> <p>不可变数据是函数式编程的一个特性，意思是一旦创建就不能被修改的数据
=》对immutable对象任意修改操作都会返回一个新的immutable对象</p> <h4 id="使用immutable"><a href="#使用immutable" class="header-anchor">#</a> 使用immutable</h4> <p>通过immutable.fromJS把js对象转成immutable对象
setIn赋值，getIn取值</p> <h4 id="应用-2"><a href="#应用-2" class="header-anchor">#</a> 应用</h4> <p>setState和redux</p> <h4 id="好处"><a href="#好处" class="header-anchor">#</a> 好处</h4> <ul><li>使得复杂的特性更容易实现</li> <li>比较容易跟踪到数据改变</li> <li>确定react何时渲染=&gt;pureComponent</li></ul> <h3 id="_63-如何在react中创建组件"><a href="#_63-如何在react中创建组件" class="header-anchor">#</a> 63.如何在react中创建组件？</h3> <p>函数式组件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Greeting({ message }) {
  return &lt;h1&gt;{`Hello, ${message}`}&lt;/h1&gt;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>类组件=&gt;在函数内部对累组件处理需要通过new来实例化</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Greeting extends React.Component {
  render() {
    return &lt;h1&gt;{`Hello, ${this.props.message}`}&lt;/h1&gt;
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_64-状态提升"><a href="#_64-状态提升" class="header-anchor">#</a> 64.状态提升？</h3> <p>多组件共享数据，要将数据提升到共同的祖先组件上，而不是在两个子组件中各自维护局部的状态</p> <h3 id="_65-react中为什么使用classname而不是class"><a href="#_65-react中为什么使用classname而不是class" class="header-anchor">#</a> 65.react中为什么使用className而不是class？</h3> <p>class是js的关键字，而jsx是基于js的</p> <h3 id="_66-react的super和super-props-区别"><a href="#_66-react的super和super-props-区别" class="header-anchor">#</a> 66.react的super和super(props)区别？</h3> <p>在构造函数内直接使用super拿不到props，必须使用super(props)将props传递给super方法
=》在构造函数之外，通过this.props都可以拿到</p> <h3 id="_67-如何编写mapdispatchtoprops"><a href="#_67-如何编写mapdispatchtoprops" class="header-anchor">#</a> 67.如何编写mapDispatchToProps()？</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const mapDispatchToProps = (dispatch) =&gt; ({
 action: () =&gt; dispatch(action())
})
// 简写
const mapDispatchToProps = { action }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_68-react事件绑定原理"><a href="#_68-react事件绑定原理" class="header-anchor">#</a> 68.react事件绑定原理？</h3> <ul><li>事件绑定不是绑定在该div真实dom上，而是在document处监听所有的事件</li> <li>当事件发生并冒泡到document，会将事件内容交由真正的处理函数去执行.</li></ul> <h4 id="好处-2"><a href="#好处-2" class="header-anchor">#</a> 好处</h4> <p>减少内存损耗，在组件挂载和销毁时能统一绑定和移除事件</p> <h4 id="取消事件冒泡"><a href="#取消事件冒泡" class="header-anchor">#</a> 取消事件冒泡</h4> <p>不能通过event.stopPropagation，要调用event.preventDefault</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a4ba95f7.js" defer></script><script src="/assets/js/2.67e62386.js" defer></script><script src="/assets/js/26.78631bc5.js" defer></script>
  </body>
</html>
