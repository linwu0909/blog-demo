<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶之路</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/icon.png">
    <meta name="description" content="linwu0909个人站点">
    
    <link rel="preload" href="/assets/css/0.styles.d6ad21ed.css" as="style"><link rel="preload" href="/assets/js/app.a4ba95f7.js" as="script"><link rel="preload" href="/assets/js/2.67e62386.js" as="script"><link rel="preload" href="/assets/js/23.0bd65a47.js" as="script"><link rel="prefetch" href="/assets/js/10.a509ebb0.js"><link rel="prefetch" href="/assets/js/11.f6c7ea4e.js"><link rel="prefetch" href="/assets/js/12.d41f06f2.js"><link rel="prefetch" href="/assets/js/13.c3e870d4.js"><link rel="prefetch" href="/assets/js/14.30322894.js"><link rel="prefetch" href="/assets/js/15.86aa2619.js"><link rel="prefetch" href="/assets/js/16.c3bf8266.js"><link rel="prefetch" href="/assets/js/17.558a6e40.js"><link rel="prefetch" href="/assets/js/18.7260607d.js"><link rel="prefetch" href="/assets/js/19.610728e5.js"><link rel="prefetch" href="/assets/js/20.9a25090f.js"><link rel="prefetch" href="/assets/js/21.8265851e.js"><link rel="prefetch" href="/assets/js/22.07a30c30.js"><link rel="prefetch" href="/assets/js/24.484698e4.js"><link rel="prefetch" href="/assets/js/25.9c781b1b.js"><link rel="prefetch" href="/assets/js/26.78631bc5.js"><link rel="prefetch" href="/assets/js/27.eafd817a.js"><link rel="prefetch" href="/assets/js/3.758fc587.js"><link rel="prefetch" href="/assets/js/4.8afd5cf5.js"><link rel="prefetch" href="/assets/js/5.4f1a5aca.js"><link rel="prefetch" href="/assets/js/6.cc47db6f.js"><link rel="prefetch" href="/assets/js/7.64d96c12.js"><link rel="prefetch" href="/assets/js/8.64e93bc9.js"><link rel="prefetch" href="/assets/js/9.ae8eb319.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d6ad21ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端进阶之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端综合" class="dropdown-title"><span class="title">前端综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端综合" class="mobile-dropdown-title"><span class="title">前端综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front/html.html" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front/js.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/front/es6.html" class="nav-link">
  ES6+
</a></li><li class="dropdown-item"><!----> <a href="/front/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构和算法" class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据结构和算法" class="mobile-dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/base.html" class="nav-link">
  经典排序算法+数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/leetCode100.html" class="nav-link">
  LeetCode100
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/handWrite.html" class="nav-link">
  手写各种实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工程化" class="dropdown-title"><span class="title">前端工程化</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端工程化" class="mobile-dropdown-title"><span class="title">前端工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/engineer/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/engineer/webpack.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/engineer/pack.html" class="nav-link">
  Gulp
</a></li></ul></div></div> <a href="https://github.com/linwu0909" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端综合" class="dropdown-title"><span class="title">前端综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端综合" class="mobile-dropdown-title"><span class="title">前端综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front/html.html" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front/js.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/front/es6.html" class="nav-link">
  ES6+
</a></li><li class="dropdown-item"><!----> <a href="/front/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构和算法" class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据结构和算法" class="mobile-dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/base.html" class="nav-link">
  经典排序算法+数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/leetCode100.html" class="nav-link">
  LeetCode100
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/handWrite.html" class="nav-link">
  手写各种实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工程化" class="dropdown-title"><span class="title">前端工程化</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端工程化" class="mobile-dropdown-title"><span class="title">前端工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/engineer/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/engineer/webpack.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/engineer/pack.html" class="nav-link">
  Gulp
</a></li></ul></div></div> <a href="https://github.com/linwu0909" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front/js.html#javascript" class="sidebar-link">JavaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js.html#概念" class="sidebar-link">概念</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_1-说一下闭包-闭包解决了什么问题" class="sidebar-link">1.说一下闭包/闭包解决了什么问题？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_2-如何解决回调地狱-3种方式" class="sidebar-link">2.如何解决回调地狱？(3种方式)</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_3-说一下事件委托-冒泡" class="sidebar-link">3.说一下事件委托(冒泡)？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_4-说说深浅拷贝" class="sidebar-link">4.说说深浅拷贝？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_5-freeze函数" class="sidebar-link">5.freeze函数？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_6-暂时性死区" class="sidebar-link">6.暂时性死区？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_7-js的垃圾回收机制" class="sidebar-link">*7.js的垃圾回收机制？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_8-栈和堆的区别" class="sidebar-link">8.栈和堆的区别？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_9-让数组乱序-数组打乱" class="sidebar-link">9.让数组乱序/数组打乱？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_10-什么是数组扁平化-如何实现" class="sidebar-link">10.什么是数组扁平化？如何实现？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_11-js基本数据类型" class="sidebar-link">11.js基本数据类型？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_12-数组常用方法" class="sidebar-link">12.数组常用方法？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_13-js语言特性" class="sidebar-link">13.js语言特性？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_14-改变this指向-apply-bind-call" class="sidebar-link">14.改变this指向(apply,bind,call)？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_15-const定义的数据可以改变吗" class="sidebar-link">15.const定义的数据可以改变吗？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_16-异步加载的几种方式" class="sidebar-link">16.异步加载的几种方式？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_17-事件循环" class="sidebar-link">17.事件循环？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_18-如何原生实现instanceof" class="sidebar-link">*18.如何原生实现instanceof？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_19-什么是函数柯里化-bind方法就是" class="sidebar-link">19.什么是函数柯里化(bind方法就是)？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_20-null和undefined的区别" class="sidebar-link">20.Null和Undefined的区别？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_21-this关键字在不同环境下的指向" class="sidebar-link">21.this关键字在不同环境下的指向？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_22-原型和原型链-构造函数-原型-实例-原型" class="sidebar-link">22.原型和原型链(构造函数原型)</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_23-js是单线程-单线程有什么好处" class="sidebar-link">23.js是单线程，单线程有什么好处？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_24-queryselector返回值是什么-queryselectorall呢" class="sidebar-link">24.querySelector返回值是什么?querySelectorAll呢？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_25-函数传参是引用吗-修改形参会影响实参" class="sidebar-link">25.函数传参是引用吗？修改形参会影响实参？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_26-如何判断变量是否是数组" class="sidebar-link">26.如何判断变量是否是数组</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_27-如何把对象转成key-value的二维数组" class="sidebar-link">27.如何把对象转成key/value的二维数组</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_28-说几种遍历数组的方法" class="sidebar-link">28.说几种遍历数组的方法</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_29-js的执行过程" class="sidebar-link">29.js的执行过程</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_30-一个超长字符串能存在栈内存中吗" class="sidebar-link">30.一个超长字符串能存在栈内存中吗？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_31-mouseover和mouseenter的区别" class="sidebar-link">31.mouseover和mouseenter的区别</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_32-new一个对象发生了什么" class="sidebar-link">32.new一个对象发生了什么?</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_33-和-有什么区别" class="sidebar-link">33.==和===有什么区别？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_34-实现一个同步的sleep函数" class="sidebar-link">34.实现一个同步的sleep函数</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_35-字符串去重" class="sidebar-link">35.字符串去重</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_36-怎么判断两个对象相等" class="sidebar-link">36.怎么判断两个对象相等</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_37-如何生成100个元素为1的数组" class="sidebar-link">37.如何生成100个元素为1的数组？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_38-typeof和instanceof的区别" class="sidebar-link">38.typeof和instanceof的区别</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_39-字符串翻转" class="sidebar-link">39.字符串翻转</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_40-手写promise-race" class="sidebar-link">40.手写promise.race</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_41-js数组哪些方法改变自身-哪些方法不改变" class="sidebar-link">41.js数组哪些方法改变自身，哪些方法不改变</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_42-说说object-defineproperty" class="sidebar-link">42.说说Object.defineProperty</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_43-如何全部替代一个子串为另一个" class="sidebar-link">43.如何全部替代一个子串为另一个</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_44-0-1-0-2不等于0-3" class="sidebar-link">44.0.1+0.2不等于0.3？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_45-类数组转数组" class="sidebar-link">45.类数组转数组</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_46" class="sidebar-link">46.</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_47-js数组去重-原生js" class="sidebar-link">47.js数组去重(原生js)</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_48-什么是作用域-什么是作用域链" class="sidebar-link">48.什么是作用域？什么是作用域链?</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_49-定时器准时吗" class="sidebar-link">49.定时器准时吗</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_50-promise-all错误处理" class="sidebar-link">50.promise.all错误处理</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_51-异步编程的实现方式" class="sidebar-link">51.异步编程的实现方式</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_52-js如何实现多线程" class="sidebar-link">52.js如何实现多线程</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_53-js的执行机制" class="sidebar-link">53.js的执行机制？</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_54-剪贴板相关操作" class="sidebar-link">54.剪贴板相关操作</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_59-js中的数组特点" class="sidebar-link">59.js中的数组特点</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_60-input事件和change事件区别" class="sidebar-link">60.input事件和change事件区别</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_61-with作用" class="sidebar-link">61.with作用</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_62-e-target和e-currenttarget区别" class="sidebar-link">62.e.target和e.currentTarget区别</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_63-json相关" class="sidebar-link">63.json相关</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_64-剩余参数和arguments对象区别是什么" class="sidebar-link">64.剩余参数和arguments对象区别是什么</a></li><li class="sidebar-sub-header"><a href="/front/js.html#_65-js有哪些代码规范" class="sidebar-link">65.*js有哪些代码规范</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#javascript">JavaScript</a><ul><li><a href="#概念">概念</a></li><li><a href="#_1-说一下闭包-闭包解决了什么问题">1.说一下闭包/闭包解决了什么问题？</a></li><li><a href="#_2-如何解决回调地狱-3种方式">2.如何解决回调地狱？(3种方式)</a></li><li><a href="#_3-说一下事件委托-冒泡">3.说一下事件委托(冒泡)？</a></li><li><a href="#_4-说说深浅拷贝">4.说说深浅拷贝？</a></li><li><a href="#_5-freeze函数">5.freeze函数？</a></li><li><a href="#_6-暂时性死区">6.暂时性死区？</a></li><li><a href="#_7-js的垃圾回收机制">*7.js的垃圾回收机制？</a></li><li><a href="#_8-栈和堆的区别">8.栈和堆的区别？</a></li><li><a href="#_9-让数组乱序-数组打乱">9.让数组乱序/数组打乱？</a></li><li><a href="#_10-什么是数组扁平化-如何实现">10.什么是数组扁平化？如何实现？</a></li><li><a href="#_11-js基本数据类型">11.js基本数据类型？</a></li><li><a href="#_12-数组常用方法">12.数组常用方法？</a></li><li><a href="#_13-js语言特性">13.js语言特性？</a></li><li><a href="#_14-改变this指向-apply-bind-call">14.改变this指向(apply,bind,call)？</a></li><li><a href="#_15-const定义的数据可以改变吗">15.const定义的数据可以改变吗？</a></li><li><a href="#_16-异步加载的几种方式">16.异步加载的几种方式？</a></li><li><a href="#_17-事件循环">17.事件循环？</a></li><li><a href="#_18-如何原生实现instanceof">*18.如何原生实现instanceof？</a></li><li><a href="#_19-什么是函数柯里化-bind方法就是">19.什么是函数柯里化(bind方法就是)？</a></li><li><a href="#_20-null和undefined的区别">20.Null和Undefined的区别？</a></li><li><a href="#_21-this关键字在不同环境下的指向">21.this关键字在不同环境下的指向？</a></li><li><a href="#_22-原型和原型链-构造函数-原型-实例-原型">22.原型和原型链(构造函数&lt;==&gt;原型 实例=&gt;原型)</a></li><li><a href="#_23-js是单线程-单线程有什么好处">23.js是单线程，单线程有什么好处？</a></li><li><a href="#_24-queryselector返回值是什么-queryselectorall呢">24.querySelector返回值是什么?querySelectorAll呢？</a></li><li><a href="#_25-函数传参是引用吗-修改形参会影响实参">25.函数传参是引用吗？修改形参会影响实参？</a></li><li><a href="#_26-如何判断变量是否是数组">26.如何判断变量是否是数组</a></li><li><a href="#_27-如何把对象转成key-value的二维数组">27.如何把对象转成key/value的二维数组</a></li><li><a href="#_28-说几种遍历数组的方法">28.说几种遍历数组的方法</a></li><li><a href="#_29-js的执行过程">29.js的执行过程</a></li><li><a href="#_30-一个超长字符串能存在栈内存中吗">30.一个超长字符串能存在栈内存中吗？</a></li><li><a href="#_31-mouseover和mouseenter的区别">31.mouseover和mouseenter的区别</a></li><li><a href="#_32-new一个对象发生了什么">32.new一个对象发生了什么?</a></li><li><a href="#_33-和-有什么区别">33.==和===有什么区别？</a></li><li><a href="#_34-实现一个同步的sleep函数">34.实现一个同步的sleep函数</a></li><li><a href="#_35-字符串去重">35.字符串去重</a></li><li><a href="#_36-怎么判断两个对象相等">36.怎么判断两个对象相等</a></li><li><a href="#_37-如何生成100个元素为1的数组">37.如何生成100个元素为1的数组？</a></li><li><a href="#_38-typeof和instanceof的区别">38.typeof和instanceof的区别</a></li><li><a href="#_39-字符串翻转">39.字符串翻转</a></li><li><a href="#_40-手写promise-race">40.手写promise.race</a></li><li><a href="#_41-js数组哪些方法改变自身-哪些方法不改变">41.js数组哪些方法改变自身，哪些方法不改变</a></li><li><a href="#_42-说说object-defineproperty">42.说说Object.defineProperty</a></li><li><a href="#_43-如何全部替代一个子串为另一个">43.如何全部替代一个子串为另一个</a></li><li><a href="#_44-0-1-0-2不等于0-3">44.0.1+0.2不等于0.3？</a></li><li><a href="#_45-类数组转数组">45.类数组转数组</a></li><li><a href="#_46">46.</a></li><li><a href="#_47-js数组去重-原生js">47.js数组去重(原生js)</a></li><li><a href="#_48-什么是作用域-什么是作用域链">48.什么是作用域？什么是作用域链?</a></li><li><a href="#_49-定时器准时吗">49.定时器准时吗</a></li><li><a href="#_50-promise-all错误处理">50.promise.all错误处理</a></li><li><a href="#_51-异步编程的实现方式">51.异步编程的实现方式</a></li><li><a href="#_52-js如何实现多线程">52.js如何实现多线程</a></li><li><a href="#_53-js的执行机制">53.js的执行机制？</a></li><li><a href="#_54-剪贴板相关操作">54.剪贴板相关操作</a></li><li><a href="#_59-js中的数组特点">59.js中的数组特点</a></li><li><a href="#_60-input事件和change事件区别">60.input事件和change事件区别</a></li><li><a href="#_61-with作用">61.with作用</a></li><li><a href="#_62-e-target和e-currenttarget区别">62.e.target和e.currentTarget区别</a></li><li><a href="#_63-json相关">63.json相关</a></li><li><a href="#_64-剩余参数和arguments对象区别是什么">64.剩余参数和arguments对象区别是什么</a></li><li><a href="#_65-js有哪些代码规范">65.*js有哪些代码规范</a></li></ul></li></ul></div><p></p> <h2 id="javascript"><a href="#javascript" class="header-anchor">#</a> JavaScript</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <ul><li>基础类型赋值只改变本身，引用类型赋值全部修改(栈内存中保存的地址指针指向的是堆内存中同一个位置)</li> <li>微任务和宏任务都属于队列，栈中先执行完才会去执行队列</li> <li>所有微任务总会在下一个宏任务之前全部执行完毕，直至微任务队列清空，过程中如果有微任务产生微任务会继续执行新的微任务</li> <li>对象中数字属性名等于字符串属性名</li> <li>alert弹出的数据都会转化成字符串</li> <li>js是单线程，浏览器是多进程</li> <li>JSON.stringify会过滤掉undefined，不会过滤掉null</li> <li>JS中的数组可以作为栈或队列使用</li></ul> <h3 id="_1-说一下闭包-闭包解决了什么问题"><a href="#_1-说一下闭包-闭包解决了什么问题" class="header-anchor">#</a> 1.说一下闭包/闭包解决了什么问题？</h3> <p>函数执行会形成私有上下文，这种保存私有变量的机制就是闭包。(闭包就是能够读取其他函数内部变量的函数)
用来解决函数外部因作用域访问不到函数内部的问题。
(即子函数在外部调用，子函数所在的父函数的作用域不会释放)
函数作用域是独立的，封闭的。但是闭包是能够读取其他函数内部变量的一个函数。
我们在函数中嵌套一个函数，里面的函数去访问外面函数的变量，被访问的变量会始终保存在内存中</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function init() {
    var name = &quot;Mozilla&quot;;
    // name 是一个被 init 创建的局部变量
    function displayName() {
    // displayName() 是内部函数，一个闭包
        alert(name); //使用了父函数中声明的变量
    }
    displayName();
}
init();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>不恰当使用闭包会造成内存泄漏(要把变量定义在函数内，而不是全局变量，这样程序执行完就会销毁变量)。
防抖和节流都有用到闭包</p> <h4 id="常见问题"><a href="#常见问题" class="header-anchor">#</a> 常见问题</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (var i = 0; i &lt; 6; i++) {
    setTimeout(() =&gt; {
    console.log(i) // 1s后输出6个6=&gt;不能用const，用let是1s后输出0-5
    }, 1000)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_2-如何解决回调地狱-3种方式"><a href="#_2-如何解决回调地狱-3种方式" class="header-anchor">#</a> 2.如何解决回调地狱？(3种方式)</h3> <p>promise，async/await，generator</p> <h3 id="_3-说一下事件委托-冒泡"><a href="#_3-说一下事件委托-冒泡" class="header-anchor">#</a> 3.说一下事件委托(冒泡)？</h3> <p>不在元素上直接设置监听函数，而是在父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上的事件被触发。举例：ul，li监听。
（ 子元素事件冒泡到父元素，需要父元素也有该事件）</p> <h4 id="事件捕获和冒泡机制-以及事件委托"><a href="#事件捕获和冒泡机制-以及事件委托" class="header-anchor">#</a> 事件捕获和冒泡机制，以及事件委托？</h4> <ul><li>事件捕获(老版本浏览器不支持，用得较少)：从window接收，一级一级往下，最后是元素接收到事件=》从外到内</li> <li>事件冒泡(IE)：从元素最先接收，一级一级往上，再由window接收=》从内到外</li></ul> <h4 id="冒泡和捕获哪个先"><a href="#冒泡和捕获哪个先" class="header-anchor">#</a> 冒泡和捕获哪个先？</h4> <p>先捕获后冒泡</p> <h4 id="dom事件流"><a href="#dom事件流" class="header-anchor">#</a> dom事件流?</h4> <p>window-&gt;document-&gt;body-&gt;div-&gt;body-&gt;document-&gt;window
事件流的典型应用就是事件委托。事件委托利用了事件冒泡，把事件加到父级上，就可以管理一类型的所有事件。
(ul和li，把事件加到ul上，可以监控到li)</p> <ul><li>event.preventDefault()可以阻止默认事件但是允许冒泡事件</li> <li>event.stopPropagation()可以阻止冒泡但是允许默认事件</li></ul> <h4 id="浏览器的事件模型"><a href="#浏览器的事件模型" class="header-anchor">#</a> 浏览器的事件模型？</h4> <p>事件模型的过程主要分三个阶段：捕获阶段，目标阶段，冒泡阶段
addEventListener(第三个参数如果是true，就代表在捕获阶段执行，否则在冒泡阶段执行=&gt;对应useCapture:true)
=&gt;第三个参数也可以是个options</p> <h3 id="_4-说说深浅拷贝"><a href="#_4-说说深浅拷贝" class="header-anchor">#</a> 4.说说深浅拷贝？</h3> <ul><li>深浅拷贝区别是对于引用类型如object，array而言的。</li> <li>深浅拷贝，基本类型的时候，改变都不会使原数据改变。</li> <li>引用类型，浅拷贝改变会使原数据改变，深拷贝不会。
(浅拷贝和赋值也有区别，赋值和原数据指向的是同一对象，浅拷贝不是)</li> <li>因为引用类型，浅拷贝拷贝的是内存地址，深拷贝拷贝的是值，但是内存地址不同，所以不会。</li> <li>浅拷贝实现是通过对对象各个属性依次进行拷贝，拷贝的是引用</li></ul> <h4 id="浅拷贝方式"><a href="#浅拷贝方式" class="header-anchor">#</a> 浅拷贝方式</h4> <ol><li>Object.assign() =》当对象只有一层是深拷贝</li> <li>es6的扩展运算法...</li> <li>slice()
// 通过对象序列化和字符串反序列化也可实现</li></ol> <h4 id="深拷贝实现是通过递归的方式将值进行拷贝"><a href="#深拷贝实现是通过递归的方式将值进行拷贝" class="header-anchor">#</a> 深拷贝实现是通过递归的方式将值进行拷贝</h4> <p>深拷贝方式：</p> <ol><li>JSON.stringify() 函数，日期，正则在JSON.stringify时都会出现问题</li> <li>遍历递归来拷贝(非原型属性)</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>var arr = ['old', 1, true, ['old1', 'old2'], {old: 1}]
var new_arr = JSON.parse( JSON.stringify(arr) );
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>实现浅拷贝</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function clone(target) {
    if (target === null) {
        return null;
    }
    // 判断原来是数组还是对象
    let cloneTarget = Array.isArray(target) ? [] : {}
    for (const key in target) {
        if (target.hasOwnProperty(key)) { // 判断是否存在该属性，不包括原型链
            cloneTarget[key] = target[key]
        }
    }
    return cloneTarget;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>实现深拷贝</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> function deepCopy(obj) {
          var result = Array.isArray(obj) ? [] : {};
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              if (typeof obj[key] === 'object') {
                result[key] = deepCopy(obj[key]);   //递归复制
              } else {
                result[key] = obj[key];
              }
            }
          }
          return result;
        }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language-深拷贝满足常见类型及循环引用 line-numbers-mode"><pre class="language-text"><code>// 利用 WeakMap 解决循环引用
let map = new WeakMap()
function deepClone(obj) {
  if (obj instanceof Object) {
    if (map.has(obj)) {
      return map.get(obj)
    }
    let newObj
    if (obj instanceof Array) {
      newObj = []
    } else if (obj instanceof Function) {
      newObj = function() {
        return obj.apply(this, arguments)
      }
    } else if (obj instanceof RegExp) {
      // 拼接正则
      newobj = new RegExp(obj.source, obj.flags)
    } else if (obj instanceof Date) {
      newobj = new Date(obj)
    } else {
      newObj = {}
    }
    // 克隆一份对象出来
    let desc = Object.getOwnPropertyDescriptors(obj)
    let clone = Object.create(Object.getPrototypeOf(obj), desc)
    map.set(obj, clone)
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        newObj[key] = deepClone(obj[key])
      }
    }
    return newObj
  }
  return obj
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h3 id="_5-freeze函数"><a href="#_5-freeze函数" class="header-anchor">#</a> 5.freeze函数？</h3> <p>Object.freeze表示冻结该对象，被冻结的对象无法被修改(包括新增属性，删除属性，以及可枚举性，可配置性等)，但是允许访问。var a = Object.freeze({})</p> <h3 id="_6-暂时性死区"><a href="#_6-暂时性死区" class="header-anchor">#</a> 6.暂时性死区？</h3> <p>使用let，const声明变量之前，该变量都是不可用的。重复命名一个变量，在第二个命名之前变量都是不可用的。</p> <h3 id="_7-js的垃圾回收机制"><a href="#_7-js的垃圾回收机制" class="header-anchor">#</a> *7.js的垃圾回收机制？</h3> <ol><li>标记清除法</li> <li>引用计数</li></ol> <p>不自动回收变量：全局变量或闭包内引用的变量</p> <h3 id="_8-栈和堆的区别"><a href="#_8-栈和堆的区别" class="header-anchor">#</a> 8.栈和堆的区别？</h3> <p>let a = 20; 都存在栈中
let a = {m: 29} a存在栈中，{m:29}作为对象存在堆中，当我们要访问堆内存中的引用数据类型，首先要从栈中获取该对象的地址引用。</p> <ul><li>栈存储基础数据类型，堆存储引用类型</li> <li>栈按值访问，堆按引用地址访问</li> <li>栈存储的值大小固定，会自动分配空间，堆存储的值大小不固定，可动态调整</li></ul> <h4 id="堆内存"><a href="#堆内存" class="header-anchor">#</a> 堆内存？</h4> <p>不能直接访问和操作堆内存，只能操作对象在栈内存的引用地址，通过这个地址可以找到堆内存中的对象
=&gt;比如引用类型的赋值操作，是把原来对象的栈内存地址拷贝一份给新的对象，他们都指向同一个堆内存对象，所以成功给这个对象赋值</p> <h3 id="_9-让数组乱序-数组打乱"><a href="#_9-让数组乱序-数组打乱" class="header-anchor">#</a> 9.让数组乱序/数组打乱？</h3> <p>_.shuffle([1, 2, 3, 4]);//需要通过第三方库lodash
<code>function shuffle(arr) { return arr.sort(() =&gt; { return (Math.random() - 0.5); }); }</code></p> <h3 id="_10-什么是数组扁平化-如何实现"><a href="#_10-什么是数组扁平化-如何实现" class="header-anchor">#</a> 10.什么是数组扁平化？如何实现？</h3> <p>数组扁平化就是将一个多维数组转换为一个一维数组。</p> <ol><li>es6的flat arr.flat(Infinity) 数组才有的属性</li> <li>转化成字符串 使用toString再用split变成以逗号分割的数组，再用map遍历转成数字返回
arr.toString().split(',').map(item=&gt;parseFloat(item)</li> <li>循环递归=&gt;循环判断子元素是否存在数组，如果是就把所有元素展开放到一个空数组中再重新赋值，直到没有数组
while(arr.some(item =&gt; Array.isArray(item)) {
arr = [].concat(...arr)
}</li></ol> <h4 id="flatmap"><a href="#flatmap" class="header-anchor">#</a> flatMap</h4> <p>会返回扁平化深度为1的数组，与flat区别就是参数传的是一个函数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const arr1 = [1, 2, [3], [4, 5], 6, [7,8,9]];
console.log(arr1.flatMap(num =&gt; num)); // [1,2,3,4,5,6,7,8,9]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_11-js基本数据类型"><a href="#_11-js基本数据类型" class="header-anchor">#</a> 11.js基本数据类型？</h3> <ul><li>string,boolean,number,undefined,null,symbol(es6新增),(bigInt=&gt;大于2^53 - 1的数，就是最大安全整数Number.MAX_SAFE_INTEGER)</li> <li>引用数据类型：对象(Array,Math,Map,Set,RegExp)，函数</li> <li>原始类型除了null都可以通过typeof判断，typeof null为object是久远的bug，想要判断通过xxx===null即可。</li> <li>转数字规则：null为0，undefined为NaN，symbol报错，字符串非数字(或进制)转NaN。NaN不等于自身</li> <li>typeof判断对象类型只能判断函数为function，其他都是object</li> <li>NaN通过isNaN(123)来判断(NaN指的是not a number，number的范围是-2^53~2^53)</li></ul> <h4 id="判断一个数是整数"><a href="#判断一个数是整数" class="header-anchor">#</a> 判断一个数是整数？</h4> <ul><li>%1 判断是不是0</li> <li>Number.isInteger()</li></ul> <h4 id="_2-53次方怎么表示"><a href="#_2-53次方怎么表示" class="header-anchor">#</a> 2^53次方怎么表示？</h4> <ul><li>2 ** 53</li> <li>Math.pow(2,53)</li></ul> <h4 id="bigint怎么表示"><a href="#bigint怎么表示" class="header-anchor">#</a> bigInt怎么表示？</h4> <p>整数后面加n即可</p> <h4 id="isnan和number-isnan区别"><a href="#isnan和number-isnan区别" class="header-anchor">#</a> isNaN和Number.isNaN区别？</h4> <p>isNaN会把参数转成数值，不能转换的都会返回true
Number.isNaN会先判断是否是数字，是数字再判断是否是NaN，更准确</p> <h3 id="_12-数组常用方法"><a href="#_12-数组常用方法" class="header-anchor">#</a> 12.数组常用方法？</h3> <p>push(),pop(),shift(),unshift(),splice(),sort(),map()
会改变数组的方法：push(),pop(),shift(),unshift(),splice(),reverse(),sort()</p> <h3 id="_13-js语言特性"><a href="#_13-js语言特性" class="header-anchor">#</a> 13.js语言特性？</h3> <p>可以在浏览器运行
不用预编译，直接解析执行代码</p> <h3 id="_14-改变this指向-apply-bind-call"><a href="#_14-改变this指向-apply-bind-call" class="header-anchor">#</a> 14.改变this指向(apply,bind,call)？</h3> <p>call，bind，apply都可以，箭头函数和proxy也可以改变=》proxy指向代理对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>fn.call(obj, 1,2) call接收一个参数列表
fn.bind(obj,1,2)也是接收一个参数列表，但是返回的是一个函数
fn.apply(obj,[1,2])apply接收的是一个参数数组
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <ul><li>call和bind都是接收一个参数列表，apply接收的是一个参数数组</li> <li>bind返回的是一个函数，需要执行才生效</li></ul> <h3 id="_15-const定义的数据可以改变吗"><a href="#_15-const定义的数据可以改变吗" class="header-anchor">#</a> 15.const定义的数据可以改变吗？</h3> <ul><li>定义的是基本类型不可以改变，定义的是引用类型就可以改变，比如对象</li> <li>const定义引用类型(对象，数组)，不能修改指针指向的地址，但可以修改地址指向的数据</li></ul> <h3 id="_16-异步加载的几种方式"><a href="#_16-异步加载的几种方式" class="header-anchor">#</a> 16.异步加载的几种方式？</h3> <ul><li>script的defer属性:defer属性规定是否对脚本执行进行延迟，直到页面加载为止。可以保证脚本按顺序执行(如果脚本不改变文档的内容，可以通过这种方式加快文档处理的速度，不是所有浏览器都支持)</li> <li>script的async属性:async是h5新增特性，只适用外部引入的脚本，一旦脚本可用会异步执行。不能保证脚本按顺序执行，不是所有浏览器都支持</li> <li>$(document).ready()。必须引入jquery</li></ul> <h4 id="defer和async区别"><a href="#defer和async区别" class="header-anchor">#</a> defer和async区别？</h4> <p>js脚本分成加载、解析、执行几个步骤，脚本加载且执行会阻塞dom渲染(所以js一般放最后)
相同点：都是异步加载
不同点：</p> <ul><li>async加载完立即执行，可能会阻塞dom解析</li> <li>defer加载后延迟到dom解析完才执行(在domContentLoaded之前)</li></ul> <h3 id="_17-事件循环"><a href="#_17-事件循环" class="header-anchor">#</a> 17.事件循环？</h3> <p>(先执行一个宏任务=》)先执行整个代码块，过程中把宏任务和微任务分别放入各自的任务队列，等代码块执行完就立即执行微任务队列中所有的微任务，
当所有微任务都执行完就开始下一次宏任务</p> <h4 id="执行微任务过程中产生了微任务"><a href="#执行微任务过程中产生了微任务" class="header-anchor">#</a> 执行微任务过程中产生了微任务</h4> <p>同样会加到当前的微任务队列中，等微任务队列都清空了才开始下次宏任务</p> <h4 id="为什么区分微任务和宏任务"><a href="#为什么区分微任务和宏任务" class="header-anchor">#</a> 为什么区分微任务和宏任务？</h4> <ul><li><p>微任务是线程之间的切换，速度快，不用进行上下文切换，一次事件循环可以完成所有微任务。</p></li> <li><p>宏任务是进程之间的切换，每次需要切换上下文，一次事件循环只能执行一个宏任务。</p></li> <li><p>目的为了实现插队。</p></li> <li><p>宏任务：js脚本，定时器，IO操作，ajax=》宏任务不一定都是异步任务，如js脚本</p></li> <li><p>微任务：Promise.then,catch,finally,process.nextTick</p></li></ul> <h4 id="为什么微任务会比宏任务先执行"><a href="#为什么微任务会比宏任务先执行" class="header-anchor">#</a> 为什么微任务会比宏任务先执行？</h4> <p>因为当主线程代码执行完后，在事件循环执行之前，会尝试dom渲染，而微任务是在dom渲染之前执行，dom渲染完成后才执行宏任务。</p> <h3 id="_18-如何原生实现instanceof"><a href="#_18-如何原生实现instanceof" class="header-anchor">#</a> *18.如何原生实现instanceof？</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>function fakeInstanceOf (instance, parent) {
    if (typeof instance !== &quot;object&quot; &amp;&amp; typeof instance !== &quot;function&quot;) return false;
    while (instance.__proto__) {
        if (instance.__proto__ === parent.prototype) {
            return true;
        }
        instance.__proto__ = instance.__proto__.__proto__;
    }
    return false;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_19-什么是函数柯里化-bind方法就是"><a href="#_19-什么是函数柯里化-bind方法就是" class="header-anchor">#</a> 19.什么是函数柯里化(bind方法就是)？</h3> <p>函数柯里化实际是一种转换，返回的是一个函数。是将多变量函数拆解为单变量的多个函数。f(a,b,c)=&gt;f(a)(b)(c) a,b,c各自都是一个函数内的变量</p> <h3 id="_20-null和undefined的区别"><a href="#_20-null和undefined的区别" class="header-anchor">#</a> 20.Null和Undefined的区别？</h3> <ul><li>null表示定义了一个空值, 变量声明了没有赋值就是undefined</li> <li>null参与计算等于0，undefined参与计算返回NaN(Number)</li></ul> <h3 id="_21-this关键字在不同环境下的指向"><a href="#_21-this关键字在不同环境下的指向" class="header-anchor">#</a> 21.this关键字在不同环境下的指向？</h3> <ul><li><p>this在浏览器指向window</p></li> <li><p>普通函数中的this指向window</p></li> <li><p>定时器的this指向window</p></li> <li><p>箭头函数的this取决于外部环境</p></li> <li><p>事件中的this指向事件的调用者</p></li> <li><p>构造函数和原型对象中的this都是指向new出来的实例对象</p></li> <li><p>类中的this指向构造器new出来的实例对象</p></li> <li><p>谁触发函数，函数里的this就指向谁</p></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>fun() // window.fun()里面的this指向window
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>多层对象调用，函数被外层对象调用，指向的也是上一级对象</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = {
    method: {
        fn: function() {
            console.log(this)
        }
    }
}
obj.method.fn() // 指向method
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>箭头函数调用，箭头函数本身没有this，实际调用的是上一级的this</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = {
    fun: ()=&gt; {
        console.log(this)
    },
    fun2: function() {
        console.log(this)
    }
}
obj.fun() // window
obj.fun2() // obj
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_22-原型和原型链-构造函数-原型-实例-原型"><a href="#_22-原型和原型链-构造函数-原型-实例-原型" class="header-anchor">#</a> 22.原型和原型链(构造函数&lt;==&gt;原型 实例=&gt;原型)</h3> <ul><li>构造函数通过prototype指向原型</li> <li>原型通过constructor指向构造函数</li> <li>实例通过_proto_指向原型(原型上有一个_proto_属性，指向Object.prototype)</li></ul> <h4 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h4> <p>构造函数通过prototype指向原型，原型通过constructor指向构造函数，原型(Parent.prototype)通过_proto_指向原型的原型(Object.prototype)</p> <h4 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h4> <ul><li>当访问一个实例对象的属性时，如果本身没有这个属性，就会去原型对象中查找，一直找到Object为止，原型间一层层的关系就构成了原型链。最终指向null</li> <li>不是所有对象都有原型(通过对象创建的对象都有原型，空对象及Object.prototype(原型的最顶端)没有原型)</li> <li>实例(p)=&gt;原型(Parent.prototype)=&gt;原型(Object.prototype)=&gt;null  // 通过_proto_一层层往上找</li></ul> <h4 id="object-create和原型链-mdn"><a href="#object-create和原型链-mdn" class="header-anchor">#</a> Object.create和原型链(MDN)</h4> <ul><li>object.create(proto)是创建一个新对象，使用现有的对象来作为新创建对象的原型(prototype)</li> <li>每个对象拥有一个原型对象。对象以原型为模版，继承了方法和属性。原型对象可能也有原型，一层一层以此类推，就构成了原型链</li> <li>这些属性和方法定义在构造函数的prototype中，而不是对象实例本身</li> <li>js通过在对象实例和构造器之间建立一个链接_proto_在构造器中找到这些属性和方法</li> <li>每个实例对象都从原型中继承了一个constructor属性，指向了构造函数</li> <li>prototype是内部属性，外部无法直接访问。但是继承者的p._proto_和被继承的Parent.prototype指向统一对象</li> <li>顶层原型对象是object，object的原型对象是null(实例的_proto_等于原型的prototype)</li> <li>js中的继承通过原型链继承实现，所以js是基于原型的语言。java是面向对象语言，创建对象后会把类的属性和方法复制到对象中</li> <li>函数默认有prototype属性，prototype中有constructor属性，指向函数本身</li></ul> <h4 id="构造函数与普通函数最核心区别"><a href="#构造函数与普通函数最核心区别" class="header-anchor">#</a> 构造函数与普通函数最核心区别</h4> <p>构造函数通过new来调用，普通函数不需要new
<a href="https://imgtu.com/i/7NK5E8" target="_blank" rel="noopener noreferrer"><img src="https://s4.ax1x.com/2022/01/16/7NK5E8.png" alt="7NK5E8.png"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_23-js是单线程-单线程有什么好处"><a href="#_23-js是单线程-单线程有什么好处" class="header-anchor">#</a> 23.js是单线程，单线程有什么好处？</h3> <p>不用在意线程状态同步问题，没有死锁的情况。</p> <h3 id="_24-queryselector返回值是什么-queryselectorall呢"><a href="#_24-queryselector返回值是什么-queryselectorall呢" class="header-anchor">#</a> 24.querySelector返回值是什么?querySelectorAll呢？</h3> <p>querySelector返回的是匹配的第一个元素，querySelectorAll返回的是一个nodeList</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    for (var div of divs) { 遍历nodeList
        div.style.color = &quot;blue&quot;;
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_25-函数传参是引用吗-修改形参会影响实参"><a href="#_25-函数传参是引用吗-修改形参会影响实参" class="header-anchor">#</a> 25.函数传参是引用吗？修改形参会影响实参？</h3> <ul><li>函数传参是引用。 不影响。会开辟一个新的内存地址指向这个参数，修改的是这个新地址指向的值。</li> <li>基本类型存储在栈中，引用类型存储在堆中，引用类型存储的是一个指针，指向存储对象的内存地址。</li> <li>基本类型的值可以直接访问，引用类型的值通过指针去访问(js不允许直接访问堆内存中的位置)。</li></ul> <h3 id="_26-如何判断变量是否是数组"><a href="#_26-如何判断变量是否是数组" class="header-anchor">#</a> 26.如何判断变量是否是数组</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>arr instanceof Array
Object.prototype.toString.call(arr) //同样也可以用来判断对象类型 
Array.isArray(arr)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_27-如何把对象转成key-value的二维数组"><a href="#_27-如何把对象转成key-value的二维数组" class="header-anchor">#</a> 27.如何把对象转成key/value的二维数组</h3> <p>object.entries({a:3})</p> <h3 id="_28-说几种遍历数组的方法"><a href="#_28-说几种遍历数组的方法" class="header-anchor">#</a> 28.说几种遍历数组的方法</h3> <p>forEach(缺点中途无法退出)，map，some，every，filter，for of，</p> <h3 id="_29-js的执行过程"><a href="#_29-js的执行过程" class="header-anchor">#</a> 29.js的执行过程</h3> <ul><li>词法分析=》var a = 2 会被分割成4个单元 var｜a｜=｜2</li> <li>语法分析=》解析成抽象语法树</li> <li>代码生成=》会在执行上下文执行</li></ul> <h3 id="_30-一个超长字符串能存在栈内存中吗"><a href="#_30-一个超长字符串能存在栈内存中吗" class="header-anchor">#</a> 30.一个超长字符串能存在栈内存中吗？</h3> <p>不能，因为字符串数据一直都是存在堆中的，栈只存了地址指针
数字=》小整数存在栈中，其他存在堆中
只有固定大小的对象和值才能在栈上分配空间，string内部是可变的字符数组</p> <h3 id="_31-mouseover和mouseenter的区别"><a href="#_31-mouseover和mouseenter的区别" class="header-anchor">#</a> 31.mouseover和mouseenter的区别</h3> <ul><li>mouseover当鼠标移入元素或子元素都会触发事件，会有重复触发，冒泡的过程，对应移除事件是mouseout</li> <li>mouseenter当鼠标移除元素本身会触发事件不会冒泡，对应移除事件是mouseleave</li></ul> <h3 id="_32-new一个对象发生了什么"><a href="#_32-new一个对象发生了什么" class="header-anchor">#</a> 32.new一个对象发生了什么?</h3> <ul><li>新建一个空对象</li> <li>为新对象添加属性_proto_并指向构造函数原型</li> <li>绑定this，执行构造函数</li> <li>如果构造函数没有返回对象，就返回这个新对象
手写new</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>function create() {
// 创建⼀个空的对象
let obj = new Object()
// 获得构造函数
let Con = [].shift.call(arguments)
// 链接到原型
obj.__proto__ = Con.prototype
// 绑定 this，执⾏构造函数
let result = Con.apply(obj, arguments)
// 如果构造器没有手动返回对象，则返回第一步的对象
return typeof result === 'object' ? result : obj
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="_33-和-有什么区别"><a href="#_33-和-有什么区别" class="header-anchor">#</a> 33.==和===有什么区别？</h3> <p>前者只要求值相等，后者要求值和类型都要相等</p> <h3 id="_34-实现一个同步的sleep函数"><a href="#_34-实现一个同步的sleep函数" class="header-anchor">#</a> 34.实现一个同步的sleep函数</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>function sleep(ttl) {
  const now = Date.now();
  ttl *= 1000;
  while (Date.now() - now &lt; ttl) {}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_35-字符串去重"><a href="#_35-字符串去重" class="header-anchor">#</a> 35.字符串去重</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const str = 'aaavvvdwww'
var rs = [].filter.call(str, (item, index, origin) =&gt; origin.indexOf(item) == index).join('');
item当前字符、index当前字符索引、origin原字符串
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>let newArr = [...new Set(str.split(&quot;&quot;))].join(&quot;&quot;); 最优解
let newArr = Array.from(new Set(str.split(&quot;&quot;))).join(&quot;&quot;)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_36-怎么判断两个对象相等"><a href="#_36-怎么判断两个对象相等" class="header-anchor">#</a> 36.怎么判断两个对象相等</h3> <p>转成字符串判断
JSON.stringify(obj)==JSON.stringify(obj2)</p> <h3 id="_37-如何生成100个元素为1的数组"><a href="#_37-如何生成100个元素为1的数组" class="header-anchor">#</a> 37.如何生成100个元素为1的数组？</h3> <ul><li>Array(100).fill(1); =&gt; 相类似的是Array(100).map(x=&gt;1)将会创建一个稀疏数组 [empty * 100]</li> <li>Array.from(Array(100), x =&gt; 1); ｜ Array.from({length: 100}, x=&gt;1)</li> <li>Array.apply(null, Array(100)).map(x =&gt; 1);</li></ul> <h3 id="_38-typeof和instanceof的区别"><a href="#_38-typeof和instanceof的区别" class="header-anchor">#</a> 38.typeof和instanceof的区别</h3> <p>typeof判断基础数据类型，null除外
instanceof判断引用数据类型</p> <h4 id="instanceof原理-》基于原型链"><a href="#instanceof原理-》基于原型链" class="header-anchor">#</a> instanceof原理=》基于原型链</h4> <p>内部通过原型链的方式来判断是否为构造函数的实例</p> <h4 id="手写instanceof"><a href="#手写instanceof" class="header-anchor">#</a> 手写instanceof</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>let myInstanceof = (target,origin) =&gt; {
    while(target) {
        if(target.__proto__===origin.prototype) {
            return true
        }
        target = target.__proto__
    }
    return false
}
let a = [1,2,3]
console.log(myInstanceof(a,Array));  // true
console.log(myInstanceof(a,Number));  // false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="typeof和instanceof常见判断"><a href="#typeof和instanceof常见判断" class="header-anchor">#</a> typeof和instanceof常见判断</h4> <p>typeof判断引用类型除函数都是object
instanceof不能判断基本类型 111 instanceof Number =》 false</p> <h3 id="_39-字符串翻转"><a href="#_39-字符串翻转" class="header-anchor">#</a> 39.字符串翻转</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = 'test'
console.log(a.split(&quot;&quot;).reverse().join(&quot;&quot;))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="手动实现reverse函数"><a href="#手动实现reverse函数" class="header-anchor">#</a> 手动实现reverse函数</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>function reverse(s) {
 let r = &quot;&quot;;
 for (const c of s) {
  r = c + r;
 }
 return r;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_40-手写promise-race"><a href="#_40-手写promise-race" class="header-anchor">#</a> 40.手写promise.race</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>Promise.race = (promiseArray) =&gt; {
    return new Promise((resolve, reject) =&gt; {
        promiseArray.forEach((item) =&gt; {
            Promise.resolve(item).then(
                (val) =&gt; {
                    resolve(val);
                },
                (reason) =&gt; {
                    reject(reason);
                }
            );
        });
    });
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_41-js数组哪些方法改变自身-哪些方法不改变"><a href="#_41-js数组哪些方法改变自身-哪些方法不改变" class="header-anchor">#</a> 41.js数组哪些方法改变自身，哪些方法不改变</h3> <ul><li>不改变原数组的方法：concat/join/map/forEach/filter/slice/findIndex</li> <li>改变原数组的方法：push/unshift/pop/shift/sort/splice/reverse =&gt;就是vue中重写的数组</li></ul> <h3 id="_42-说说object-defineproperty"><a href="#_42-说说object-defineproperty" class="header-anchor">#</a> 42.说说Object.defineProperty</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 普通
let o = {};o.a=3;
// Object.defineProperty
let o = {};
Object.defineProperty(o, 'a', {
 configurable: false, // 是否可删除,默认false删除无效
 enumerable: false, // 是否可枚举 默认false
 writable: true, // 是否可更改，默认false修改无效
 value: 3 默认undefined
})
// 可拦截对象属性进行get，set操作
Object.defineProperty(o, &quot;a&quot;, {
 configurable: false,
 enumerable: false,
 get() {
  return this._a;
 },
 set(a) {
  this._a = a * 10;
 },
});
o.a=1; // 赋值调用set方法，取值调用get方法
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="_43-如何全部替代一个子串为另一个"><a href="#_43-如何全部替代一个子串为另一个" class="header-anchor">#</a> 43.如何全部替代一个子串为另一个</h3> <ol><li>str.split('foo').join('bar')</li> <li>str.replaceAll('foo', 'bar')，在ESNext中，支持性不好</li></ol> <h3 id="_44-0-1-0-2不等于0-3"><a href="#_44-0-1-0-2不等于0-3" class="header-anchor">#</a> 44.0.1+0.2不等于0.3？</h3> <p>计算机对于浮点数无法准确表达为二进制，此时再转成10进制就不是我们预期的结果0.2+0.4,0.7+0.1</p> <h3 id="_45-类数组转数组"><a href="#_45-类数组转数组" class="header-anchor">#</a> 45.类数组转数组</h3> <p>类数组指类似数组的对象。有length属性
key是0，1，2这样的，类似数组的下标。常见的有arguments
Array.from(arr)可以将类数组转数组</p> <h3 id="_46"><a href="#_46" class="header-anchor">#</a> 46.</h3> <h3 id="_47-js数组去重-原生js"><a href="#_47-js数组去重-原生js" class="header-anchor">#</a> 47.js数组去重(原生js)</h3> <p>Array.from(new Set(arr))
arr.filter((item, index) =&gt; {
// 返回当前元素在数组中第一个索引，重复出现的返回都是false，就被过滤掉了
return arr.indexOf(item, 0) === index;
})</p> <h3 id="_48-什么是作用域-什么是作用域链"><a href="#_48-什么是作用域-什么是作用域链" class="header-anchor">#</a> 48.什么是作用域？什么是作用域链?</h3> <p>作用域就是变量的可用范围。分成全局作用域，块级作用域({}只在花括号内)
当访问一个变量，首先会在当前作用域查找，找不到就会去上一级作用域查找，直到全局作用域，这个过程就是作用域链</p> <h4 id="js有哪些块级作用域"><a href="#js有哪些块级作用域" class="header-anchor">#</a> js有哪些块级作用域</h4> <p>let,const,以及try-catch的catch语句</p> <h3 id="_49-定时器准时吗"><a href="#_49-定时器准时吗" class="header-anchor">#</a> 49.定时器准时吗</h3> <p>定时器实际可能不准时，受事件循环影响</p> <h4 id="为什么settimeout有最小时延4ms"><a href="#为什么settimeout有最小时延4ms" class="header-anchor">#</a> 为什么setTimeout有最小时延4ms</h4> <p>(不同浏览器的最小时延不一致，chrome最小时延是1ms)定时器嵌套的层级很多超过了5层那么最低是4ms
设置延迟过低会导致 CPU-spinning(会导致计算机没办法进入低功耗模式，这样耗电就比较严重)，经过测试后选定了最小时延4ms</p> <h4 id="如何解决最小时延"><a href="#如何解决最小时延" class="header-anchor">#</a> 如何解决最小时延</h4> <p>可以通过window.postMessage()=&gt;也是宏任务，和addEventListener('message')结合模拟定时器功能</p> <h3 id="_50-promise-all错误处理"><a href="#_50-promise-all错误处理" class="header-anchor">#</a> 50.promise.all错误处理</h3> <p>场景：获取多个用户的信息，即使一个用户失败，也不影响其他用户信息的获取=》此时使用Promise.allSettled;在所有promise都fulfilled或rejected后，
返回一个数组</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>[
{ status: &quot;fulfilled&quot;, value: result} // 成功响应
{ status: &quot;rejected&quot;, reason: error} // 表示错误
]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>原生错误处理:对每个promise进行错误处理，处理后返回res或err，最终到promise.all的还是一个数组，因为错误都被捕获了，所以不会一个reject就挂掉</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>async function handleAllFunc(fun){
    try{
        let res = await fun
        return res
    }catch(err){
        return err
    }
}
let requestArr = [p1(), p2(), p3()]
Promise.all(requestArr.map(item =&gt; handleAllFunc(item))).then(res =&gt; {
    console.log('结果', res);
}).catch(err =&gt; {
    console.log('错误', err);
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_51-异步编程的实现方式"><a href="#_51-异步编程的实现方式" class="header-anchor">#</a> 51.异步编程的实现方式</h3> <p>1.回调函数 简单，但不利于维护，耦合度高(回调地狱)
2.promise 链式调用
3.async 结构清晰更容易理解</p> <h3 id="_52-js如何实现多线程"><a href="#_52-js如何实现多线程" class="header-anchor">#</a> 52.js如何实现多线程</h3> <p>通过worker类
使用这个类的时候，会向浏览器申请一个新的线程来单独执行一个js</p> <h3 id="_53-js的执行机制"><a href="#_53-js的执行机制" class="header-anchor">#</a> 53.js的执行机制？</h3> <p>js是单线程，一次只能执行一个任务，执行机制就是事件循环
(js是单线程。浏览器是多线程)</p> <h3 id="_54-剪贴板相关操作"><a href="#_54-剪贴板相关操作" class="header-anchor">#</a> 54.剪贴板相关操作</h3> <p>可通过Clipboard API来操作(是异步的)=》navigator.clipboard.writeText(text);</p> <h4 id="不支持clipboard-api的浏览器"><a href="#不支持clipboard-api的浏览器" class="header-anchor">#</a> 不支持clipboard API的浏览器</h4> <p>先通过Selection API选中，再通过document.execCommand('copy')进行拷贝</p> <h3 id="_59-js中的数组特点"><a href="#_59-js中的数组特点" class="header-anchor">#</a> 59.js中的数组特点</h3> <ul><li>有两种存储方式，快数组和慢数组。</li> <li>初始化空数组会用快数组(默认空数组初始化大小为4)，快数组使用连续的内存空间，当数组长度达到最大时，会进行动态扩容(老容量*1.5+16)。</li> <li>转成慢数组，以哈希表(key,value)的方式存储数据(不需要连续的内存空间)</li> <li>新加入的索引值比当前容量大等于1024或者快数组新容量是扩容后容量的三倍还多的时候都会由 快数组 转成 慢数组</li></ul> <h3 id="_60-input事件和change事件区别"><a href="#_60-input事件和change事件区别" class="header-anchor">#</a> 60.input事件和change事件区别</h3> <ul><li>input：只要在input框内输入内容就触发</li> <li>change:只有input框内内容改变且失去焦点才触发</li></ul> <h3 id="_61-with作用"><a href="#_61-with作用" class="header-anchor">#</a> 61.with作用</h3> <p>可以用来对对象的属性进行解析，但是不推荐使用，存在数据泄漏的问题
=&gt;如果在with里面赋值一个不存在该对象上的属性，会自动创建全局属性，而不是给这个对象添加新属性</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>a.age = 18
a.name = &quot;aa&quot;
// 等价于
with(a) {
    age = 18
    name = &quot;aa&quot;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_62-e-target和e-currenttarget区别"><a href="#_62-e-target和e-currenttarget区别" class="header-anchor">#</a> 62.e.target和e.currentTarget区别</h3> <ul><li>绑定的事件所在元素没有子元素，两者一样</li> <li>事件绑定在父元素
e.currentTarget无论点击父元素还是子元素都正常执行(e.currentTarget都是parent)
e.target点击父元素无错，点击子元素报错(因为事件绑定在父元素上，此时e.target是children)</li></ul> <h3 id="_63-json相关"><a href="#_63-json相关" class="header-anchor">#</a> 63.json相关</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>以下代码输出什么?
const obj = {
  a: 3,
  b: 4,
  c: null,
  d: undefined,
  get e() {},
};
console.log(JSON.stringify(obj));
// {&quot;a&quot;:3,&quot;b&quot;:4,&quot;c&quot;:null} 对于undefined和function会被忽略掉
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_64-剩余参数和arguments对象区别是什么"><a href="#_64-剩余参数和arguments对象区别是什么" class="header-anchor">#</a> 64.剩余参数和arguments对象区别是什么</h3> <p>剩余参数只包含没有对应形参的实参，而arguments对象包含了传给函数的所有实参
arguments对象不是一个真实数组，而剩余参数是真实的数组，所以剩余参数可以直接使用数组的所有方法，arguments需要转成真实数组才能使用
=&gt;arguments是类数组</p> <h3 id="_65-js有哪些代码规范"><a href="#_65-js有哪些代码规范" class="header-anchor">#</a> 65.*js有哪些代码规范</h3> <ul><li>尽量用===代替==，防止转换的时候出现预期外的异常</li> <li>switch 必须带有default</li> <li>if 使用大括号，不要省略</li> <li>分清楚常量和变量=&gt;const,let</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a4ba95f7.js" defer></script><script src="/assets/js/2.67e62386.js" defer></script><script src="/assets/js/23.0bd65a47.js" defer></script>
  </body>
</html>
