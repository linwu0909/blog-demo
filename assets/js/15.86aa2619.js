(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{287:function(a,s,t){"use strict";t.r(s);var e=t(14),r=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#浏览器"}},[a._v("浏览器")]),s("ul",[s("li",[s("a",{attrs:{href:"#_1-bom属性有哪些方法-bom是浏览器对象模型-dom-文档对象模型"}},[a._v("1.BOM属性有哪些方法？（BOM是浏览器对象模型）DOM(文档对象模型)")])]),s("li",[s("a",{attrs:{href:"#_2-cookie-sessionstorage-localstorage-本地持久化"}},[a._v("2.Cookie，sessionStorage，localStorage｜本地持久化？")])]),s("li",[s("a",{attrs:{href:"#_3-cookie和session区别-单个cookie保存的数据不超过4k"}},[a._v("3.cookie和session区别(单个cookie保存的数据不超过4K)？")])]),s("li",[s("a",{attrs:{href:"#_4-在地址栏输入一个url到页面渲染完毕-中间发生了什么-网络阶段-解析阶段-渲染阶段"}},[a._v("4.在地址栏输入一个url到页面渲染完毕，中间发生了什么？=>(网络阶段=>解析阶段=>渲染阶段)")])]),s("li",[s("a",{attrs:{href:"#_6-重绘和重排-回流"}},[a._v("6.重绘和重排(回流)？")])]),s("li",[s("a",{attrs:{href:"#_7-跨域-同源策略"}},[a._v("7.跨域｜同源策略?")])]),s("li",[s("a",{attrs:{href:"#_8-前端如何反向代理proxy-用来本地测试"}},[a._v("8.前端如何反向代理proxy(用来本地测试)？")])]),s("li",[s("a",{attrs:{href:"#_9-浏览器请求头的connection-keep-alive作用"}},[a._v("9.浏览器请求头的connection:keep-alive作用？")])]),s("li",[s("a",{attrs:{href:"#_10-多个页面之间通讯问题"}},[a._v("10.多个页面之间通讯问题？")])]),s("li",[s("a",{attrs:{href:"#_12-虚拟dom解决的问题"}},[a._v("12.虚拟dom解决的问题？")])]),s("li",[s("a",{attrs:{href:"#_13-虚拟dom实现原理"}},[a._v("13.虚拟dom实现原理？")])]),s("li",[s("a",{attrs:{href:"#_14-cookie常用字段"}},[a._v("14.cookie常用字段？")])]),s("li",[s("a",{attrs:{href:"#_15-http缓存机制了解吗"}},[a._v("15.http缓存机制了解吗？")])]),s("li",[s("a",{attrs:{href:"#_16-dns解析过程-dns是域名系统缩写-dns解析就是将域名转换成对应的ip地址"}},[a._v("16.DNS解析过程(DNS是域名系统缩写，DNS解析就是将域名转换成对应的ip地址)？")])]),s("li",[s("a",{attrs:{href:"#_17-a-com的cookie在b-com能访问到吗"}},[a._v("17.a.com的cookie在b.com能访问到吗？")])]),s("li",[s("a",{attrs:{href:"#_18-常见的浏览器内核"}},[a._v("*18.常见的浏览器内核？")])]),s("li",[s("a",{attrs:{href:"#_19-cookie-session模式和token模式登录有什么不同"}},[a._v("19.cookie-session模式和token模式登录有什么不同？")])]),s("li",[s("a",{attrs:{href:"#_20-service-worker"}},[a._v("*20.service worker？")])]),s("li",[s("a",{attrs:{href:"#_21-performance-api中哪个指标用来衡量首屏时间"}},[a._v("21.performance API中哪个指标用来衡量首屏时间？")])]),s("li",[s("a",{attrs:{href:"#_22-load和domcontentloaded事件的先后顺序"}},[a._v("22.load和domContentLoaded事件的先后顺序？")])]),s("li",[s("a",{attrs:{href:"#_23-data-url是什么"}},[a._v("*23.Data Url是什么？")])]),s("li",[s("a",{attrs:{href:"#_24-gzip如何开启"}},[a._v("24.gzip如何开启？")])]),s("li",[s("a",{attrs:{href:"#_25-web-worker"}},[a._v("*25.web worker？")])]),s("li",[s("a",{attrs:{href:"#_26-前端大文件存储"}},[a._v("*26.前端大文件存储？")])]),s("li",[s("a",{attrs:{href:"#_27-页面级数据暂存"}},[a._v("*27.页面级数据暂存？")])]),s("li",[s("a",{attrs:{href:"#_28-浏览器架构"}},[a._v("28.浏览器架构？")])]),s("li",[s("a",{attrs:{href:"#_29-内存泄漏-memory-leak"}},[a._v("29.内存泄漏(memory leak)？")])]),s("li",[s("a",{attrs:{href:"#_30-前端性能优化-rail了解过吗"}},[a._v("*30.前端性能优化-RAIL了解过吗？")])]),s("li",[s("a",{attrs:{href:"#_31-浏览器有哪些进程了解吗"}},[a._v("*31.浏览器有哪些进程了解吗？")])]),s("li",[s("a",{attrs:{href:"#_32-如何统计当前页面出现的所有标签"}},[a._v("32.如何统计当前页面出现的所有标签？")])]),s("li",[s("a",{attrs:{href:"#_33-localhost-3000和localhost-5000的cookie共享吗"}},[a._v("33.localhost：3000和localhost: 5000的cookie共享吗？")])])])])])]),s("p"),a._v(" "),s("h2",{attrs:{id:"浏览器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[a._v("#")]),a._v(" 浏览器")]),a._v(" "),s("h3",{attrs:{id:"_1-bom属性有哪些方法-bom是浏览器对象模型-dom-文档对象模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-bom属性有哪些方法-bom是浏览器对象模型-dom-文档对象模型"}},[a._v("#")]),a._v(" 1.BOM属性有哪些方法？（BOM是浏览器对象模型）DOM(文档对象模型)")]),a._v(" "),s("p",[a._v("常用document.getElementById(根据id找到元素) document.getElementsByName(返回指定名称的元素的集合)")]),a._v(" "),s("h4",{attrs:{id:"_1-1location对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1location对象"}},[a._v("#")]),a._v(" 1.1location对象")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("location.href返回当前网页的URL\nlocation.search返回URL中参数字符串即？号后的内容\nlocation.hash返回#后面的内容\nlocation.host返回域名 www.baidu.com\nlocation.hostname 返回主域名部分 baidu.com\nlocation.reload() 重载当前页面\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("h4",{attrs:{id:"_1-2history对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2history对象"}},[a._v("#")]),a._v(" 1.2history对象")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("history.go()前进或后退指定的页面数\nhistory.back()后退一页\nhistory.forward()前进一页\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("h4",{attrs:{id:"_1-3navigator对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3navigator对象"}},[a._v("#")]),a._v(" 1.3navigator对象")]),a._v(" "),s("p",[a._v("navigator.userAgent 返回用户代理头 内容包含浏览器版本手机系统等等")]),a._v(" "),s("h3",{attrs:{id:"_2-cookie-sessionstorage-localstorage-本地持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-cookie-sessionstorage-localstorage-本地持久化"}},[a._v("#")]),a._v(" 2.Cookie，sessionStorage，localStorage｜本地持久化？")]),a._v(" "),s("p",[a._v('(localStorage.setItem(key, value) localStorage.getItem(key) sessionStorage设置和取出用法相同)\n都是将数据保存在浏览器端\ncookie中的数据可以传给服务端\ndocument.cookie="key=value"; 删除只需把过期时间设置为现在以前即可，修改可以用同一个key不同的value来覆盖原来的value。')]),a._v(" "),s("p",[a._v("存储时间：")]),a._v(" "),s("ul",[s("li",[a._v("cookie在过期时间之前一直有效（cookie不设置过期时间，默认就是关闭浏览器失效）")]),a._v(" "),s("li",[a._v("sessionStorage仅在当前浏览器窗口关闭前有效")]),a._v(" "),s("li",[a._v("localStorage可以持久保存数据，需要手动清除\n(对于同一个网站，不同标签页共享cookie和localStorage，不共享sessionStorage)\n存储大小：")]),a._v(" "),s("li",[a._v("cookie只有4K")]),a._v(" "),s("li",[a._v("sessionStorage和localStorage大概可以保存5M信息\n服务器交互：\ncookie会自动在请求头中携带，在服务器和浏览器之间相互传递\nsessionStorage和localStorage不会自动把数据发送给服务器")])]),a._v(" "),s("p",[a._v("cookie经常用来保存用户登陆状态(http无状态，需要用cookie存用户登陆状态)，设置过期时间在浏览器保存用户id\nsession可以用来存储用户的登陆信息")]),a._v(" "),s("p",[a._v("cookie存在跨域问题，现在常用localStorage存token")]),a._v(" "),s("h4",{attrs:{id:"sessionstorage多窗口不能共享状态吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sessionstorage多窗口不能共享状态吗"}},[a._v("#")]),a._v(" sessionStorage多窗口不能共享状态吗？")]),a._v(" "),s("p",[a._v("不一定。 正常来说，每个tab会创建自己的sessionStorage，关闭时会清除对应的sessionStorage\n但是在本页面打开新同源页面会临时共享之前页面的sessionStorage(比如通过window.open打开同源的页面)\n=》等于打开时带过去，但是之后再在原页面修改新页面不会获取到新的值=》MDN上称为复制")]),a._v(" "),s("h3",{attrs:{id:"_3-cookie和session区别-单个cookie保存的数据不超过4k"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-cookie和session区别-单个cookie保存的数据不超过4k"}},[a._v("#")]),a._v(" 3.cookie和session区别(单个cookie保存的数据不超过4K)？")]),a._v(" "),s("ul",[s("li",[a._v("cookie的数据保存在客户端，session的数据保存在服务端")]),a._v(" "),s("li",[a._v("cookie最大只能保存4K，session的大小没有限制，但是过大会消耗服务器性能")]),a._v(" "),s("li",[a._v("cookie不安全，攻击者可以通过分析本地的cookie进行cookie欺骗。如果数据考虑到安全需要使用session")])]),a._v(" "),s("h4",{attrs:{id:"session工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#session工作原理"}},[a._v("#")]),a._v(" Session工作原理？")]),a._v(" "),s("p",[a._v("浏览器第一次访问服务器时，服务器会创建一个session对象，把产生的session_id放在响应头返回给浏览器，\n浏览器收到后会保存到cookie中，下次再访问时,就会把session_id放到请求头发送给服务器，\n服务器通过session_id找到对应的session.\n(用户数据都保存在session中，session机制决定当前客户端只会获取到自己的session)")]),a._v(" "),s("h4",{attrs:{id:"cookie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[a._v("#")]),a._v(" cookie")]),a._v(" "),s("p",[a._v("cookie具有不可跨域名性。\n设置setMaxAge为0会删除cookie,修改cookie通过新增同名cookie覆盖用来的cookie，只能修改value和maxAge，否则视为新增。\n如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。这样浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie")]),a._v(" "),s("h3",{attrs:{id:"_4-在地址栏输入一个url到页面渲染完毕-中间发生了什么-网络阶段-解析阶段-渲染阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-在地址栏输入一个url到页面渲染完毕-中间发生了什么-网络阶段-解析阶段-渲染阶段"}},[a._v("#")]),a._v(" 4.在地址栏输入一个url到页面渲染完毕，中间发生了什么？=>(网络阶段=>解析阶段=>渲染阶段)")]),a._v(" "),s("p",[a._v("DNS解析->TCP连接->发送http请求->服务器处理请求->返回响应->浏览器渲染页面")]),a._v(" "),s("h4",{attrs:{id:"dns解析过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns解析过程"}},[a._v("#")]),a._v(" DNS解析过程")]),a._v(" "),s("p",[a._v("先去浏览器找是否有该域名对应的ip地址，没有会去系统缓存中查找\n也没有就会去本地域名服务器查找，如果没找到会去根域名服务器请求解析\n根域名会返回该域名所属的主域名服务器地址\n本地服务器再去主域名服务器查询，主域名服务器没找到会递归向下一级的子域名服务器查找，直到找到返回给本地域名服务器\n本地域名服务器将结果进行缓存，并返回给客户机")]),a._v(" "),s("h4",{attrs:{id:"tcp连接-http请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp连接-http请求"}},[a._v("#")]),a._v(" TCP连接+HTTP请求")]),a._v(" "),s("p",[a._v("DNS解析得到ip地址和端口后=》\n浏览器会构造一个http请求，请求报文包括请求行(method=》get，post等,requestUrl,http version)请求头和请求体\n然后把http请求封装在tcp包中，tcp包一次经过(传输层，网络层，数据链路层，物理层)到达服务器")]),a._v(" "),s("h4",{attrs:{id:"浏览器如何渲染页面-浏览器的运行机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器如何渲染页面-浏览器的运行机制"}},[a._v("#")]),a._v(" 浏览器如何渲染页面｜浏览器的运行机制")]),a._v(" "),s("ul",[s("li",[a._v("解析html文件构建dom树")]),a._v(" "),s("li",[a._v("解析css文件构成CSS规则树")]),a._v(" "),s("li",[a._v("根据dom树和css规则树构建渲染树")]),a._v(" "),s("li",[a._v("布局(layout，计算出每个节点在屏幕的位置)和绘制渲染树(遍历render树，绘制每个节点)")])]),a._v(" "),s("h4",{attrs:{id:"css是否阻塞html解析-渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css是否阻塞html解析-渲染"}},[a._v("#")]),a._v(" css是否阻塞html解析，渲染?")]),a._v(" "),s("p",[a._v("css不会阻塞dom树的解析(css解析和dom树的解析是并行操作)，但会阻塞dom树的渲染\njs会阻塞dom树的解析和渲染\n=>如果css不阻塞dom的渲染，那么会在解析css的过程中渲染一次，而css解析完又会重新渲染一次，浪费性能")]),a._v(" "),s("h3",{attrs:{id:"_6-重绘和重排-回流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-重绘和重排-回流"}},[a._v("#")]),a._v(" 6.重绘和重排(回流)？")]),a._v(" "),s("p",[a._v("（浏览器需要重新渲染树，就是重排(大)，只重新绘制受影响的部分是重绘(小)）")]),a._v(" "),s("ul",[s("li",[a._v("重绘：浏览器重新绘制，改color，background-color等外观属性都会触发")]),a._v(" "),s("li",[a._v("重排：隐藏或修改尺寸大小/添加或删除dom元素等都会触发。每个页面第一次加载的时候都会触发一次重排。")]),a._v(" "),s("li",[a._v("重排一定触发重绘，重绘不一定触发重排")])]),a._v(" "),s("h4",{attrs:{id:"_6-1减少重绘重排的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-1减少重绘重排的方法"}},[a._v("#")]),a._v(" 6.1减少重绘重排的方法?")]),a._v(" "),s("ul",[s("li",[a._v("少进行dom操作")]),a._v(" "),s("li",[a._v("对于多次触发重排的元素可以使用绝对定位脱离文档流")]),a._v(" "),s("li",[a._v("统一改变样式，不要一个个元素改")])]),a._v(" "),s("h3",{attrs:{id:"_7-跨域-同源策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-跨域-同源策略"}},[a._v("#")]),a._v(" 7.跨域｜同源策略?")]),a._v(" "),s("p",[a._v("同源指的是协议，域名，端口都相同。三者有任一不同，就构成了跨域。同源目的是为了浏览器安全。\n后端不存在跨域，跨域是因为浏览器的同源政策。")]),a._v(" "),s("h4",{attrs:{id:"如何解决跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何解决跨域"}},[a._v("#")]),a._v(" 如何解决跨域？")]),a._v(" "),s("ul",[s("li",[a._v("jsonp(将声明的回调函数名称拼接到请求的url后面，通过在script元素的src属性进行发送。服务器接收到请求后，\n把函数名和需要返回给客户端的数据拼接成字符串进行返回，客户端调用之前声明的回调函数对返回的数据进行操作。要求必须是get请求。一定要服务端配合)\n浏览器对于script，iframe等标签的src等属性，是没有同源策略限制的")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function jsonp ({ url, onData, params }) {\n  const script = document.createElement('script')\n  // 一、为了避免全局污染，使用一个随机函数名\n  const cbFnName = `JSONP_PADDING_${Math.random().toString().slice(2)}`\n  // 二、默认 callback 函数为 cbFnName\n  script.src = `${url}?${stringify({ callback: cbFnName, ...params })}`\n  // 三、使用 onData 作为 cbFnName 回调函数，接收数据\n  window[cbFnName] = onData;\n  document.body.appendChild(script)\n}\n// 发送 JSONP 请求\njsonp({\n  url: 'http://localhost:10010',\n  params: { id: 10000 },\n  onData (data) {\n    console.log('Data:', data)\n  }\n})\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br")])]),s("ul",[s("li",[a._v("cors(需要服务器响应头设置允许跨域Access-Control-Allow-Origin: *) =》安全问题 并且不能携带cookie\n=》cors实际上浏览器发出了请求，服务端也正常返回，只是浏览器不接收。需要设置后才可以接收")]),a._v(" "),s("li",[a._v("nginx反向代理(正向代理是客户端代理，反向代理是服务端代理)=>反向代理为同一域名就不存在跨域\nlocation /api {\n"),s("h1",{attrs:{id:"或者是-http-localhost-8080"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#或者是-http-localhost-8080"}},[a._v("#")]),a._v(" 或者是 http://localhost:8080")]),a._v("\nproxy_pass http://api.shanyue.tech;\n}\n常用的是将/api开头的都代理到后端的服务器上")]),a._v(" "),s("li",[a._v("proxy(本地 webpack-dev-server)")])]),a._v(" "),s("h3",{attrs:{id:"_8-前端如何反向代理proxy-用来本地测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-前端如何反向代理proxy-用来本地测试"}},[a._v("#")]),a._v(" 8.前端如何反向代理proxy(用来本地测试)？")]),a._v(" "),s("p",[a._v("vue.config.js可以配置会自动代理到后端。相当于vue开启了一个服务器，通过服务器转发你的请求到跨域的后端服务器。(服务器之间没有跨域)")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("devServer: {\n    proxy: {\n        '/api': { // 需要代理的接口\n            target: '后端url',\n            changeOrigin: true,//是否跨域\n            pathRewrite: { // 重定向地址\n                '^/api': ''\n            }\n        }\n    }\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br")])]),s("h3",{attrs:{id:"_9-浏览器请求头的connection-keep-alive作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-浏览器请求头的connection-keep-alive作用"}},[a._v("#")]),a._v(" 9.浏览器请求头的connection:keep-alive作用？")]),a._v(" "),s("p",[a._v("说明TCP连接保持打开状态，浏览器可以继续发送请求")]),a._v(" "),s("h3",{attrs:{id:"_10-多个页面之间通讯问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-多个页面之间通讯问题"}},[a._v("#")]),a._v(" 10.多个页面之间通讯问题？")]),a._v(" "),s("ul",[s("li",[a._v("localstorage存储，监听storage事件，就可以获得存储的值")])]),a._v(" "),s("h3",{attrs:{id:"_12-虚拟dom解决的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-虚拟dom解决的问题"}},[a._v("#")]),a._v(" 12.虚拟dom解决的问题？")]),a._v(" "),s("ul",[s("li",[a._v("用来解决浏览器性能问题。")]),a._v(" "),s("li",[a._v("操作dom时，浏览器会从构建dom树开始整个流程执行一遍，频繁操作dom会引起不必要的节点位置计算，影响浏览器性能。")])]),a._v(" "),s("h3",{attrs:{id:"_13-虚拟dom实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-虚拟dom实现原理"}},[a._v("#")]),a._v(" 13.虚拟dom实现原理？")]),a._v(" "),s("p",[a._v("用js对象模拟dom树，根据diff算法比较新老dom树的差异，再用patch算法将差异应用到真正dom树上")]),a._v(" "),s("h4",{attrs:{id:"虚拟dom和真实dom的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom和真实dom的区别"}},[a._v("#")]),a._v(" 虚拟dom和真实dom的区别？")]),a._v(" "),s("ul",[s("li",[a._v("虚拟dom是以对象的形式模拟真实dom树")]),a._v(" "),s("li",[a._v("操作虚拟dom消耗性能小，并且不会进行重排和重绘的操作")]),a._v(" "),s("li",[a._v("操作真实dom，会触发频繁的重绘和重排，性能消耗比较大")]),a._v(" "),s("li",[a._v("当HTML解析到script标签时，会暂停构建DOM，直到解析完成才会从暂停的地方重新开始构建")])]),a._v(" "),s("h3",{attrs:{id:"_14-cookie常用字段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-cookie常用字段"}},[a._v("#")]),a._v(" 14.cookie常用字段？")]),a._v(" "),s("ul",[s("li",[a._v("path:在该路径下的页面才能访问到cookie")]),a._v(" "),s("li",[a._v("domain：子域，在该子域下才可以访问cookie，一般设置/=》表示同站点下的所有页面都可以访问这个cookie\n=》如domain设置为 .a.com,则b.a.com和c.a.com均可使用该Cookie")]),a._v(" "),s("li",[a._v("name：cookie名称")]),a._v(" "),s("li",[a._v("value：cookie值")]),a._v(" "),s("li",[a._v("httponly：设置不允许通过js来访问cookie(dom api的方式，防xss)")]),a._v(" "),s("li",[a._v("expires：设置过期时间")]),a._v(" "),s("li",[a._v("*same：限制第三方cookie")])]),a._v(" "),s("h3",{attrs:{id:"_15-http缓存机制了解吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-http缓存机制了解吗"}},[a._v("#")]),a._v(" 15.http缓存机制了解吗？")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("会先判断是否有强缓存，(根据header判断)=》状态码200")])]),a._v(" "),s("li",[s("p",[a._v("如果没有，会发请求到服务器验证是否命中协商缓存，如果也没有，才去服务器直接取数据。")])]),a._v(" "),s("li",[s("p",[a._v("强缓存(Expires或Cache-control，同时存在Cache-control优先级更高，状态码返回200)\ncache-control: no-cache会缓存，开启后每次会像服务端发请求验证才可以使用缓存 no-store不缓存\n强缓存可以通过设置cache-control：max-age或者expires: Sun, 06 Mar 2022 09:28:39 GMT")])]),a._v(" "),s("li",[s("p",[a._v("协商缓存(Last-Modified/If-Modified-Since/If-UnModified-Since，Etag/If-None-Match/If-Match, ETag优先级更高，状态码返回304)\n协商缓存可以通过last-modify或者etag来进行判断")])]),a._v(" "),s("li",[s("p",[a._v("Last-Modified/If-Modified-Since\n浏览器发送请求，返回的响应头会有last-modify。\n当再次请求last-modify会做为If-Modify-Since放到请求头里给服务端校验")])]),a._v(" "),s("li",[s("p",[a._v("Etag/If-None-Match\n浏览器发送请求，返回的响应头会有ETag\n当再次请求Etag会作为If-None-Match放到请求头里给服务端校验。(服务端校验是否和原来的Etag值相等)")])])]),a._v(" "),s("h4",{attrs:{id:"强缓存和协商缓存各自存在的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强缓存和协商缓存各自存在的问题"}},[a._v("#")]),a._v(" 强缓存和协商缓存各自存在的问题")]),a._v(" "),s("ul",[s("li",[a._v("expire可能存在时间不同步的问题，expires用的是绝对时间，cache-control用的是相对时间。")]),a._v(" "),s("li",[a._v("last-modify有个精度问题，到秒。e-tag没有精度问题，只要文件改变，etag值就发生改变=》etag是服务器随机生成的字符串")])]),a._v(" "),s("h3",{attrs:{id:"_16-dns解析过程-dns是域名系统缩写-dns解析就是将域名转换成对应的ip地址"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-dns解析过程-dns是域名系统缩写-dns解析就是将域名转换成对应的ip地址"}},[a._v("#")]),a._v(" 16.DNS解析过程(DNS是域名系统缩写，DNS解析就是将域名转换成对应的ip地址)？")]),a._v(" "),s("p",[a._v("浏览器缓存->系统缓存->本地域名服务器->根域名服务器->主域名服务器去找->去子服务器去找->继续往下查找直到知道->返回给本地域名服务器->返回给客户机。")]),a._v(" "),s("ol",[s("li",[a._v("先检查浏览器缓存是否有域名对应的ip地址")]),a._v(" "),s("li",[a._v("没有会去系统缓存中查询")]),a._v(" "),s("li",[a._v("都没有采取请求本地域名服务器解析")]),a._v(" "),s("li",[a._v("本地服务器没有会去根域名服务器查询")]),a._v(" "),s("li",[a._v("根域名服务器返回所查询域的主域名服务器地址")]),a._v(" "),s("li",[a._v("本地服务器去主域名服务器查询")]),a._v(" "),s("li",[a._v("主域名服务器如果没有找到，会重复向下一级的子域名服务器查询，直到找到")]),a._v(" "),s("li",[a._v("本地域名服务器把结果进行缓存，并返回给客户机")])]),a._v(" "),s("ul",[s("li",[a._v("先去浏览器找是否有该域名对应的ip地址，没有会去系统缓存中查找")]),a._v(" "),s("li",[a._v("也没有就会去本地域名服务器查找，如果没找到会去根域名服务器请求解析")]),a._v(" "),s("li",[a._v("根域名会返回该域名所属的主域名服务器地址")]),a._v(" "),s("li",[a._v("本地服务器再去主域名服务器查询，主域名服务器没找到会递归向下一级的子域名服务器查找，直到找到返回给本地域名服务器")]),a._v(" "),s("li",[a._v("本地域名服务器将结果进行缓存，并返回给客户机")])]),a._v(" "),s("p",[a._v("拆分就是：客户机(浏览器=>系统) 服务器(本地域名=>根域名=>本地域名 本地域名=>主域名) 递归(主域名的子域名递归查找=》本地域名服务器) 客户机")]),a._v(" "),s("h3",{attrs:{id:"_17-a-com的cookie在b-com能访问到吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-a-com的cookie在b-com能访问到吗"}},[a._v("#")]),a._v(" 17.a.com的cookie在b.com能访问到吗？")]),a._v(" "),s("p",[a._v("能。在a.com域名下的网站引入b.com域名下的js，这个js需要获取b.com的cookie。SSO单点登录通过统一的验证中心。")]),a._v(" "),s("h3",{attrs:{id:"_18-常见的浏览器内核"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-常见的浏览器内核"}},[a._v("#")]),a._v(" *18.常见的浏览器内核？")]),a._v(" "),s("ul",[s("li",[a._v("Safari,Chrome都是webkit内核=》chrome现在调整为blink内核")]),a._v(" "),s("li",[a._v("浏览器引擎分成：渲染引擎和JS引擎")]),a._v(" "),s("li",[a._v("渲染引擎负责将html和css等渲染到页面上，不同内核渲染效果不同，我们平时说的浏览器兼容就是兼容不同内核。")]),a._v(" "),s("li",[a._v("JS引擎负责解析js来实现网页动态效果")])]),a._v(" "),s("h3",{attrs:{id:"_19-cookie-session模式和token模式登录有什么不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-cookie-session模式和token模式登录有什么不同"}},[a._v("#")]),a._v(" 19.cookie-session模式和token模式登录有什么不同？")]),a._v(" "),s("ul",[s("li",[a._v("因为http协议无状态，所以登录需要辨别客户端的身份。")]),a._v(" "),s("li",[a._v("cookie-session在负载均衡时有问题，分发的机器可能没有保存用户信息的session。")]),a._v(" "),s("li",[a._v("token的没有这种问题。")])]),a._v(" "),s("p",[a._v("token登陆流程：")]),a._v(" "),s("ol",[s("li",[a._v("发送请求到服务端，服务端返回一个带签名的token给客户端")]),a._v(" "),s("li",[a._v("客户端存储token，每次请求都携带这个token")]),a._v(" "),s("li",[a._v("服务端验证token，成功才返回数据")])]),a._v(" "),s("h3",{attrs:{id:"_20-service-worker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_20-service-worker"}},[a._v("#")]),a._v(" *20.service worker？")]),a._v(" "),s("p",[a._v("常用来做缓存文件，提高首屏速度")]),a._v(" "),s("h3",{attrs:{id:"_21-performance-api中哪个指标用来衡量首屏时间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21-performance-api中哪个指标用来衡量首屏时间"}},[a._v("#")]),a._v(" 21.performance API中哪个指标用来衡量首屏时间？")]),a._v(" "),s("p",[a._v("window.performance.timing")]),a._v(" "),s("h3",{attrs:{id:"_22-load和domcontentloaded事件的先后顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_22-load和domcontentloaded事件的先后顺序"}},[a._v("#")]),a._v(" 22.load和domContentLoaded事件的先后顺序？")]),a._v(" "),s("ul",[s("li",[a._v("初始HTML文档被完全加载和解析后，domContentLoaded事件被触发(无需等待样式，图像的完全加载)")]),a._v(" "),s("li",[a._v("当整个页面及所有依赖资源(样式表和图片)都加载完成时，将触发load事件\n=》domContentLoad触发，说明dom结构加载完成，而load触发说明页面所有资源都加载完成")])]),a._v(" "),s("h3",{attrs:{id:"_23-data-url是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_23-data-url是什么"}},[a._v("#")]),a._v(" *23.Data Url是什么？")]),a._v(" "),s("ul",[s("li",[a._v("平时主要用来把图片转成base64格式嵌入网页，是前缀为data：的URL。")]),a._v(" "),s("li",[a._v("缺点：base64格式的图片会比原来的体积大三分之一左右，不会缓存每次都要下载(可以写入到css中，随css被缓存下来)")])]),a._v(" "),s("h3",{attrs:{id:"_24-gzip如何开启"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_24-gzip如何开启"}},[a._v("#")]),a._v(" 24.gzip如何开启？")]),a._v(" "),s("p",[a._v("通过nginx来开启gzip=》nginx的http配置里加上gzip on｜off")]),a._v(" "),s("h4",{attrs:{id:"原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),s("p",[a._v("主要是对重复数据做处理，所以重复度越高的文件可压缩的空间越大")]),a._v(" "),s("h4",{attrs:{id:"可以对图片进行gzip压缩吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可以对图片进行gzip压缩吗"}},[a._v("#")]),a._v(" 可以对图片进行gzip压缩吗")]),a._v(" "),s("p",[a._v("可以，但是基本都不开启，因为可能会使它们变得更大。")]),a._v(" "),s("h3",{attrs:{id:"_25-web-worker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_25-web-worker"}},[a._v("#")]),a._v(" *25.web worker？")]),a._v(" "),s("ul",[s("li",[a._v("百万条数据计算，会造成页面假死(GUI渲染线程和JS引擎线程互斥，js有大量计算时，会造成UI阻塞，严重就是页面卡死)")]),a._v(" "),s("li",[a._v("web worker主要还是通过多线程解决问题。web worker线程中可以执行ajax请求")])]),a._v(" "),s("h3",{attrs:{id:"_26-前端大文件存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_26-前端大文件存储"}},[a._v("#")]),a._v(" *26.前端大文件存储？")]),a._v(" "),s("p",[a._v("可以用indexedDB，按key/value形式存储，更接近于非关系型数据库")]),a._v(" "),s("h3",{attrs:{id:"_27-页面级数据暂存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_27-页面级数据暂存"}},[a._v("#")]),a._v(" *27.页面级数据暂存？")]),a._v(" "),s("p",[a._v("比如浏览到第几页=》通过把整个组件的data缓存到localStorage来实现。因为$data是只读的，所以要通过Object.assign()把拷贝的对象返回给data")]),a._v(" "),s("h3",{attrs:{id:"_28-浏览器架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_28-浏览器架构"}},[a._v("#")]),a._v(" 28.浏览器架构？")]),a._v(" "),s("ul",[s("li",[a._v("浏览器主要由用户界面(包括地址栏，书签等)，浏览器引擎(提供了开始加载URL，前进后退等方法)，渲染引擎(负责显示请求的内容)，网络(HTTP请求)，")]),a._v(" "),s("li",[a._v("显示后端(包括窗口，组合框等)，JS解释器器，XML解析器(将XML文档解析成DOM)，存储这八个部分组成。")])]),a._v(" "),s("h3",{attrs:{id:"_29-内存泄漏-memory-leak"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_29-内存泄漏-memory-leak"}},[a._v("#")]),a._v(" 29.内存泄漏(memory leak)？")]),a._v(" "),s("ul",[s("li",[a._v("内存泄漏就是指内存得不到释放，最后会导致内存溢出")]),a._v(" "),s("li",[a._v("原因：垃圾回收无法回收这块内存(这样这块内存就被浪费了，就是内存泄漏)")])]),a._v(" "),s("h4",{attrs:{id:"常见的有-循环引用及不规范使用闭包导致的内存泄漏-事件重复监听未移除也会导致"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的有-循环引用及不规范使用闭包导致的内存泄漏-事件重复监听未移除也会导致"}},[a._v("#")]),a._v(" 常见的有=>循环引用及不规范使用闭包导致的内存泄漏(事件重复监听未移除也会导致)")]),a._v(" "),s("ol",[s("li",[a._v("闭包导致的内存泄漏无法解决，只能尽量避免使用闭包")]),a._v(" "),s("li",[a._v("全局变量")]),a._v(" "),s("li",[a._v("定时器")])]),a._v(" "),s("h4",{attrs:{id:"优化手段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化手段"}},[a._v("#")]),a._v(" 优化手段")]),a._v(" "),s("ul",[s("li",[a._v("堆内存：参数指针指向null即可")]),a._v(" "),s("li",[a._v("堆内存：取消上下文引用即可")])]),a._v(" "),s("h3",{attrs:{id:"_30-前端性能优化-rail了解过吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_30-前端性能优化-rail了解过吗"}},[a._v("#")]),a._v(" *30.前端性能优化-RAIL了解过吗？")]),a._v(" "),s("ul",[s("li",[a._v("RAIL是个性能模型，RAIL分别对应Response,Animation,Idle,Load")]),a._v(" "),s("li",[a._v("Response响应速度")]),a._v(" "),s("li",[a._v("Animation动画的渲染速度")]),a._v(" "),s("li",[a._v("Idle最大空闲空间=》可以在空闲空间执行一些延后的任务，但是必须以用户的交互为最高优先级")]),a._v(" "),s("li",[a._v("Load：页面加载时间")])]),a._v(" "),s("h4",{attrs:{id:"分析rail工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分析rail工具"}},[a._v("#")]),a._v(" 分析RAIL工具")]),a._v(" "),s("ul",[s("li",[a._v("Chrome DevTools")]),a._v(" "),s("li",[a._v("LightHouse")])]),a._v(" "),s("h3",{attrs:{id:"_31-浏览器有哪些进程了解吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_31-浏览器有哪些进程了解吗"}},[a._v("#")]),a._v(" *31.浏览器有哪些进程了解吗？")]),a._v(" "),s("ul",[s("li",[a._v("浏览器包含了browser进程(浏览器主进程)，第三方插件进程，GPU进程(浏览器渲染进程)。")]),a._v(" "),s("li",[a._v("GPU进程包括：GUI渲染线程，JS引擎线程，事件触发线程，定时器线程，HTTP请求线程。GUI渲染线程和JS引擎线程互斥，一个执行另一个会被挂起")]),a._v(" "),s("li",[a._v("浏览器页面初次渲染后，JS引擎线程和事件触发线程工作流程：")])]),a._v(" "),s("ol",[s("li",[a._v("同步任务在JS引擎线程上执行，形成执行栈")]),a._v(" "),s("li",[a._v("主线程外事件触发线程管理一个任务队列，只要异步任务有了结果就在任务队列中放置一个事件")]),a._v(" "),s("li",[a._v("执行栈中的同步任务执行完毕，系统就会读取任务队列，如果有异步任务要执行，将其加到主线程的执行栈中并执行其异步任务")])]),a._v(" "),s("h3",{attrs:{id:"_32-如何统计当前页面出现的所有标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_32-如何统计当前页面出现的所有标签"}},[a._v("#")]),a._v(" 32.如何统计当前页面出现的所有标签？")]),a._v(" "),s("h4",{attrs:{id:"获取所有标签的api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#获取所有标签的api"}},[a._v("#")]),a._v(" 获取所有标签的API")]),a._v(" "),s("ul",[s("li",[a._v("document.querySelectorAll('*')")]),a._v(" "),s("li",[a._v("document.getELementsByTagName('*')")]),a._v(" "),s("li",[a._v("$$('*')=>浏览器控制台使用")])]),a._v(" "),s("h4",{attrs:{id:"实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 通过reduce去比较大小，返回最多的标签\nconst maxBy = (list, keyBy) => list.reduce((x, y) => (keyBy(x) > keyBy(y) ? x : y));\nfunction getFrequentTag() {\n  // 获取到所有标签\n  let tags = [...document.querySelectorAll(\"*\")]\n    .map((x) => x.tagName)\n    // 通过reduce去计算每个标签出现的次数\n    tags = tags.reduce((o, tag) => {\n      o[tag] = o[tag] ? o[tag] + 1 : 1;\n      return o;\n    }, {});\n  return maxBy(Object.entries(tags), (tag) => tag[1]);\n}\n// 最后返回的是个数组，key是最多的标签，value是出现的次数['LI', 1120]\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br")])]),s("h3",{attrs:{id:"_33-localhost-3000和localhost-5000的cookie共享吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_33-localhost-3000和localhost-5000的cookie共享吗"}},[a._v("#")]),a._v(" 33.localhost：3000和localhost: 5000的cookie共享吗？")]),a._v(" "),s("p",[a._v("共享。对浏览器来说，cookie区分域，不区分端口，所以共享。(https和http协议不同也共享)")])])}),[],!1,null,null,null);s.default=r.exports}}]);