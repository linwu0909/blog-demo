(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{297:function(s,a,t){"use strict";t.r(a);var e=t(14),r=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#node"}},[s._v("Node")]),a("ul",[a("li",[a("a",{attrs:{href:"#_1-node引入模块的过程是什么-来自深入浅出nodejs"}},[s._v("1.node引入模块的过程是什么？(来自深入浅出nodejs)")])]),a("li",[a("a",{attrs:{href:"#_2-nodejs有哪些全局对象"}},[s._v("2.nodejs有哪些全局对象？")])]),a("li",[a("a",{attrs:{href:"#_3-process常用方法"}},[s._v("3.process常用方法？")])]),a("li",[a("a",{attrs:{href:"#_4-nodejs的事件循环"}},[s._v("4.nodejs的事件循环?")])]),a("li",[a("a",{attrs:{href:"#_5-有使用过buffer吗"}},[s._v("5.有使用过buffer吗?")])]),a("li",[a("a",{attrs:{href:"#_6-nodejs同步和异步怎么理解"}},[s._v("6.nodejs同步和异步怎么理解？")])]),a("li",[a("a",{attrs:{href:"#_7-如何防止程序奔溃"}},[s._v("7.如何防止程序奔溃？")])]),a("li",[a("a",{attrs:{href:"#_8-怎么调试nodejs"}},[s._v("8.怎么调试nodejs？")])]),a("li",[a("a",{attrs:{href:"#_9-node网络模块有哪些"}},[s._v("9.node网络模块有哪些?")])]),a("li",[a("a",{attrs:{href:"#_10-npm作用"}},[s._v("10.npm作用？")])]),a("li",[a("a",{attrs:{href:"#_11-nodejs导入模块和导入js文件有什么区别"}},[s._v("11.nodejs导入模块和导入js文件有什么区别?")])]),a("li",[a("a",{attrs:{href:"#_12-有使用过stream流吗"}},[s._v("12.有使用过stream流吗?")])]),a("li",[a("a",{attrs:{href:"#_13-fs模块常用"}},[s._v("13.fs模块常用?")])]),a("li",[a("a",{attrs:{href:"#_14-nodejs优缺点"}},[s._v("14.nodejs优缺点？")])]),a("li",[a("a",{attrs:{href:"#_15-nodejs模块加载和使用规则是什么-》cjs"}},[s._v("15.nodejs模块加载和使用规则是什么？=》cjs")])]),a("li",[a("a",{attrs:{href:"#_16-常见npm命令"}},[s._v("16.常见npm命令？")])]),a("li",[a("a",{attrs:{href:"#_17-什么是前后端分离"}},[s._v("17.什么是前后端分离？")])]),a("li",[a("a",{attrs:{href:"#_18-v8垃圾回收机制-v8限制64位机器内存最大约1-4g-32机器0-7g。node-v14版本的内存为2g-v8自身是用c-》完整"}},[s._v("18.v8垃圾回收机制(v8限制64位机器内存最大约1.4G,32机器0.7G。node v14版本的内存为2G，V8自身是用C++)=》完整")])]),a("li",[a("a",{attrs:{href:"#内存分配机制"}},[s._v("内存分配机制？")])]),a("li",[a("a",{attrs:{href:"#_19-express和koa区别"}},[s._v("19.express和koa区别？")])]),a("li",[a("a",{attrs:{href:"#_20-ts和js区别及优缺点"}},[s._v("20.ts和js区别及优缺点？")])]),a("li",[a("a",{attrs:{href:"#_21-node是单线程单进程如何高效利用多核cpu"}},[s._v("21.node是单线程单进程如何高效利用多核CPU？")])]),a("li",[a("a",{attrs:{href:"#_22-什么是ipc"}},[s._v("22.什么是IPC？")])]),a("li",[a("a",{attrs:{href:"#_23-大文件上传和断点续传如何实现"}},[s._v("23.大文件上传和断点续传如何实现？")])]),a("li",[a("a",{attrs:{href:"#_24-ts中const和readonly区别"}},[s._v("24.ts中const和readonly区别？")])]),a("li",[a("a",{attrs:{href:"#_25-ts中的this和js中的this有什么区别"}},[s._v("25.ts中的this和js中的this有什么区别？")])]),a("li",[a("a",{attrs:{href:"#_26-nodejs和js区别是什么"}},[s._v("26.nodejs和js区别是什么？")])]),a("li",[a("a",{attrs:{href:"#_27-npm-i与npm-ci的区别是什么"}},[s._v("27.npm i与npm ci的区别是什么？")])]),a("li",[a("a",{attrs:{href:"#_28-node中循环引用会发生什么"}},[s._v("28.node中循环引用会发生什么？")])]),a("li",[a("a",{attrs:{href:"#_29-v8如何执行js代码"}},[s._v("29.v8如何执行js代码？")])]),a("li",[a("a",{attrs:{href:"#_30-node中如何读取可读流的内容"}},[s._v("30.node中如何读取可读流的内容？")])]),a("li",[a("a",{attrs:{href:"#_31-如何读取大文件内容"}},[s._v("31.如何读取大文件内容？")])]),a("li",[a("a",{attrs:{href:"#_32-如何查看文件状态-文件最后修改时间"}},[s._v("32.如何查看文件状态/文件最后修改时间？")])]),a("li",[a("a",{attrs:{href:"#_33-说说对bff"}},[s._v("33.说说对BFF？")])]),a("li",[a("a",{attrs:{href:"#_34-koa-router实现原理"}},[s._v("34.koa-router实现原理？")])]),a("li",[a("a",{attrs:{href:"#_35-node如何调用c"}},[s._v("35.node如何调用c++？")])]),a("li",[a("a",{attrs:{href:"#_36-什么是中间件-举例"}},[s._v("36.什么是中间件-举例？")])]),a("li",[a("a",{attrs:{href:"#_37-fs-extra有使用过吗"}},[s._v("37.fs-extra有使用过吗？")])]),a("li",[a("a",{attrs:{href:"#_38-如何监控文件的变动"}},[s._v("38.如何监控文件的变动？")])]),a("li",[a("a",{attrs:{href:"#_39-node-max-old-space-size-4096什么意思"}},[s._v("39.node --max-old-space-size=4096什么意思？")])])])])])]),a("p"),s._v(" "),a("h2",{attrs:{id:"node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[s._v("#")]),s._v(" Node")]),s._v(" "),a("h3",{attrs:{id:"_1-node引入模块的过程是什么-来自深入浅出nodejs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-node引入模块的过程是什么-来自深入浅出nodejs"}},[s._v("#")]),s._v(" 1.node引入模块的过程是什么？(来自深入浅出nodejs)")]),s._v(" "),a("p",[s._v("路径分析(分析是node的核心模块，如http，还是文件路径或者是第三方依赖)\n->文件定位(后缀优先级js>json>node)\n->编译执行")]),s._v(" "),a("ul",[a("li",[s._v("node会对引入过的模块进行缓存，缓存的是编译执行后的对象。从缓存加载不需要这三步。")]),s._v(" "),a("li",[s._v("node模块分为两类：node提供的核心模块，用户编写的文件模块。")]),s._v(" "),a("li",[s._v("核心模块加载速度比文件模块快(因为有部分模块在node进程启动时就被直接加载进内存，这部分文件不需要再进行文件定位和编译执行)。")])]),s._v(" "),a("h3",{attrs:{id:"_2-nodejs有哪些全局对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-nodejs有哪些全局对象"}},[s._v("#")]),s._v(" 2.nodejs有哪些全局对象？")]),s._v(" "),a("p",[s._v("global,process,console,module,export")]),s._v(" "),a("h3",{attrs:{id:"_3-process常用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-process常用方法"}},[s._v("#")]),s._v(" 3.process常用方法？")]),s._v(" "),a("p",[s._v("process.env process.argv process.exit")]),s._v(" "),a("h3",{attrs:{id:"_4-nodejs的事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-nodejs的事件循环"}},[s._v("#")]),s._v(" 4.nodejs的事件循环?")]),s._v(" "),a("p",[s._v("(执行中是IO事件，setImmediate在当前队列中立即执行，setTimeout/setInterval把执行定时到下一个队列\nprocess.nextTick在当前队列执行完,下次遍历前执行)")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("顺序：IO事件->setImmediate->setTimeout/setInterval->process.nextTick")])]),s._v(" "),a("li",[a("p",[s._v("总共是6个阶段，")])]),s._v(" "),a("li",[a("p",[s._v("从poll开始，这个阶段会检查是否有io事件，执行io相关回调")])]),s._v(" "),a("li",[a("p",[s._v("到check阶段，这个阶段会执行setImediate的回调")])]),s._v(" "),a("li",[a("p",[s._v("到close callback 这个阶段执行关闭的回调函数")])]),s._v(" "),a("li",[a("p",[s._v("到timer 这个阶段会执行setTimeout和setInterval的回调")])]),s._v(" "),a("li",[a("p",[s._v("到pending callback这个阶段执行之前延迟的回调")])]),s._v(" "),a("li",[a("p",[s._v("到idle,prepare阶段，这个是node系统内部使用的")])]),s._v(" "),a("li",[a("p",[s._v("回到poll开始新的循环。算是一次Tick")])]),s._v(" "),a("li",[a("p",[s._v("setTimeout/setInterval 属于定时器阶段(timer) poll控制timer何时执行")])]),s._v(" "),a("li",[a("p",[s._v("setImmediate属于check阶段")])]),s._v(" "),a("li",[a("p",[s._v("nextTick会优先setImmediate和setTimeout")])]),s._v(" "),a("li",[a("p",[s._v("timer(定时器)：执行setTimeout和setInterval的回调\n=>pending callback(待定的回调)\n=>idle,prepare(仅系统内部使用)\n=>poll(轮询)：检查新的io事件，执行与IO相关的回调\n=>check(检测) 执行setImmediate的回调\n=>close callback(关闭的回调函数) 关闭的回调函数\n(微任务会在每个阶段执行完立即执行)")])])]),s._v(" "),a("h3",{attrs:{id:"_5-有使用过buffer吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-有使用过buffer吗"}},[s._v("#")]),s._v(" 5.有使用过buffer吗?")]),s._v(" "),a("p",[s._v("buffer主要处理二进制数据，在文件上传有用到。=》支持for...of\n(引入typedArray之前，js没有读取获操作二进制数据的机制，typeArray用来实现Uint8Array=》8位无符号整型数组，typedArray是统称)\nbuffer实例类似整型数组，但buffer的大小是固定的无法改变(V8堆外分配内存)，全局变量不需要require")]),s._v(" "),a("h4",{attrs:{id:"常用api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用api"}},[s._v("#")]),s._v(" 常用api")]),s._v(" "),a("ul",[a("li",[s._v("Buffer.concat(list,[length])返回一个合并了list中所有buffer的新buffer")]),s._v(" "),a("li",[s._v("Buffer.from(array)使用数组创建buffer")]),s._v(" "),a("li",[s._v("Buffer.alloc(size)创建一个buffer空间")]),s._v(" "),a("li",[s._v("Buffer.isBuffer(obj)判断是否是buffer")])]),s._v(" "),a("h3",{attrs:{id:"_6-nodejs同步和异步怎么理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-nodejs同步和异步怎么理解"}},[s._v("#")]),s._v(" 6.nodejs同步和异步怎么理解？")]),s._v(" "),a("ul",[a("li",[s._v("同步会阻塞IO，所以一般只在项目启动时使用，用来加载配置文件，初始化各种中间件。")]),s._v(" "),a("li",[s._v("异步是通过一次次循环事件队列来实现")])]),s._v(" "),a("h3",{attrs:{id:"_7-如何防止程序奔溃"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何防止程序奔溃"}},[s._v("#")]),s._v(" 7.如何防止程序奔溃？")]),s._v(" "),a("p",[s._v("通过try catch捕获异常(可以设置一个全局异常处理器，捕获程序抛出的异常,捕获到把异常打印到控制台)")]),s._v(" "),a("h3",{attrs:{id:"_8-怎么调试nodejs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-怎么调试nodejs"}},[s._v("#")]),s._v(" 8.怎么调试nodejs？")]),s._v(" "),a("p",[s._v("node-- debug 文件名")]),s._v(" "),a("h3",{attrs:{id:"_9-node网络模块有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-node网络模块有哪些"}},[s._v("#")]),s._v(" 9.node网络模块有哪些?")]),s._v(" "),a("p",[s._v("常用HTTP")]),s._v(" "),a("h3",{attrs:{id:"_10-npm作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-npm作用"}},[s._v("#")]),s._v(" 10.npm作用？")]),s._v(" "),a("p",[s._v("是包管理器，可以管理项目的依赖及依赖版本号")]),s._v(" "),a("h3",{attrs:{id:"_11-nodejs导入模块和导入js文件有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-nodejs导入模块和导入js文件有什么区别"}},[s._v("#")]),s._v(" 11.nodejs导入模块和导入js文件有什么区别?")]),s._v(" "),a("p",[s._v("导入模块按名称导入，导入文件按路径导入")]),s._v(" "),a("h3",{attrs:{id:"_12-有使用过stream流吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-有使用过stream流吗"}},[s._v("#")]),s._v(" 12.有使用过stream流吗?")]),s._v(" "),a("p",[s._v("主要用在读写文件。=》流可读，可写，或者可读可写\n=》fs.createReadStream('a.txt') fs.createWriteStream('a.txt')")]),s._v(" "),a("h4",{attrs:{id:"buffer和stream之间如何转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#buffer和stream之间如何转换"}},[s._v("#")]),s._v(" buffer和stream之间如何转换？")]),s._v(" "),a("p",[s._v("=》stream to buffer\n通过stream.on(data, data=>buffer.push(data))把每个buffer插入buffers数组，然后再通过buffer.concat把这些buffer组合到一起\n=》buffer to stream\n可以通过duplex(可读可写流)把缓存push到stream中\nlet stream = new Duplex() stream.push(buffer)")]),s._v(" "),a("h4",{attrs:{id:"buffer和stream区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#buffer和stream区别"}},[s._v("#")]),s._v(" buffer和stream区别？")]),s._v(" "),a("p",[s._v("buffer是取完数据一次性操作，stream是边取边操作")]),s._v(" "),a("h3",{attrs:{id:"_13-fs模块常用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-fs模块常用"}},[s._v("#")]),s._v(" 13.fs模块常用?")]),s._v(" "),a("ul",[a("li",[s._v("文件流 fs.createReadStream('a.txt') fs.createWriteStream('a.txt')")]),s._v(" "),a("li",[s._v("同步文件读写 fs.readFileSync() fs.writeFileSync()")]),s._v(" "),a("li",[s._v("异步文件读写 fs.readFile() fs.writeFile()")])]),s._v(" "),a("h3",{attrs:{id:"_14-nodejs优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-nodejs优缺点"}},[s._v("#")]),s._v(" 14.nodejs优缺点？")]),s._v(" "),a("ul",[a("li",[s._v("非阻塞IO，适合IO密集型的场景(CPU密集型给node主要挑战是：如果有长时间的计算将导致CPU时间片不能释放，使后续IO无法发起。IO阻塞的性能浪费远比CPU小)")]),s._v(" "),a("li",[s._v("单进程，单线程。不用担心锁和线程同步的问题(js部分是单线程，但是底层IO操作用到了libuv，这块不是单线程)\n(缺点：一旦一个地方崩溃，整个系统都崩溃)\n*node跨平台是通过libuv库，事件循环也是这个库实现的")])]),s._v(" "),a("h3",{attrs:{id:"_15-nodejs模块加载和使用规则是什么-》cjs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-nodejs模块加载和使用规则是什么-》cjs"}},[s._v("#")]),s._v(" 15.nodejs模块加载和使用规则是什么？=》cjs")]),s._v(" "),a("ul",[a("li",[s._v("遵循commonjs规范，使用require加载文件 使用exports/module.export导出文件 =》cjs不能直接在浏览器使用")]),s._v(" "),a("li",[s._v("commonjs主要为nodejs设计，早期浏览器使用的规范是amd=》commonjs是同步的，amd是异步的")]),s._v(" "),a("li",[s._v("amd代表库是require.js,早期commonjs代表库是sea.js，由淘宝玉伯开发\n=》现在统一为nodejs遵循commonjs规范，浏览器遵循esm规范(es6才有的)")])]),s._v(" "),a("h4",{attrs:{id:"exports和module-export区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exports和module-export区别"}},[s._v("#")]),s._v(" exports和module.export区别")]),s._v(" "),a("p",[s._v("本质无区别,最终暴露的都是module.export。但不能直接对exports赋值，没有任何效果")]),s._v(" "),a("h4",{attrs:{id:"amd和cmd区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#amd和cmd区别"}},[s._v("#")]),s._v(" amd和cmd区别")]),s._v(" "),a("ul",[a("li",[s._v("amd加载完模块会立马执行。cmd加载完没有立即执行，等遇到require才执行。")]),s._v(" "),a("li",[s._v("amd是异步引入模块，cmd是同步引入模块")])]),s._v(" "),a("h4",{attrs:{id:"umd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#umd"}},[s._v("#")]),s._v(" umd")]),s._v(" "),a("ul",[a("li",[s._v("umd兼容cjs和esm=》以amd为基础，加了特殊处理去兼容cjs")]),s._v(" "),a("li",[s._v("umd和esm前后端通用")])]),s._v(" "),a("h4",{attrs:{id:"cjs-commonjs-和esm-es-module-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cjs-commonjs-和esm-es-module-区别"}},[s._v("#")]),s._v(" cjs(commonjs)和esm(es module)区别？")]),s._v(" "),a("ul",[a("li",[s._v("cjs是module.export导出，require导入，esm是export导出，import")]),s._v(" "),a("li",[s._v("cjs是动态导入，esm是静态导入支持tree shaking")]),s._v(" "),a("li",[s._v("cjs是被加载时运行，esm是编译时候运行。")]),s._v(" "),a("li",[s._v("cjs输出的是值的浅拷贝，esm输出值的引用((输出值拷贝，输出后改变值，输出值不变。输出值引用会变)")]),s._v(" "),a("li",[s._v("cjs会缓存，第一次被加载会完整运行整个文件并输出一个对象，拷贝在内存中，下次加载文件，直接去内存中取")])]),s._v(" "),a("h3",{attrs:{id:"_16-常见npm命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-常见npm命令"}},[s._v("#")]),s._v(" 16.常见npm命令？")]),s._v(" "),a("p",[s._v("npm install | npm uninstall | npm init | npm config set")]),s._v(" "),a("h3",{attrs:{id:"_17-什么是前后端分离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-什么是前后端分离"}},[s._v("#")]),s._v(" 17.什么是前后端分离？")]),s._v(" "),a("p",[s._v("前端通过ajax调用后端提供的接口进行数据交互")]),s._v(" "),a("h3",{attrs:{id:"_18-v8垃圾回收机制-v8限制64位机器内存最大约1-4g-32机器0-7g。node-v14版本的内存为2g-v8自身是用c-》完整"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-v8垃圾回收机制-v8限制64位机器内存最大约1-4g-32机器0-7g。node-v14版本的内存为2g-v8自身是用c-》完整"}},[s._v("#")]),s._v(" 18.v8垃圾回收机制(v8限制64位机器内存最大约1.4G,32机器0.7G。node v14版本的内存为2G，V8自身是用C++)=》完整")]),s._v(" "),a("p",[s._v("(64位新生代空间64M,老生代1400MB 32位新生代空间32M,老生代700M)")]),s._v(" "),a("ul",[a("li",[s._v("实际应用中，对象生命周期长短不一，不同算法只能针对特定情况具有最好的效果，所以V8采用分代式垃圾回收。")]),s._v(" "),a("li",[s._v("分代式垃圾回收机制，将内存区分成老年代和新生代。(新生代内存占用小可以用复制的方式，老生代内存占用大不能用)")]),s._v(" "),a("li",[s._v("新生代中存放的是生存时间短的对象，老生代中存放的是生存时间长的对象。")]),s._v(" "),a("li",[s._v("新生代回收使用scavenge算法(牺牲空间换时间，具体实现采用了cheney算法):通过将存活对象在两个semiSpace空间中复制来实现垃圾回收。")]),s._v(" "),a("li",[s._v("cheney算法：它将堆内存一分为二，每个部分称为semiSpace，只有一个在使用中，使用中的是from，空闲的是to空间。")]),s._v(" "),a("li",[s._v("分配对象会在from空间进行分配，回收会检查from存活的对象，非存活对象会被释放，存活对象会复制到to空间，然后清空from空间，最后from，to交换\n=》拷贝和交换from，to空间主要是为了让内存空间保持连续")]),s._v(" "),a("li",[s._v("scavenge算法缺点是只能使用堆内存的一半，由划分空间和复制机制决定的。但因为它只复制存活的对象，而对于生命周期短的场景来说存活对象只占少部分，所以由时间效率上的优势。")]),s._v(" "),a("li",[s._v("新生代中的对象生命周期较短所以适用scavenge算法。\n(scavenge算法有很大的空间开销。所以老生代不适合，会浪费大量内存)")])]),s._v(" "),a("h4",{attrs:{id:"一开始都在新生代中-达到对象晋升条件后晋升为老生代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一开始都在新生代中-达到对象晋升条件后晋升为老生代"}},[s._v("#")]),s._v(" 一开始都在新生代中，达到对象晋升条件后晋升为老生代")]),s._v(" "),a("ol",[a("li",[s._v("对象经历过一次Scavenge回收")]),s._v(" "),a("li",[s._v("To空间已经使用超过25%(To空间对象会很快移动到老年代，防止新生代的空间被耗尽)")])]),s._v(" "),a("h4",{attrs:{id:"为什么是25"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么是25"}},[s._v("#")]),s._v(" 为什么是25%？")]),s._v(" "),a("p",[s._v("当这次scavenge回收完成后，会发生角色交换，如果占比过高，会影响后续的内存分配")]),s._v(" "),a("h4",{attrs:{id:"老年代使用什么算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#老年代使用什么算法"}},[s._v("#")]),s._v(" 老年代使用什么算法？")]),s._v(" "),a("p",[s._v("老年代回收使用标记清除+标记整理算法\n对老年代进行一次扫描，标记存活的对象，进行第二次扫描，清除未被标记的对象\n将存活对象往内存的一端移动(整理)，清除掉存活对象外的内存")]),s._v(" "),a("h4",{attrs:{id:"老生代为什么还要用标记整理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#老生代为什么还要用标记整理"}},[s._v("#")]),s._v(" 老生代为什么还要用标记整理？")]),s._v(" "),a("p",[s._v("因为进行一次清除后，内存空间会出现不连续的情况(会对后续内存分配造成影响)。所以需要整理碎片空间(使内存空间变得连续)")]),s._v(" "),a("h4",{attrs:{id:"全停顿问题-全停顿影响性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全停顿问题-全停顿影响性能"}},[s._v("#")]),s._v(" 全停顿问题(全停顿影响性能)")]),s._v(" "),a("p",[s._v("垃圾回收时需要将应用逻辑先暂停下来，等执行完垃圾回收再继续执行应用逻辑，这就是全停顿，对新生代影响较小，但对老生代影响大。\n老生代引入增量标记，将标记阶段分成若干个步骤，每运行一段时间就让程序执行一会，再进行标记(主线程停顿进行垃圾回收然后继续执行主线程然后再垃圾回收)")]),s._v(" "),a("h4",{attrs:{id:"三色标记法-黑白灰"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三色标记法-黑白灰"}},[s._v("#")]),s._v(" 三色标记法(黑白灰)：")]),s._v(" "),a("p",[s._v("黑色表示被GC ROOT引用，而且子节点已经标记完成\n灰色表示被GC ROOT引用，但是子节点还没被处理\n白色表示这个节点没有被访问到，如果本轮垃圾回收结束，节点还是白色，说明是垃圾数据，对应内存会被回收\n增量回收是并发进行的，增量回收条件：\n不能让黑色节点指向白色节点。\n通常使用写屏障(Write-barrier)机制来实现这个约束条件：\n当发生了黑色节点引用了白色节点的情况，写屏障会强制将被引用的白色节点变成灰色，这种方法也被称为强三色不变性")]),s._v(" "),a("h4",{attrs:{id:"对象如何释放"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象如何释放"}},[s._v("#")]),s._v(" 对象如何释放？")]),s._v(" "),a("p",[s._v("可达性算法。将GC ROOT对象作为起始点，向下搜索，搜索经过的路径称为引用链。当对象到起始点没有任何引用链就是不可用。\n即使不可达的对象，也不是立即释放，会先进行标记，然后进行筛选，会被放进一个队列中依次进行回收\n如果又有对象引用，就不会被回收。如果一个新生代对象经过多次复制后还存活，会晋升到老年代\n对象From空间复制到To空间，如果To空间超过25%，也会直接晋升到老年代\n(新生代用全停顿问题不大，因为新生代垃圾回收速度快)")]),s._v(" "),a("h3",{attrs:{id:"内存分配机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存分配机制"}},[s._v("#")]),s._v(" 内存分配机制？")]),s._v(" "),a("ol",[a("li",[s._v("分配你需要的内存")]),s._v(" "),a("li",[s._v("使用分配到的内存读/写")]),s._v(" "),a("li",[s._v("不需要的时候释放")]),s._v(" "),a("li",[s._v("(C语言可以通过代码手动分配和手动释放，即手动垃圾回收。这两个java和js都默认处理，即自动垃圾回收)")])]),s._v(" "),a("h3",{attrs:{id:"_19-express和koa区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-express和koa区别"}},[s._v("#")]),s._v(" 19.express和koa区别？")]),s._v(" "),a("ul",[a("li",[s._v("express内置了许多中间件。koa没有")]),s._v(" "),a("li",[s._v("express包含路由，视图渲染等特性，koa只有http模块")]),s._v(" "),a("li",[s._v("express主要通过回调实现异步函数，koa主要通过async，await的方式来处理异步")])]),s._v(" "),a("h3",{attrs:{id:"_20-ts和js区别及优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-ts和js区别及优缺点"}},[s._v("#")]),s._v(" 20.ts和js区别及优缺点？")]),s._v(" "),a("ul",[a("li",[s._v("ts是js的超集，有js的所有功能")])]),s._v(" "),a("h4",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[s._v("#")]),s._v(" 缺点")]),s._v(" "),a("p",[s._v("ts需要编译成js才能被浏览器执行，声明类型麻烦")]),s._v(" "),a("h4",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[s._v("#")]),s._v(" 优点")]),s._v(" "),a("ul",[a("li",[s._v("ts在编译期就进行类型检查，js在程序运行时才进行类型检查")]),s._v(" "),a("li",[s._v("ts可以自动进行类型推导")]),s._v(" "),a("li",[s._v("(ts是静态类型，js是动态类型)")])]),s._v(" "),a("h3",{attrs:{id:"_21-node是单线程单进程如何高效利用多核cpu"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-node是单线程单进程如何高效利用多核cpu"}},[s._v("#")]),s._v(" 21.node是单线程单进程如何高效利用多核CPU？")]),s._v(" "),a("p",[s._v("node提供了child_process，通过启动多进程的方式来高效利用")]),s._v(" "),a("h3",{attrs:{id:"_22-什么是ipc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-什么是ipc"}},[s._v("#")]),s._v(" 22.什么是IPC？")]),s._v(" "),a("p",[s._v("IPC指InterProcess Communication,即进程间通信")]),s._v(" "),a("h3",{attrs:{id:"_23-大文件上传和断点续传如何实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-大文件上传和断点续传如何实现"}},[s._v("#")]),s._v(" 23.大文件上传和断点续传如何实现？")]),s._v(" "),a("ul",[a("li",[s._v("前端：核心是利用Blob.prototype.slice来返回文件的切片，再并发上传切片。")]),s._v(" "),a("li",[s._v("后端：按标识合并切片=》通过读写流(readStream/writeStream)将切片写入最终文件")])]),s._v(" "),a("h4",{attrs:{id:"流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[s._v("#")]),s._v(" 流程")]),s._v(" "),a("ol",[a("li",[s._v("按设置的切片大小对文件进行切片(返回的是个数组，每个切片都带有索引，因为并发上传的切片可能会打乱切片顺序)=>文件内容和切片下标生成hash")]),s._v(" "),a("li",[s._v("通过Promise.all并发上传所有切片=>后端通过multiparty来处理前端的formData")]),s._v(" "),a("li",[s._v("再发送一次请求通知后端合并切片")]),s._v(" "),a("li",[s._v("进度条通过upload的onprogress监听进度=>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度\n断点续传：后端保存已上传的切片hash，前端上传时后端会校验该切片是否已上传，已上传的切片就不再上传")])]),s._v(" "),a("h3",{attrs:{id:"_24-ts中const和readonly区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-ts中const和readonly区别"}},[s._v("#")]),s._v(" 24.ts中const和readonly区别？")]),s._v(" "),a("p",[s._v("1.const是静态常量(不能同时和static使用)，由类型访问\nreadonly是动态常量，由实例访问\n2.const必须在字段声明时初始化，readonly非必须")]),s._v(" "),a("h3",{attrs:{id:"_25-ts中的this和js中的this有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-ts中的this和js中的this有什么区别"}},[s._v("#")]),s._v(" 25.ts中的this和js中的this有什么区别？")]),s._v(" "),a("p",[s._v("// TODO")]),s._v(" "),a("h3",{attrs:{id:"_26-nodejs和js区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-nodejs和js区别是什么"}},[s._v("#")]),s._v(" 26.nodejs和js区别是什么？")]),s._v(" "),a("ul",[a("li",[s._v("nodejs是运行环境，js是语言(执行js可以在浏览器也可以在nodejs上。因为都内置了js引擎)")]),s._v(" "),a("li",[s._v("js在浏览器有dom，bom等浏览器相关对象,nodejs有文件系统，网络系统等")])]),s._v(" "),a("h3",{attrs:{id:"_27-npm-i与npm-ci的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_27-npm-i与npm-ci的区别是什么"}},[s._v("#")]),s._v(" 27.npm i与npm ci的区别是什么？")]),s._v(" "),a("ul",[a("li",[s._v("npm ci会删除node_modules文件夹")]),s._v(" "),a("li",[s._v("npm ci要求项目中必须有package-lock.json否则不起作用，npm i不要求")])]),s._v(" "),a("h3",{attrs:{id:"_28-node中循环引用会发生什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_28-node中循环引用会发生什么"}},[s._v("#")]),s._v(" 28.node中循环引用会发生什么？")]),s._v(" "),a("p",[s._v("在cjs中，遇到require时，会执行require模块中的代码，并缓存执行结果。下次再加载就会直接去取缓存结果，所以不会出现无限循环引用的情况")]),s._v(" "),a("h3",{attrs:{id:"_29-v8如何执行js代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_29-v8如何执行js代码"}},[s._v("#")]),s._v(" 29.v8如何执行js代码？")]),s._v(" "),a("p",[s._v("parser生成抽象语法树=>Ignition生成字节码(字节码不能直接在处理器上运行，需要解释器转成机器码)=>编译器TuiboFan来编译成机器码")]),s._v(" "),a("h4",{attrs:{id:"怎么知道v8版本号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么知道v8版本号"}},[s._v("#")]),s._v(" 怎么知道v8版本号？")]),s._v(" "),a("p",[s._v("console.log(process.versions)")]),s._v(" "),a("h3",{attrs:{id:"_30-node中如何读取可读流的内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_30-node中如何读取可读流的内容"}},[s._v("#")]),s._v(" 30.node中如何读取可读流的内容？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// 通过stream流\nlet data = "";\nstream.on("data", (chunk) => (data += chunk));\nstream.on("end", () => console.log(data));\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h3",{attrs:{id:"_31-如何读取大文件内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_31-如何读取大文件内容"}},[s._v("#")]),s._v(" 31.如何读取大文件内容？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('import { createReadStream } from "fs";\nconst stream = createReadStream("bigfile.json");\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h3",{attrs:{id:"_32-如何查看文件状态-文件最后修改时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_32-如何查看文件状态-文件最后修改时间"}},[s._v("#")]),s._v(" 32.如何查看文件状态/文件最后修改时间？")]),s._v(" "),a("p",[s._v("node stats")]),s._v(" "),a("h3",{attrs:{id:"_33-说说对bff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_33-说说对bff"}},[s._v("#")]),s._v(" 33.说说对BFF？")]),s._v(" "),a("ul",[a("li",[s._v("BFF层可以对前端的数据进行处理再给后端")]),s._v(" "),a("li",[s._v("优点：后端改动，只需改动BFF层，无需去改前端代码")])]),s._v(" "),a("h3",{attrs:{id:"_34-koa-router实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_34-koa-router实现原理"}},[s._v("#")]),s._v(" 34.koa-router实现原理？")]),s._v(" "),a("p",[s._v("正则匹配=》采用的是path-to-regexp库")]),s._v(" "),a("h3",{attrs:{id:"_35-node如何调用c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_35-node如何调用c"}},[s._v("#")]),s._v(" 35.node如何调用c++？")]),s._v(" "),a("p",[s._v("通过napi")]),s._v(" "),a("h3",{attrs:{id:"_36-什么是中间件-举例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_36-什么是中间件-举例"}},[s._v("#")]),s._v(" 36.什么是中间件-举例？")]),s._v(" "),a("p",[s._v("比如路由中间件，全局异常捕获中间件，权限中间件")]),s._v(" "),a("h3",{attrs:{id:"_37-fs-extra有使用过吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_37-fs-extra有使用过吗"}},[s._v("#")]),s._v(" 37.fs-extra有使用过吗？")]),s._v(" "),a("p",[s._v("是fs的扩展，继承了fs的所有方法，扩展了更多的功能，给fs的方法添加了promise的支持")]),s._v(" "),a("h3",{attrs:{id:"_38-如何监控文件的变动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_38-如何监控文件的变动"}},[s._v("#")]),s._v(" 38.如何监控文件的变动？")]),s._v(" "),a("p",[s._v("node有提供一个fs.watch")]),s._v(" "),a("h3",{attrs:{id:"_39-node-max-old-space-size-4096什么意思"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_39-node-max-old-space-size-4096什么意思"}},[s._v("#")]),s._v(" 39.node --max-old-space-size=4096什么意思？")]),s._v(" "),a("p",[s._v("最大内存4G")])])}),[],!1,null,null,null);a.default=r.exports}}]);