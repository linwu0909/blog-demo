(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{295:function(s,a,t){"use strict";t.r(a);var e=t(14),r=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#javascript"}},[s._v("JavaScript")]),a("ul",[a("li",[a("a",{attrs:{href:"#概念"}},[s._v("概念")])]),a("li",[a("a",{attrs:{href:"#_1-说一下闭包-闭包解决了什么问题"}},[s._v("1.说一下闭包/闭包解决了什么问题？")])]),a("li",[a("a",{attrs:{href:"#_2-如何解决回调地狱-3种方式"}},[s._v("2.如何解决回调地狱？(3种方式)")])]),a("li",[a("a",{attrs:{href:"#_3-说一下事件委托-冒泡"}},[s._v("3.说一下事件委托(冒泡)？")])]),a("li",[a("a",{attrs:{href:"#_4-说说深浅拷贝"}},[s._v("4.说说深浅拷贝？")])]),a("li",[a("a",{attrs:{href:"#_5-freeze函数"}},[s._v("5.freeze函数？")])]),a("li",[a("a",{attrs:{href:"#_6-暂时性死区"}},[s._v("6.暂时性死区？")])]),a("li",[a("a",{attrs:{href:"#_7-js的垃圾回收机制"}},[s._v("*7.js的垃圾回收机制？")])]),a("li",[a("a",{attrs:{href:"#_8-栈和堆的区别"}},[s._v("8.栈和堆的区别？")])]),a("li",[a("a",{attrs:{href:"#_9-让数组乱序-数组打乱"}},[s._v("9.让数组乱序/数组打乱？")])]),a("li",[a("a",{attrs:{href:"#_10-什么是数组扁平化-如何实现"}},[s._v("10.什么是数组扁平化？如何实现？")])]),a("li",[a("a",{attrs:{href:"#_11-js基本数据类型"}},[s._v("11.js基本数据类型？")])]),a("li",[a("a",{attrs:{href:"#_12-数组常用方法"}},[s._v("12.数组常用方法？")])]),a("li",[a("a",{attrs:{href:"#_13-js语言特性"}},[s._v("13.js语言特性？")])]),a("li",[a("a",{attrs:{href:"#_14-改变this指向-apply-bind-call"}},[s._v("14.改变this指向(apply,bind,call)？")])]),a("li",[a("a",{attrs:{href:"#_15-const定义的数据可以改变吗"}},[s._v("15.const定义的数据可以改变吗？")])]),a("li",[a("a",{attrs:{href:"#_16-异步加载的几种方式"}},[s._v("16.异步加载的几种方式？")])]),a("li",[a("a",{attrs:{href:"#_17-事件循环"}},[s._v("17.事件循环？")])]),a("li",[a("a",{attrs:{href:"#_18-如何原生实现instanceof"}},[s._v("*18.如何原生实现instanceof？")])]),a("li",[a("a",{attrs:{href:"#_19-什么是函数柯里化-bind方法就是"}},[s._v("19.什么是函数柯里化(bind方法就是)？")])]),a("li",[a("a",{attrs:{href:"#_20-null和undefined的区别"}},[s._v("20.Null和Undefined的区别？")])]),a("li",[a("a",{attrs:{href:"#_21-this关键字在不同环境下的指向"}},[s._v("21.this关键字在不同环境下的指向？")])]),a("li",[a("a",{attrs:{href:"#_22-原型和原型链-构造函数-原型-实例-原型"}},[s._v("22.原型和原型链(构造函数<==>原型 实例=>原型)")])]),a("li",[a("a",{attrs:{href:"#_23-js是单线程-单线程有什么好处"}},[s._v("23.js是单线程，单线程有什么好处？")])]),a("li",[a("a",{attrs:{href:"#_24-queryselector返回值是什么-queryselectorall呢"}},[s._v("24.querySelector返回值是什么?querySelectorAll呢？")])]),a("li",[a("a",{attrs:{href:"#_25-函数传参是引用吗-修改形参会影响实参"}},[s._v("25.函数传参是引用吗？修改形参会影响实参？")])]),a("li",[a("a",{attrs:{href:"#_26-如何判断变量是否是数组"}},[s._v("26.如何判断变量是否是数组")])]),a("li",[a("a",{attrs:{href:"#_27-如何把对象转成key-value的二维数组"}},[s._v("27.如何把对象转成key/value的二维数组")])]),a("li",[a("a",{attrs:{href:"#_28-说几种遍历数组的方法"}},[s._v("28.说几种遍历数组的方法")])]),a("li",[a("a",{attrs:{href:"#_29-js的执行过程"}},[s._v("29.js的执行过程")])]),a("li",[a("a",{attrs:{href:"#_30-一个超长字符串能存在栈内存中吗"}},[s._v("30.一个超长字符串能存在栈内存中吗？")])]),a("li",[a("a",{attrs:{href:"#_31-mouseover和mouseenter的区别"}},[s._v("31.mouseover和mouseenter的区别")])]),a("li",[a("a",{attrs:{href:"#_32-new一个对象发生了什么"}},[s._v("32.new一个对象发生了什么?")])]),a("li",[a("a",{attrs:{href:"#_33-和-有什么区别"}},[s._v("33.==和===有什么区别？")])]),a("li",[a("a",{attrs:{href:"#_34-实现一个同步的sleep函数"}},[s._v("34.实现一个同步的sleep函数")])]),a("li",[a("a",{attrs:{href:"#_35-字符串去重"}},[s._v("35.字符串去重")])]),a("li",[a("a",{attrs:{href:"#_36-怎么判断两个对象相等"}},[s._v("36.怎么判断两个对象相等")])]),a("li",[a("a",{attrs:{href:"#_37-如何生成100个元素为1的数组"}},[s._v("37.如何生成100个元素为1的数组？")])]),a("li",[a("a",{attrs:{href:"#_38-typeof和instanceof的区别"}},[s._v("38.typeof和instanceof的区别")])]),a("li",[a("a",{attrs:{href:"#_39-字符串翻转"}},[s._v("39.字符串翻转")])]),a("li",[a("a",{attrs:{href:"#_40-手写promise-race"}},[s._v("40.手写promise.race")])]),a("li",[a("a",{attrs:{href:"#_41-js数组哪些方法改变自身-哪些方法不改变"}},[s._v("41.js数组哪些方法改变自身，哪些方法不改变")])]),a("li",[a("a",{attrs:{href:"#_42-说说object-defineproperty"}},[s._v("42.说说Object.defineProperty")])]),a("li",[a("a",{attrs:{href:"#_43-如何全部替代一个子串为另一个"}},[s._v("43.如何全部替代一个子串为另一个")])]),a("li",[a("a",{attrs:{href:"#_44-0-1-0-2不等于0-3"}},[s._v("44.0.1+0.2不等于0.3？")])]),a("li",[a("a",{attrs:{href:"#_45-类数组转数组"}},[s._v("45.类数组转数组")])]),a("li",[a("a",{attrs:{href:"#_46"}},[s._v("46.")])]),a("li",[a("a",{attrs:{href:"#_47-js数组去重-原生js"}},[s._v("47.js数组去重(原生js)")])]),a("li",[a("a",{attrs:{href:"#_48-什么是作用域-什么是作用域链"}},[s._v("48.什么是作用域？什么是作用域链?")])]),a("li",[a("a",{attrs:{href:"#_49-定时器准时吗"}},[s._v("49.定时器准时吗")])]),a("li",[a("a",{attrs:{href:"#_50-promise-all错误处理"}},[s._v("50.promise.all错误处理")])]),a("li",[a("a",{attrs:{href:"#_51-异步编程的实现方式"}},[s._v("51.异步编程的实现方式")])]),a("li",[a("a",{attrs:{href:"#_52-js如何实现多线程"}},[s._v("52.js如何实现多线程")])]),a("li",[a("a",{attrs:{href:"#_53-js的执行机制"}},[s._v("53.js的执行机制？")])]),a("li",[a("a",{attrs:{href:"#_54-剪贴板相关操作"}},[s._v("54.剪贴板相关操作")])]),a("li",[a("a",{attrs:{href:"#_59-js中的数组特点"}},[s._v("59.js中的数组特点")])]),a("li",[a("a",{attrs:{href:"#_60-input事件和change事件区别"}},[s._v("60.input事件和change事件区别")])]),a("li",[a("a",{attrs:{href:"#_61-with作用"}},[s._v("61.with作用")])]),a("li",[a("a",{attrs:{href:"#_62-e-target和e-currenttarget区别"}},[s._v("62.e.target和e.currentTarget区别")])]),a("li",[a("a",{attrs:{href:"#_63-json相关"}},[s._v("63.json相关")])]),a("li",[a("a",{attrs:{href:"#_64-剩余参数和arguments对象区别是什么"}},[s._v("64.剩余参数和arguments对象区别是什么")])]),a("li",[a("a",{attrs:{href:"#_65-js有哪些代码规范"}},[s._v("65.*js有哪些代码规范")])])])])])]),a("p"),s._v(" "),a("h2",{attrs:{id:"javascript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[s._v("#")]),s._v(" JavaScript")]),s._v(" "),a("h3",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[s._v("#")]),s._v(" 概念")]),s._v(" "),a("ul",[a("li",[s._v("基础类型赋值只改变本身，引用类型赋值全部修改(栈内存中保存的地址指针指向的是堆内存中同一个位置)")]),s._v(" "),a("li",[s._v("微任务和宏任务都属于队列，栈中先执行完才会去执行队列")]),s._v(" "),a("li",[s._v("所有微任务总会在下一个宏任务之前全部执行完毕，直至微任务队列清空，过程中如果有微任务产生微任务会继续执行新的微任务")]),s._v(" "),a("li",[s._v("对象中数字属性名等于字符串属性名")]),s._v(" "),a("li",[s._v("alert弹出的数据都会转化成字符串")]),s._v(" "),a("li",[s._v("js是单线程，浏览器是多进程")]),s._v(" "),a("li",[s._v("JSON.stringify会过滤掉undefined，不会过滤掉null")]),s._v(" "),a("li",[s._v("JS中的数组可以作为栈或队列使用")])]),s._v(" "),a("h3",{attrs:{id:"_1-说一下闭包-闭包解决了什么问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-说一下闭包-闭包解决了什么问题"}},[s._v("#")]),s._v(" 1.说一下闭包/闭包解决了什么问题？")]),s._v(" "),a("p",[s._v("函数执行会形成私有上下文，这种保存私有变量的机制就是闭包。(闭包就是能够读取其他函数内部变量的函数)\n用来解决函数外部因作用域访问不到函数内部的问题。\n(即子函数在外部调用，子函数所在的父函数的作用域不会释放)\n函数作用域是独立的，封闭的。但是闭包是能够读取其他函数内部变量的一个函数。\n我们在函数中嵌套一个函数，里面的函数去访问外面函数的变量，被访问的变量会始终保存在内存中")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function init() {\n    var name = "Mozilla";\n    // name 是一个被 init 创建的局部变量\n    function displayName() {\n    // displayName() 是内部函数，一个闭包\n        alert(name); //使用了父函数中声明的变量\n    }\n    displayName();\n}\ninit();\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("不恰当使用闭包会造成内存泄漏(要把变量定义在函数内，而不是全局变量，这样程序执行完就会销毁变量)。\n防抖和节流都有用到闭包")]),s._v(" "),a("h4",{attrs:{id:"常见问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[s._v("#")]),s._v(" 常见问题")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("for (var i = 0; i < 6; i++) {\n    setTimeout(() => {\n    console.log(i) // 1s后输出6个6=>不能用const，用let是1s后输出0-5\n    }, 1000)\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h3",{attrs:{id:"_2-如何解决回调地狱-3种方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何解决回调地狱-3种方式"}},[s._v("#")]),s._v(" 2.如何解决回调地狱？(3种方式)")]),s._v(" "),a("p",[s._v("promise，async/await，generator")]),s._v(" "),a("h3",{attrs:{id:"_3-说一下事件委托-冒泡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-说一下事件委托-冒泡"}},[s._v("#")]),s._v(" 3.说一下事件委托(冒泡)？")]),s._v(" "),a("p",[s._v("不在元素上直接设置监听函数，而是在父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上的事件被触发。举例：ul，li监听。\n（ 子元素事件冒泡到父元素，需要父元素也有该事件）")]),s._v(" "),a("h4",{attrs:{id:"事件捕获和冒泡机制-以及事件委托"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件捕获和冒泡机制-以及事件委托"}},[s._v("#")]),s._v(" 事件捕获和冒泡机制，以及事件委托？")]),s._v(" "),a("ul",[a("li",[s._v("事件捕获(老版本浏览器不支持，用得较少)：从window接收，一级一级往下，最后是元素接收到事件=》从外到内")]),s._v(" "),a("li",[s._v("事件冒泡(IE)：从元素最先接收，一级一级往上，再由window接收=》从内到外")])]),s._v(" "),a("h4",{attrs:{id:"冒泡和捕获哪个先"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#冒泡和捕获哪个先"}},[s._v("#")]),s._v(" 冒泡和捕获哪个先？")]),s._v(" "),a("p",[s._v("先捕获后冒泡")]),s._v(" "),a("h4",{attrs:{id:"dom事件流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom事件流"}},[s._v("#")]),s._v(" dom事件流?")]),s._v(" "),a("p",[s._v("window->document->body->div->body->document->window\n事件流的典型应用就是事件委托。事件委托利用了事件冒泡，把事件加到父级上，就可以管理一类型的所有事件。\n(ul和li，把事件加到ul上，可以监控到li)")]),s._v(" "),a("ul",[a("li",[s._v("event.preventDefault()可以阻止默认事件但是允许冒泡事件")]),s._v(" "),a("li",[s._v("event.stopPropagation()可以阻止冒泡但是允许默认事件")])]),s._v(" "),a("h4",{attrs:{id:"浏览器的事件模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的事件模型"}},[s._v("#")]),s._v(" 浏览器的事件模型？")]),s._v(" "),a("p",[s._v("事件模型的过程主要分三个阶段：捕获阶段，目标阶段，冒泡阶段\naddEventListener(第三个参数如果是true，就代表在捕获阶段执行，否则在冒泡阶段执行=>对应useCapture:true)\n=>第三个参数也可以是个options")]),s._v(" "),a("h3",{attrs:{id:"_4-说说深浅拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-说说深浅拷贝"}},[s._v("#")]),s._v(" 4.说说深浅拷贝？")]),s._v(" "),a("ul",[a("li",[s._v("深浅拷贝区别是对于引用类型如object，array而言的。")]),s._v(" "),a("li",[s._v("深浅拷贝，基本类型的时候，改变都不会使原数据改变。")]),s._v(" "),a("li",[s._v("引用类型，浅拷贝改变会使原数据改变，深拷贝不会。\n(浅拷贝和赋值也有区别，赋值和原数据指向的是同一对象，浅拷贝不是)")]),s._v(" "),a("li",[s._v("因为引用类型，浅拷贝拷贝的是内存地址，深拷贝拷贝的是值，但是内存地址不同，所以不会。")]),s._v(" "),a("li",[s._v("浅拷贝实现是通过对对象各个属性依次进行拷贝，拷贝的是引用")])]),s._v(" "),a("h4",{attrs:{id:"浅拷贝方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝方式"}},[s._v("#")]),s._v(" 浅拷贝方式")]),s._v(" "),a("ol",[a("li",[s._v("Object.assign() =》当对象只有一层是深拷贝")]),s._v(" "),a("li",[s._v("es6的扩展运算法...")]),s._v(" "),a("li",[s._v("slice()\n// 通过对象序列化和字符串反序列化也可实现")])]),s._v(" "),a("h4",{attrs:{id:"深拷贝实现是通过递归的方式将值进行拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝实现是通过递归的方式将值进行拷贝"}},[s._v("#")]),s._v(" 深拷贝实现是通过递归的方式将值进行拷贝")]),s._v(" "),a("p",[s._v("深拷贝方式：")]),s._v(" "),a("ol",[a("li",[s._v("JSON.stringify() 函数，日期，正则在JSON.stringify时都会出现问题")]),s._v(" "),a("li",[s._v("遍历递归来拷贝(非原型属性)")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var arr = ['old', 1, true, ['old1', 'old2'], {old: 1}]\nvar new_arr = JSON.parse( JSON.stringify(arr) );\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("实现浅拷贝")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function clone(target) {\n    if (target === null) {\n        return null;\n    }\n    // 判断原来是数组还是对象\n    let cloneTarget = Array.isArray(target) ? [] : {}\n    for (const key in target) {\n        if (target.hasOwnProperty(key)) { // 判断是否存在该属性，不包括原型链\n            cloneTarget[key] = target[key]\n        }\n    }\n    return cloneTarget;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[s._v("实现深拷贝")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v(" function deepCopy(obj) {\n          var result = Array.isArray(obj) ? [] : {};\n          for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n              if (typeof obj[key] === 'object') {\n                result[key] = deepCopy(obj[key]);   //递归复制\n              } else {\n                result[key] = obj[key];\n              }\n            }\n          }\n          return result;\n        }\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("div",{staticClass:"language-深拷贝满足常见类型及循环引用 line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 利用 WeakMap 解决循环引用\nlet map = new WeakMap()\nfunction deepClone(obj) {\n  if (obj instanceof Object) {\n    if (map.has(obj)) {\n      return map.get(obj)\n    }\n    let newObj\n    if (obj instanceof Array) {\n      newObj = []\n    } else if (obj instanceof Function) {\n      newObj = function() {\n        return obj.apply(this, arguments)\n      }\n    } else if (obj instanceof RegExp) {\n      // 拼接正则\n      newobj = new RegExp(obj.source, obj.flags)\n    } else if (obj instanceof Date) {\n      newobj = new Date(obj)\n    } else {\n      newObj = {}\n    }\n    // 克隆一份对象出来\n    let desc = Object.getOwnPropertyDescriptors(obj)\n    let clone = Object.create(Object.getPrototypeOf(obj), desc)\n    map.set(obj, clone)\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        newObj[key] = deepClone(obj[key])\n      }\n    }\n    return newObj\n  }\n  return obj\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br")])]),a("h3",{attrs:{id:"_5-freeze函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-freeze函数"}},[s._v("#")]),s._v(" 5.freeze函数？")]),s._v(" "),a("p",[s._v("Object.freeze表示冻结该对象，被冻结的对象无法被修改(包括新增属性，删除属性，以及可枚举性，可配置性等)，但是允许访问。var a = Object.freeze({})")]),s._v(" "),a("h3",{attrs:{id:"_6-暂时性死区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-暂时性死区"}},[s._v("#")]),s._v(" 6.暂时性死区？")]),s._v(" "),a("p",[s._v("使用let，const声明变量之前，该变量都是不可用的。重复命名一个变量，在第二个命名之前变量都是不可用的。")]),s._v(" "),a("h3",{attrs:{id:"_7-js的垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-js的垃圾回收机制"}},[s._v("#")]),s._v(" *7.js的垃圾回收机制？")]),s._v(" "),a("ol",[a("li",[s._v("标记清除法")]),s._v(" "),a("li",[s._v("引用计数")])]),s._v(" "),a("p",[s._v("不自动回收变量：全局变量或闭包内引用的变量")]),s._v(" "),a("h3",{attrs:{id:"_8-栈和堆的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-栈和堆的区别"}},[s._v("#")]),s._v(" 8.栈和堆的区别？")]),s._v(" "),a("p",[s._v("let a = 20; 都存在栈中\nlet a = {m: 29} a存在栈中，{m:29}作为对象存在堆中，当我们要访问堆内存中的引用数据类型，首先要从栈中获取该对象的地址引用。")]),s._v(" "),a("ul",[a("li",[s._v("栈存储基础数据类型，堆存储引用类型")]),s._v(" "),a("li",[s._v("栈按值访问，堆按引用地址访问")]),s._v(" "),a("li",[s._v("栈存储的值大小固定，会自动分配空间，堆存储的值大小不固定，可动态调整")])]),s._v(" "),a("h4",{attrs:{id:"堆内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆内存"}},[s._v("#")]),s._v(" 堆内存？")]),s._v(" "),a("p",[s._v("不能直接访问和操作堆内存，只能操作对象在栈内存的引用地址，通过这个地址可以找到堆内存中的对象\n=>比如引用类型的赋值操作，是把原来对象的栈内存地址拷贝一份给新的对象，他们都指向同一个堆内存对象，所以成功给这个对象赋值")]),s._v(" "),a("h3",{attrs:{id:"_9-让数组乱序-数组打乱"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-让数组乱序-数组打乱"}},[s._v("#")]),s._v(" 9.让数组乱序/数组打乱？")]),s._v(" "),a("p",[s._v("_.shuffle([1, 2, 3, 4]);//需要通过第三方库lodash\n"),a("code",[s._v("function shuffle(arr) { return arr.sort(() => { return (Math.random() - 0.5); }); }")])]),s._v(" "),a("h3",{attrs:{id:"_10-什么是数组扁平化-如何实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-什么是数组扁平化-如何实现"}},[s._v("#")]),s._v(" 10.什么是数组扁平化？如何实现？")]),s._v(" "),a("p",[s._v("数组扁平化就是将一个多维数组转换为一个一维数组。")]),s._v(" "),a("ol",[a("li",[s._v("es6的flat arr.flat(Infinity) 数组才有的属性")]),s._v(" "),a("li",[s._v("转化成字符串 使用toString再用split变成以逗号分割的数组，再用map遍历转成数字返回\narr.toString().split(',').map(item=>parseFloat(item)")]),s._v(" "),a("li",[s._v("循环递归=>循环判断子元素是否存在数组，如果是就把所有元素展开放到一个空数组中再重新赋值，直到没有数组\nwhile(arr.some(item => Array.isArray(item)) {\narr = [].concat(...arr)\n}")])]),s._v(" "),a("h4",{attrs:{id:"flatmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flatmap"}},[s._v("#")]),s._v(" flatMap")]),s._v(" "),a("p",[s._v("会返回扁平化深度为1的数组，与flat区别就是参数传的是一个函数")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const arr1 = [1, 2, [3], [4, 5], 6, [7,8,9]];\nconsole.log(arr1.flatMap(num => num)); // [1,2,3,4,5,6,7,8,9]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h3",{attrs:{id:"_11-js基本数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-js基本数据类型"}},[s._v("#")]),s._v(" 11.js基本数据类型？")]),s._v(" "),a("ul",[a("li",[s._v("string,boolean,number,undefined,null,symbol(es6新增),(bigInt=>大于2^53 - 1的数，就是最大安全整数Number.MAX_SAFE_INTEGER)")]),s._v(" "),a("li",[s._v("引用数据类型：对象(Array,Math,Map,Set,RegExp)，函数")]),s._v(" "),a("li",[s._v("原始类型除了null都可以通过typeof判断，typeof null为object是久远的bug，想要判断通过xxx===null即可。")]),s._v(" "),a("li",[s._v("转数字规则：null为0，undefined为NaN，symbol报错，字符串非数字(或进制)转NaN。NaN不等于自身")]),s._v(" "),a("li",[s._v("typeof判断对象类型只能判断函数为function，其他都是object")]),s._v(" "),a("li",[s._v("NaN通过isNaN(123)来判断(NaN指的是not a number，number的范围是-2^53~2^53)")])]),s._v(" "),a("h4",{attrs:{id:"判断一个数是整数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断一个数是整数"}},[s._v("#")]),s._v(" 判断一个数是整数？")]),s._v(" "),a("ul",[a("li",[s._v("%1 判断是不是0")]),s._v(" "),a("li",[s._v("Number.isInteger()")])]),s._v(" "),a("h4",{attrs:{id:"_2-53次方怎么表示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-53次方怎么表示"}},[s._v("#")]),s._v(" 2^53次方怎么表示？")]),s._v(" "),a("ul",[a("li",[s._v("2 ** 53")]),s._v(" "),a("li",[s._v("Math.pow(2,53)")])]),s._v(" "),a("h4",{attrs:{id:"bigint怎么表示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bigint怎么表示"}},[s._v("#")]),s._v(" bigInt怎么表示？")]),s._v(" "),a("p",[s._v("整数后面加n即可")]),s._v(" "),a("h4",{attrs:{id:"isnan和number-isnan区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isnan和number-isnan区别"}},[s._v("#")]),s._v(" isNaN和Number.isNaN区别？")]),s._v(" "),a("p",[s._v("isNaN会把参数转成数值，不能转换的都会返回true\nNumber.isNaN会先判断是否是数字，是数字再判断是否是NaN，更准确")]),s._v(" "),a("h3",{attrs:{id:"_12-数组常用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-数组常用方法"}},[s._v("#")]),s._v(" 12.数组常用方法？")]),s._v(" "),a("p",[s._v("push(),pop(),shift(),unshift(),splice(),sort(),map()\n会改变数组的方法：push(),pop(),shift(),unshift(),splice(),reverse(),sort()")]),s._v(" "),a("h3",{attrs:{id:"_13-js语言特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-js语言特性"}},[s._v("#")]),s._v(" 13.js语言特性？")]),s._v(" "),a("p",[s._v("可以在浏览器运行\n不用预编译，直接解析执行代码")]),s._v(" "),a("h3",{attrs:{id:"_14-改变this指向-apply-bind-call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-改变this指向-apply-bind-call"}},[s._v("#")]),s._v(" 14.改变this指向(apply,bind,call)？")]),s._v(" "),a("p",[s._v("call，bind，apply都可以，箭头函数和proxy也可以改变=》proxy指向代理对象")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("fn.call(obj, 1,2) call接收一个参数列表\nfn.bind(obj,1,2)也是接收一个参数列表，但是返回的是一个函数\nfn.apply(obj,[1,2])apply接收的是一个参数数组\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h4",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("ul",[a("li",[s._v("call和bind都是接收一个参数列表，apply接收的是一个参数数组")]),s._v(" "),a("li",[s._v("bind返回的是一个函数，需要执行才生效")])]),s._v(" "),a("h3",{attrs:{id:"_15-const定义的数据可以改变吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-const定义的数据可以改变吗"}},[s._v("#")]),s._v(" 15.const定义的数据可以改变吗？")]),s._v(" "),a("ul",[a("li",[s._v("定义的是基本类型不可以改变，定义的是引用类型就可以改变，比如对象")]),s._v(" "),a("li",[s._v("const定义引用类型(对象，数组)，不能修改指针指向的地址，但可以修改地址指向的数据")])]),s._v(" "),a("h3",{attrs:{id:"_16-异步加载的几种方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-异步加载的几种方式"}},[s._v("#")]),s._v(" 16.异步加载的几种方式？")]),s._v(" "),a("ul",[a("li",[s._v("script的defer属性:defer属性规定是否对脚本执行进行延迟，直到页面加载为止。可以保证脚本按顺序执行(如果脚本不改变文档的内容，可以通过这种方式加快文档处理的速度，不是所有浏览器都支持)")]),s._v(" "),a("li",[s._v("script的async属性:async是h5新增特性，只适用外部引入的脚本，一旦脚本可用会异步执行。不能保证脚本按顺序执行，不是所有浏览器都支持")]),s._v(" "),a("li",[s._v("$(document).ready()。必须引入jquery")])]),s._v(" "),a("h4",{attrs:{id:"defer和async区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defer和async区别"}},[s._v("#")]),s._v(" defer和async区别？")]),s._v(" "),a("p",[s._v("js脚本分成加载、解析、执行几个步骤，脚本加载且执行会阻塞dom渲染(所以js一般放最后)\n相同点：都是异步加载\n不同点：")]),s._v(" "),a("ul",[a("li",[s._v("async加载完立即执行，可能会阻塞dom解析")]),s._v(" "),a("li",[s._v("defer加载后延迟到dom解析完才执行(在domContentLoaded之前)")])]),s._v(" "),a("h3",{attrs:{id:"_17-事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-事件循环"}},[s._v("#")]),s._v(" 17.事件循环？")]),s._v(" "),a("p",[s._v("(先执行一个宏任务=》)先执行整个代码块，过程中把宏任务和微任务分别放入各自的任务队列，等代码块执行完就立即执行微任务队列中所有的微任务，\n当所有微任务都执行完就开始下一次宏任务")]),s._v(" "),a("h4",{attrs:{id:"执行微任务过程中产生了微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行微任务过程中产生了微任务"}},[s._v("#")]),s._v(" 执行微任务过程中产生了微任务")]),s._v(" "),a("p",[s._v("同样会加到当前的微任务队列中，等微任务队列都清空了才开始下次宏任务")]),s._v(" "),a("h4",{attrs:{id:"为什么区分微任务和宏任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么区分微任务和宏任务"}},[s._v("#")]),s._v(" 为什么区分微任务和宏任务？")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("微任务是线程之间的切换，速度快，不用进行上下文切换，一次事件循环可以完成所有微任务。")])]),s._v(" "),a("li",[a("p",[s._v("宏任务是进程之间的切换，每次需要切换上下文，一次事件循环只能执行一个宏任务。")])]),s._v(" "),a("li",[a("p",[s._v("目的为了实现插队。")])]),s._v(" "),a("li",[a("p",[s._v("宏任务：js脚本，定时器，IO操作，ajax=》宏任务不一定都是异步任务，如js脚本")])]),s._v(" "),a("li",[a("p",[s._v("微任务：Promise.then,catch,finally,process.nextTick")])])]),s._v(" "),a("h4",{attrs:{id:"为什么微任务会比宏任务先执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么微任务会比宏任务先执行"}},[s._v("#")]),s._v(" 为什么微任务会比宏任务先执行？")]),s._v(" "),a("p",[s._v("因为当主线程代码执行完后，在事件循环执行之前，会尝试dom渲染，而微任务是在dom渲染之前执行，dom渲染完成后才执行宏任务。")]),s._v(" "),a("h3",{attrs:{id:"_18-如何原生实现instanceof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-如何原生实现instanceof"}},[s._v("#")]),s._v(" *18.如何原生实现instanceof？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function fakeInstanceOf (instance, parent) {\n    if (typeof instance !== "object" && typeof instance !== "function") return false;\n    while (instance.__proto__) {\n        if (instance.__proto__ === parent.prototype) {\n            return true;\n        }\n        instance.__proto__ = instance.__proto__.__proto__;\n    }\n    return false;\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("h3",{attrs:{id:"_19-什么是函数柯里化-bind方法就是"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-什么是函数柯里化-bind方法就是"}},[s._v("#")]),s._v(" 19.什么是函数柯里化(bind方法就是)？")]),s._v(" "),a("p",[s._v("函数柯里化实际是一种转换，返回的是一个函数。是将多变量函数拆解为单变量的多个函数。f(a,b,c)=>f(a)(b)(c) a,b,c各自都是一个函数内的变量")]),s._v(" "),a("h3",{attrs:{id:"_20-null和undefined的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-null和undefined的区别"}},[s._v("#")]),s._v(" 20.Null和Undefined的区别？")]),s._v(" "),a("ul",[a("li",[s._v("null表示定义了一个空值, 变量声明了没有赋值就是undefined")]),s._v(" "),a("li",[s._v("null参与计算等于0，undefined参与计算返回NaN(Number)")])]),s._v(" "),a("h3",{attrs:{id:"_21-this关键字在不同环境下的指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-this关键字在不同环境下的指向"}},[s._v("#")]),s._v(" 21.this关键字在不同环境下的指向？")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("this在浏览器指向window")])]),s._v(" "),a("li",[a("p",[s._v("普通函数中的this指向window")])]),s._v(" "),a("li",[a("p",[s._v("定时器的this指向window")])]),s._v(" "),a("li",[a("p",[s._v("箭头函数的this取决于外部环境")])]),s._v(" "),a("li",[a("p",[s._v("事件中的this指向事件的调用者")])]),s._v(" "),a("li",[a("p",[s._v("构造函数和原型对象中的this都是指向new出来的实例对象")])]),s._v(" "),a("li",[a("p",[s._v("类中的this指向构造器new出来的实例对象")])]),s._v(" "),a("li",[a("p",[s._v("谁触发函数，函数里的this就指向谁")])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("fun() // window.fun()里面的this指向window\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("ul",[a("li",[s._v("多层对象调用，函数被外层对象调用，指向的也是上一级对象")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var obj = {\n    method: {\n        fn: function() {\n            console.log(this)\n        }\n    }\n}\nobj.method.fn() // 指向method\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("ul",[a("li",[s._v("箭头函数调用，箭头函数本身没有this，实际调用的是上一级的this")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var obj = {\n    fun: ()=> {\n        console.log(this)\n    },\n    fun2: function() {\n        console.log(this)\n    }\n}\nobj.fun() // window\nobj.fun2() // obj\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("h3",{attrs:{id:"_22-原型和原型链-构造函数-原型-实例-原型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-原型和原型链-构造函数-原型-实例-原型"}},[s._v("#")]),s._v(" 22.原型和原型链(构造函数<==>原型 实例=>原型)")]),s._v(" "),a("ul",[a("li",[s._v("构造函数通过prototype指向原型")]),s._v(" "),a("li",[s._v("原型通过constructor指向构造函数")]),s._v(" "),a("li",[s._v("实例通过_proto_指向原型(原型上有一个_proto_属性，指向Object.prototype)")])]),s._v(" "),a("h4",{attrs:{id:"总结-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("构造函数通过prototype指向原型，原型通过constructor指向构造函数，原型(Parent.prototype)通过_proto_指向原型的原型(Object.prototype)")]),s._v(" "),a("h4",{attrs:{id:"原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[s._v("#")]),s._v(" 原型链")]),s._v(" "),a("ul",[a("li",[s._v("当访问一个实例对象的属性时，如果本身没有这个属性，就会去原型对象中查找，一直找到Object为止，原型间一层层的关系就构成了原型链。最终指向null")]),s._v(" "),a("li",[s._v("不是所有对象都有原型(通过对象创建的对象都有原型，空对象及Object.prototype(原型的最顶端)没有原型)")]),s._v(" "),a("li",[s._v("实例(p)=>原型(Parent.prototype)=>原型(Object.prototype)=>null  // 通过_proto_一层层往上找")])]),s._v(" "),a("h4",{attrs:{id:"object-create和原型链-mdn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-create和原型链-mdn"}},[s._v("#")]),s._v(" Object.create和原型链(MDN)")]),s._v(" "),a("ul",[a("li",[s._v("object.create(proto)是创建一个新对象，使用现有的对象来作为新创建对象的原型(prototype)")]),s._v(" "),a("li",[s._v("每个对象拥有一个原型对象。对象以原型为模版，继承了方法和属性。原型对象可能也有原型，一层一层以此类推，就构成了原型链")]),s._v(" "),a("li",[s._v("这些属性和方法定义在构造函数的prototype中，而不是对象实例本身")]),s._v(" "),a("li",[s._v("js通过在对象实例和构造器之间建立一个链接_proto_在构造器中找到这些属性和方法")]),s._v(" "),a("li",[s._v("每个实例对象都从原型中继承了一个constructor属性，指向了构造函数")]),s._v(" "),a("li",[s._v("prototype是内部属性，外部无法直接访问。但是继承者的p._proto_和被继承的Parent.prototype指向统一对象")]),s._v(" "),a("li",[s._v("顶层原型对象是object，object的原型对象是null(实例的_proto_等于原型的prototype)")]),s._v(" "),a("li",[s._v("js中的继承通过原型链继承实现，所以js是基于原型的语言。java是面向对象语言，创建对象后会把类的属性和方法复制到对象中")]),s._v(" "),a("li",[s._v("函数默认有prototype属性，prototype中有constructor属性，指向函数本身")])]),s._v(" "),a("h4",{attrs:{id:"构造函数与普通函数最核心区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造函数与普通函数最核心区别"}},[s._v("#")]),s._v(" 构造函数与普通函数最核心区别")]),s._v(" "),a("p",[s._v("构造函数通过new来调用，普通函数不需要new\n"),a("a",{attrs:{href:"https://imgtu.com/i/7NK5E8",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://s4.ax1x.com/2022/01/16/7NK5E8.png",alt:"7NK5E8.png"}}),a("OutboundLink")],1)]),s._v(" "),a("h3",{attrs:{id:"_23-js是单线程-单线程有什么好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-js是单线程-单线程有什么好处"}},[s._v("#")]),s._v(" 23.js是单线程，单线程有什么好处？")]),s._v(" "),a("p",[s._v("不用在意线程状态同步问题，没有死锁的情况。")]),s._v(" "),a("h3",{attrs:{id:"_24-queryselector返回值是什么-queryselectorall呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-queryselector返回值是什么-queryselectorall呢"}},[s._v("#")]),s._v(" 24.querySelector返回值是什么?querySelectorAll呢？")]),s._v(" "),a("p",[s._v("querySelector返回的是匹配的第一个元素，querySelectorAll返回的是一个nodeList")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('    for (var div of divs) { 遍历nodeList\n        div.style.color = "blue";\n    }\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h3",{attrs:{id:"_25-函数传参是引用吗-修改形参会影响实参"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-函数传参是引用吗-修改形参会影响实参"}},[s._v("#")]),s._v(" 25.函数传参是引用吗？修改形参会影响实参？")]),s._v(" "),a("ul",[a("li",[s._v("函数传参是引用。 不影响。会开辟一个新的内存地址指向这个参数，修改的是这个新地址指向的值。")]),s._v(" "),a("li",[s._v("基本类型存储在栈中，引用类型存储在堆中，引用类型存储的是一个指针，指向存储对象的内存地址。")]),s._v(" "),a("li",[s._v("基本类型的值可以直接访问，引用类型的值通过指针去访问(js不允许直接访问堆内存中的位置)。")])]),s._v(" "),a("h3",{attrs:{id:"_26-如何判断变量是否是数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-如何判断变量是否是数组"}},[s._v("#")]),s._v(" 26.如何判断变量是否是数组")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("arr instanceof Array\nObject.prototype.toString.call(arr) //同样也可以用来判断对象类型 \nArray.isArray(arr)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h3",{attrs:{id:"_27-如何把对象转成key-value的二维数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_27-如何把对象转成key-value的二维数组"}},[s._v("#")]),s._v(" 27.如何把对象转成key/value的二维数组")]),s._v(" "),a("p",[s._v("object.entries({a:3})")]),s._v(" "),a("h3",{attrs:{id:"_28-说几种遍历数组的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_28-说几种遍历数组的方法"}},[s._v("#")]),s._v(" 28.说几种遍历数组的方法")]),s._v(" "),a("p",[s._v("forEach(缺点中途无法退出)，map，some，every，filter，for of，")]),s._v(" "),a("h3",{attrs:{id:"_29-js的执行过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_29-js的执行过程"}},[s._v("#")]),s._v(" 29.js的执行过程")]),s._v(" "),a("ul",[a("li",[s._v("词法分析=》var a = 2 会被分割成4个单元 var｜a｜=｜2")]),s._v(" "),a("li",[s._v("语法分析=》解析成抽象语法树")]),s._v(" "),a("li",[s._v("代码生成=》会在执行上下文执行")])]),s._v(" "),a("h3",{attrs:{id:"_30-一个超长字符串能存在栈内存中吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_30-一个超长字符串能存在栈内存中吗"}},[s._v("#")]),s._v(" 30.一个超长字符串能存在栈内存中吗？")]),s._v(" "),a("p",[s._v("不能，因为字符串数据一直都是存在堆中的，栈只存了地址指针\n数字=》小整数存在栈中，其他存在堆中\n只有固定大小的对象和值才能在栈上分配空间，string内部是可变的字符数组")]),s._v(" "),a("h3",{attrs:{id:"_31-mouseover和mouseenter的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_31-mouseover和mouseenter的区别"}},[s._v("#")]),s._v(" 31.mouseover和mouseenter的区别")]),s._v(" "),a("ul",[a("li",[s._v("mouseover当鼠标移入元素或子元素都会触发事件，会有重复触发，冒泡的过程，对应移除事件是mouseout")]),s._v(" "),a("li",[s._v("mouseenter当鼠标移除元素本身会触发事件不会冒泡，对应移除事件是mouseleave")])]),s._v(" "),a("h3",{attrs:{id:"_32-new一个对象发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_32-new一个对象发生了什么"}},[s._v("#")]),s._v(" 32.new一个对象发生了什么?")]),s._v(" "),a("ul",[a("li",[s._v("新建一个空对象")]),s._v(" "),a("li",[s._v("为新对象添加属性_proto_并指向构造函数原型")]),s._v(" "),a("li",[s._v("绑定this，执行构造函数")]),s._v(" "),a("li",[s._v("如果构造函数没有返回对象，就返回这个新对象\n手写new")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function create() {\n// 创建⼀个空的对象\nlet obj = new Object()\n// 获得构造函数\nlet Con = [].shift.call(arguments)\n// 链接到原型\nobj.__proto__ = Con.prototype\n// 绑定 this，执⾏构造函数\nlet result = Con.apply(obj, arguments)\n// 如果构造器没有手动返回对象，则返回第一步的对象\nreturn typeof result === 'object' ? result : obj\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h3",{attrs:{id:"_33-和-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_33-和-有什么区别"}},[s._v("#")]),s._v(" 33.==和===有什么区别？")]),s._v(" "),a("p",[s._v("前者只要求值相等，后者要求值和类型都要相等")]),s._v(" "),a("h3",{attrs:{id:"_34-实现一个同步的sleep函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_34-实现一个同步的sleep函数"}},[s._v("#")]),s._v(" 34.实现一个同步的sleep函数")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function sleep(ttl) {\n  const now = Date.now();\n  ttl *= 1000;\n  while (Date.now() - now < ttl) {}\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h3",{attrs:{id:"_35-字符串去重"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_35-字符串去重"}},[s._v("#")]),s._v(" 35.字符串去重")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const str = 'aaavvvdwww'\nvar rs = [].filter.call(str, (item, index, origin) => origin.indexOf(item) == index).join('');\nitem当前字符、index当前字符索引、origin原字符串\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('let newArr = [...new Set(str.split(""))].join(""); 最优解\nlet newArr = Array.from(new Set(str.split(""))).join("")\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h3",{attrs:{id:"_36-怎么判断两个对象相等"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_36-怎么判断两个对象相等"}},[s._v("#")]),s._v(" 36.怎么判断两个对象相等")]),s._v(" "),a("p",[s._v("转成字符串判断\nJSON.stringify(obj)==JSON.stringify(obj2)")]),s._v(" "),a("h3",{attrs:{id:"_37-如何生成100个元素为1的数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_37-如何生成100个元素为1的数组"}},[s._v("#")]),s._v(" 37.如何生成100个元素为1的数组？")]),s._v(" "),a("ul",[a("li",[s._v("Array(100).fill(1); => 相类似的是Array(100).map(x=>1)将会创建一个稀疏数组 [empty * 100]")]),s._v(" "),a("li",[s._v("Array.from(Array(100), x => 1); ｜ Array.from({length: 100}, x=>1)")]),s._v(" "),a("li",[s._v("Array.apply(null, Array(100)).map(x => 1);")])]),s._v(" "),a("h3",{attrs:{id:"_38-typeof和instanceof的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_38-typeof和instanceof的区别"}},[s._v("#")]),s._v(" 38.typeof和instanceof的区别")]),s._v(" "),a("p",[s._v("typeof判断基础数据类型，null除外\ninstanceof判断引用数据类型")]),s._v(" "),a("h4",{attrs:{id:"instanceof原理-》基于原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#instanceof原理-》基于原型链"}},[s._v("#")]),s._v(" instanceof原理=》基于原型链")]),s._v(" "),a("p",[s._v("内部通过原型链的方式来判断是否为构造函数的实例")]),s._v(" "),a("h4",{attrs:{id:"手写instanceof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写instanceof"}},[s._v("#")]),s._v(" 手写instanceof")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("let myInstanceof = (target,origin) => {\n    while(target) {\n        if(target.__proto__===origin.prototype) {\n            return true\n        }\n        target = target.__proto__\n    }\n    return false\n}\nlet a = [1,2,3]\nconsole.log(myInstanceof(a,Array));  // true\nconsole.log(myInstanceof(a,Number));  // false\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h4",{attrs:{id:"typeof和instanceof常见判断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typeof和instanceof常见判断"}},[s._v("#")]),s._v(" typeof和instanceof常见判断")]),s._v(" "),a("p",[s._v("typeof判断引用类型除函数都是object\ninstanceof不能判断基本类型 111 instanceof Number =》 false")]),s._v(" "),a("h3",{attrs:{id:"_39-字符串翻转"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_39-字符串翻转"}},[s._v("#")]),s._v(" 39.字符串翻转")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('let a = \'test\'\nconsole.log(a.split("").reverse().join(""))\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h4",{attrs:{id:"手动实现reverse函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手动实现reverse函数"}},[s._v("#")]),s._v(" 手动实现reverse函数")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function reverse(s) {\n let r = "";\n for (const c of s) {\n  r = c + r;\n }\n return r;\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("h3",{attrs:{id:"_40-手写promise-race"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_40-手写promise-race"}},[s._v("#")]),s._v(" 40.手写promise.race")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Promise.race = (promiseArray) => {\n    return new Promise((resolve, reject) => {\n        promiseArray.forEach((item) => {\n            Promise.resolve(item).then(\n                (val) => {\n                    resolve(val);\n                },\n                (reason) => {\n                    reject(reason);\n                }\n            );\n        });\n    });\n};\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("h3",{attrs:{id:"_41-js数组哪些方法改变自身-哪些方法不改变"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_41-js数组哪些方法改变自身-哪些方法不改变"}},[s._v("#")]),s._v(" 41.js数组哪些方法改变自身，哪些方法不改变")]),s._v(" "),a("ul",[a("li",[s._v("不改变原数组的方法：concat/join/map/forEach/filter/slice/findIndex")]),s._v(" "),a("li",[s._v("改变原数组的方法：push/unshift/pop/shift/sort/splice/reverse =>就是vue中重写的数组")])]),s._v(" "),a("h3",{attrs:{id:"_42-说说object-defineproperty"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_42-说说object-defineproperty"}},[s._v("#")]),s._v(" 42.说说Object.defineProperty")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 普通\nlet o = {};o.a=3;\n// Object.defineProperty\nlet o = {};\nObject.defineProperty(o, 'a', {\n configurable: false, // 是否可删除,默认false删除无效\n enumerable: false, // 是否可枚举 默认false\n writable: true, // 是否可更改，默认false修改无效\n value: 3 默认undefined\n})\n// 可拦截对象属性进行get，set操作\nObject.defineProperty(o, \"a\", {\n configurable: false,\n enumerable: false,\n get() {\n  return this._a;\n },\n set(a) {\n  this._a = a * 10;\n },\n});\no.a=1; // 赋值调用set方法，取值调用get方法\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br")])]),a("h3",{attrs:{id:"_43-如何全部替代一个子串为另一个"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_43-如何全部替代一个子串为另一个"}},[s._v("#")]),s._v(" 43.如何全部替代一个子串为另一个")]),s._v(" "),a("ol",[a("li",[s._v("str.split('foo').join('bar')")]),s._v(" "),a("li",[s._v("str.replaceAll('foo', 'bar')，在ESNext中，支持性不好")])]),s._v(" "),a("h3",{attrs:{id:"_44-0-1-0-2不等于0-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_44-0-1-0-2不等于0-3"}},[s._v("#")]),s._v(" 44.0.1+0.2不等于0.3？")]),s._v(" "),a("p",[s._v("计算机对于浮点数无法准确表达为二进制，此时再转成10进制就不是我们预期的结果0.2+0.4,0.7+0.1")]),s._v(" "),a("h3",{attrs:{id:"_45-类数组转数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_45-类数组转数组"}},[s._v("#")]),s._v(" 45.类数组转数组")]),s._v(" "),a("p",[s._v("类数组指类似数组的对象。有length属性\nkey是0，1，2这样的，类似数组的下标。常见的有arguments\nArray.from(arr)可以将类数组转数组")]),s._v(" "),a("h3",{attrs:{id:"_46"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_46"}},[s._v("#")]),s._v(" 46.")]),s._v(" "),a("h3",{attrs:{id:"_47-js数组去重-原生js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_47-js数组去重-原生js"}},[s._v("#")]),s._v(" 47.js数组去重(原生js)")]),s._v(" "),a("p",[s._v("Array.from(new Set(arr))\narr.filter((item, index) => {\n// 返回当前元素在数组中第一个索引，重复出现的返回都是false，就被过滤掉了\nreturn arr.indexOf(item, 0) === index;\n})")]),s._v(" "),a("h3",{attrs:{id:"_48-什么是作用域-什么是作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_48-什么是作用域-什么是作用域链"}},[s._v("#")]),s._v(" 48.什么是作用域？什么是作用域链?")]),s._v(" "),a("p",[s._v("作用域就是变量的可用范围。分成全局作用域，块级作用域({}只在花括号内)\n当访问一个变量，首先会在当前作用域查找，找不到就会去上一级作用域查找，直到全局作用域，这个过程就是作用域链")]),s._v(" "),a("h4",{attrs:{id:"js有哪些块级作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js有哪些块级作用域"}},[s._v("#")]),s._v(" js有哪些块级作用域")]),s._v(" "),a("p",[s._v("let,const,以及try-catch的catch语句")]),s._v(" "),a("h3",{attrs:{id:"_49-定时器准时吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_49-定时器准时吗"}},[s._v("#")]),s._v(" 49.定时器准时吗")]),s._v(" "),a("p",[s._v("定时器实际可能不准时，受事件循环影响")]),s._v(" "),a("h4",{attrs:{id:"为什么settimeout有最小时延4ms"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么settimeout有最小时延4ms"}},[s._v("#")]),s._v(" 为什么setTimeout有最小时延4ms")]),s._v(" "),a("p",[s._v("(不同浏览器的最小时延不一致，chrome最小时延是1ms)定时器嵌套的层级很多超过了5层那么最低是4ms\n设置延迟过低会导致 CPU-spinning(会导致计算机没办法进入低功耗模式，这样耗电就比较严重)，经过测试后选定了最小时延4ms")]),s._v(" "),a("h4",{attrs:{id:"如何解决最小时延"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何解决最小时延"}},[s._v("#")]),s._v(" 如何解决最小时延")]),s._v(" "),a("p",[s._v("可以通过window.postMessage()=>也是宏任务，和addEventListener('message')结合模拟定时器功能")]),s._v(" "),a("h3",{attrs:{id:"_50-promise-all错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_50-promise-all错误处理"}},[s._v("#")]),s._v(" 50.promise.all错误处理")]),s._v(" "),a("p",[s._v("场景：获取多个用户的信息，即使一个用户失败，也不影响其他用户信息的获取=》此时使用Promise.allSettled;在所有promise都fulfilled或rejected后，\n返回一个数组")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('[\n{ status: "fulfilled", value: result} // 成功响应\n{ status: "rejected", reason: error} // 表示错误\n]\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("原生错误处理:对每个promise进行错误处理，处理后返回res或err，最终到promise.all的还是一个数组，因为错误都被捕获了，所以不会一个reject就挂掉")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("async function handleAllFunc(fun){\n    try{\n        let res = await fun\n        return res\n    }catch(err){\n        return err\n    }\n}\nlet requestArr = [p1(), p2(), p3()]\nPromise.all(requestArr.map(item => handleAllFunc(item))).then(res => {\n    console.log('结果', res);\n}).catch(err => {\n    console.log('错误', err);\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("h3",{attrs:{id:"_51-异步编程的实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_51-异步编程的实现方式"}},[s._v("#")]),s._v(" 51.异步编程的实现方式")]),s._v(" "),a("p",[s._v("1.回调函数 简单，但不利于维护，耦合度高(回调地狱)\n2.promise 链式调用\n3.async 结构清晰更容易理解")]),s._v(" "),a("h3",{attrs:{id:"_52-js如何实现多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_52-js如何实现多线程"}},[s._v("#")]),s._v(" 52.js如何实现多线程")]),s._v(" "),a("p",[s._v("通过worker类\n使用这个类的时候，会向浏览器申请一个新的线程来单独执行一个js")]),s._v(" "),a("h3",{attrs:{id:"_53-js的执行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_53-js的执行机制"}},[s._v("#")]),s._v(" 53.js的执行机制？")]),s._v(" "),a("p",[s._v("js是单线程，一次只能执行一个任务，执行机制就是事件循环\n(js是单线程。浏览器是多线程)")]),s._v(" "),a("h3",{attrs:{id:"_54-剪贴板相关操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_54-剪贴板相关操作"}},[s._v("#")]),s._v(" 54.剪贴板相关操作")]),s._v(" "),a("p",[s._v("可通过Clipboard API来操作(是异步的)=》navigator.clipboard.writeText(text);")]),s._v(" "),a("h4",{attrs:{id:"不支持clipboard-api的浏览器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不支持clipboard-api的浏览器"}},[s._v("#")]),s._v(" 不支持clipboard API的浏览器")]),s._v(" "),a("p",[s._v("先通过Selection API选中，再通过document.execCommand('copy')进行拷贝")]),s._v(" "),a("h3",{attrs:{id:"_59-js中的数组特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_59-js中的数组特点"}},[s._v("#")]),s._v(" 59.js中的数组特点")]),s._v(" "),a("ul",[a("li",[s._v("有两种存储方式，快数组和慢数组。")]),s._v(" "),a("li",[s._v("初始化空数组会用快数组(默认空数组初始化大小为4)，快数组使用连续的内存空间，当数组长度达到最大时，会进行动态扩容(老容量*1.5+16)。")]),s._v(" "),a("li",[s._v("转成慢数组，以哈希表(key,value)的方式存储数据(不需要连续的内存空间)")]),s._v(" "),a("li",[s._v("新加入的索引值比当前容量大等于1024或者快数组新容量是扩容后容量的三倍还多的时候都会由 快数组 转成 慢数组")])]),s._v(" "),a("h3",{attrs:{id:"_60-input事件和change事件区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_60-input事件和change事件区别"}},[s._v("#")]),s._v(" 60.input事件和change事件区别")]),s._v(" "),a("ul",[a("li",[s._v("input：只要在input框内输入内容就触发")]),s._v(" "),a("li",[s._v("change:只有input框内内容改变且失去焦点才触发")])]),s._v(" "),a("h3",{attrs:{id:"_61-with作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_61-with作用"}},[s._v("#")]),s._v(" 61.with作用")]),s._v(" "),a("p",[s._v("可以用来对对象的属性进行解析，但是不推荐使用，存在数据泄漏的问题\n=>如果在with里面赋值一个不存在该对象上的属性，会自动创建全局属性，而不是给这个对象添加新属性")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('a.age = 18\na.name = "aa"\n// 等价于\nwith(a) {\n    age = 18\n    name = "aa"\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("h3",{attrs:{id:"_62-e-target和e-currenttarget区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_62-e-target和e-currenttarget区别"}},[s._v("#")]),s._v(" 62.e.target和e.currentTarget区别")]),s._v(" "),a("ul",[a("li",[s._v("绑定的事件所在元素没有子元素，两者一样")]),s._v(" "),a("li",[s._v("事件绑定在父元素\ne.currentTarget无论点击父元素还是子元素都正常执行(e.currentTarget都是parent)\ne.target点击父元素无错，点击子元素报错(因为事件绑定在父元素上，此时e.target是children)")])]),s._v(" "),a("h3",{attrs:{id:"_63-json相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_63-json相关"}},[s._v("#")]),s._v(" 63.json相关")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('以下代码输出什么?\nconst obj = {\n  a: 3,\n  b: 4,\n  c: null,\n  d: undefined,\n  get e() {},\n};\nconsole.log(JSON.stringify(obj));\n// {"a":3,"b":4,"c":null} 对于undefined和function会被忽略掉\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("h3",{attrs:{id:"_64-剩余参数和arguments对象区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_64-剩余参数和arguments对象区别是什么"}},[s._v("#")]),s._v(" 64.剩余参数和arguments对象区别是什么")]),s._v(" "),a("p",[s._v("剩余参数只包含没有对应形参的实参，而arguments对象包含了传给函数的所有实参\narguments对象不是一个真实数组，而剩余参数是真实的数组，所以剩余参数可以直接使用数组的所有方法，arguments需要转成真实数组才能使用\n=>arguments是类数组")]),s._v(" "),a("h3",{attrs:{id:"_65-js有哪些代码规范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_65-js有哪些代码规范"}},[s._v("#")]),s._v(" 65.*js有哪些代码规范")]),s._v(" "),a("ul",[a("li",[s._v("尽量用===代替==，防止转换的时候出现预期外的异常")]),s._v(" "),a("li",[s._v("switch 必须带有default")]),s._v(" "),a("li",[s._v("if 使用大括号，不要省略")]),s._v(" "),a("li",[s._v("分清楚常量和变量=>const,let")])])])}),[],!1,null,null,null);a.default=r.exports}}]);