(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{292:function(a,s,e){"use strict";e.r(s);var t=e(14),n=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#es6"}},[a._v("es6+")]),s("ul",[s("li",[s("a",{attrs:{href:"#_1-装饰器了解过吗"}},[a._v("1.装饰器了解过吗？")])]),s("li",[s("a",{attrs:{href:"#_2-var和const-let区别"}},[a._v("2.var和const，let区别？")])]),s("li",[s("a",{attrs:{href:"#_3-箭头函数和普通函数区别"}},[a._v("3.箭头函数和普通函数区别？")])]),s("li",[s("a",{attrs:{href:"#_4-es5和es6继承有什么不同"}},[a._v("*4.es5和es6继承有什么不同？")])]),s("li",[s("a",{attrs:{href:"#_5-es6新特性"}},[a._v("5.ES6新特性？")])]),s("li",[s("a",{attrs:{href:"#_6-es5和es6监听对象属性改变区别"}},[a._v("6.es5和es6监听对象属性改变区别？")])]),s("li",[s("a",{attrs:{href:"#_7-async-await实现了generator-如何实现"}},[a._v("7.async,await实现了generator，如何实现？")])]),s("li",[s("a",{attrs:{href:"#_8-foreach-for-of区别"}},[a._v("8.forEach,for of区别？")])]),s("li",[s("a",{attrs:{href:"#_9-async和await缺点"}},[a._v("9.async和await缺点？")])]),s("li",[s("a",{attrs:{href:"#_10-set和map有什么区别"}},[a._v("10.set和map有什么区别？")])]),s("li",[s("a",{attrs:{href:"#_11-map和weakmap区别"}},[a._v("11.map和weakMap区别？")])]),s("li",[s("a",{attrs:{href:"#_12-作用"}},[a._v("12.??作用")])]),s("li",[s("a",{attrs:{href:"#_13-什么是可选链-如何访问数组"}},[a._v("13.什么是可选链？如何访问数组？")])]),s("li",[s("a",{attrs:{href:"#_14-异步的几种解决方案"}},[a._v("14.异步的几种解决方案？")])])])])])]),s("p"),a._v(" "),s("h2",{attrs:{id:"es6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[a._v("#")]),a._v(" es6+")]),a._v(" "),s("h3",{attrs:{id:"_1-装饰器了解过吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-装饰器了解过吗"}},[a._v("#")]),a._v(" 1.装饰器了解过吗？")]),a._v(" "),s("p",[a._v("装饰器是个函数，可以给类加东西。@+函数名")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function testFc(target) {\n    target.name = \"123\" // 添加属性name\n    console.log('调用了')\n}\n\n@testFc\nclass MyTestClass {\n\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("h3",{attrs:{id:"_2-var和const-let区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-var和const-let区别"}},[a._v("#")]),a._v(" 2.var和const，let区别？")]),a._v(" "),s("ul",[s("li",[a._v("var声明的变量是全局的，而let，const声明的变量是块级的。")]),a._v(" "),s("li",[a._v("var声明的变量存在变量提升， let，const不存在。 (变量提升：可以在声明变量前使用这个变量，但是拿到的是undefined，拿不到所赋的值)")])]),a._v(" "),s("h4",{attrs:{id:"变量提升的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#变量提升的原因"}},[a._v("#")]),a._v(" 变量提升的原因？")]),a._v(" "),s("p",[a._v("js代码在运行前都会进行AST(抽象语法树)解析，函数声明和变量声明都会提升到最前面，但赋值不会提升")]),a._v(" "),s("h3",{attrs:{id:"_3-箭头函数和普通函数区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-箭头函数和普通函数区别"}},[a._v("#")]),a._v(" 3.箭头函数和普通函数区别？")]),a._v(" "),s("ul",[s("li",[a._v("箭头函数的this继承外层普通函数的this，如果没有普通函数，this指向window(node中指向空对象)")]),a._v(" "),s("li",[a._v("箭头函数没有构造器，没有原型属性(prototype)，没有arguments对象")])]),a._v(" "),s("h4",{attrs:{id:"vue生命周期的钩子函数为什么不能用箭头函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期的钩子函数为什么不能用箭头函数"}},[a._v("#")]),a._v(" vue生命周期的钩子函数为什么不能用箭头函数？")]),a._v(" "),s("p",[a._v("箭头函数的this关键字不会绑定到vue实例，会报错")]),a._v(" "),s("h3",{attrs:{id:"_4-es5和es6继承有什么不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-es5和es6继承有什么不同"}},[a._v("#")]),a._v(" *4.es5和es6继承有什么不同？")]),a._v(" "),s("ul",[s("li",[a._v("es5的继承是通过构造函数或原型来实现，先创建子类的实例对象this，再将父类的方法绑定到this上")]),a._v(" "),s("li",[a._v("es6是先创建父类的实例对象this，再用子类的构造函数修改this。\n(子类的构造函数中，只有调用super后才能使用this，因为子类没有自己的this，而是继承了父类的this)\n(super调用父类的构造函数)")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("//ES5继承 寄生组合继承\nfunction Parent(name) {\n    this.name = name;\n}\nParent.prototype.eat = function() {\n    console.log(this.name + ' eating')\n}\nfunction Child(name, age) {\n    Parent.call(this,name)\n    this.age = age\n}\nChild.prototype = Object.create(Parent.prototype)\nChild.prototype.constructor = Child\nlet aa = new Child('aa', 123)\nconsole.log(aa.name)\nconsole.log(aa.age)\naa.eat()\n\n//ES6继承\nclass Parent {\n    constructor(name) {\n        this.name = name\n    }\n    eat() {\n        console.log(this.name, 'eating')\n    }\n}\nclass Child extends Parent {\n    constructor(name, age) {\n        super(name);\n        this.age = age;\n    }\n}\nlet aa = new Child('aa', 123)\nconsole.log(aa.name)\nconsole.log(aa.age)\naa.eat()\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br"),s("span",{staticClass:"line-number"},[a._v("33")]),s("br"),s("span",{staticClass:"line-number"},[a._v("34")]),s("br"),s("span",{staticClass:"line-number"},[a._v("35")]),s("br"),s("span",{staticClass:"line-number"},[a._v("36")]),s("br"),s("span",{staticClass:"line-number"},[a._v("37")]),s("br")])]),s("h4",{attrs:{id:"手写任意一种继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#手写任意一种继承"}},[a._v("#")]),a._v(" 手写任意一种继承？")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("原型链继承=>弊端是cat.prototype.constructor指向animal，需要手动改成cat，cat实例化只能继承animal的方法，不能继承属性\nfunction animal() {\nthis.name = 'dog'\n}\nfunction cat() {}\ncat.prototype = new animal()\n构造函数继承=>弊端是cat只能继承animal的属性，不能继承方法\nfunction animal() {\nthis.name = 'dog'\n}\nfunction cat() {\nanimal.call(this)\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br")])]),s("h4",{attrs:{id:"列表继承类型及优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#列表继承类型及优缺点"}},[a._v("#")]),a._v(" 列表继承类型及优缺点？")]),a._v(" "),s("ul",[s("li",[a._v("原型链继承 缺点：原型对象的属性和方法被所有实例共享 构造函数实例话对象无法进行参数传递")]),a._v(" "),s("li",[a._v("构造函数继承 缺点：解决了原型链继承的问题，但不能继承构造函数原型，只能继承构造函数的属性和方法。(常用原型链+构造函数，称为组合继承)")]),a._v(" "),s("li",[a._v("组合式继承 缺点：无论什么情况下，都会调用两次父级构造函数：一次是在创建子级原型的时候，另一次是在子级构造函数内部")]),a._v(" "),s("li",[a._v("寄生继承 缺点：无法复用")]),a._v(" "),s("li",[a._v("原型式继承 缺点：无法复用")]),a._v(" "),s("li",[a._v("寄生组合式继承 目前js继承都是用这个方法。结合了组合继承和寄生继承的优点。")])]),a._v(" "),s("h3",{attrs:{id:"_5-es6新特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-es6新特性"}},[a._v("#")]),a._v(" 5.ES6新特性？")]),a._v(" "),s("ul",[s("li",[a._v("async，await")]),a._v(" "),s("li",[a._v("箭头函数 function(参数) {} (参数)=> {}")]),a._v(" "),s("li",[a._v("const，let")]),a._v(" "),s("li",[a._v("解构赋值=>对象")]),a._v(" "),s("li",[a._v("扩展运算符")]),a._v(" "),s("li",[a._v("模板字符串")]),a._v(" "),s("li",[a._v("for of遍历(for in不是es6新增)")]),a._v(" "),s("li",[a._v("set/weakSet map/weakMap")]),a._v(" "),s("li",[a._v("class类, 装饰器")]),a._v(" "),s("li",[a._v("generator")]),a._v(" "),s("li",[a._v("reflect/proxy")]),a._v(" "),s("li",[a._v("promise")]),a._v(" "),s("li",[a._v("symbol/bigInt=》构造函数返回一个symbol，保证是唯一的。不能new=》即使传入相同的值生成的值也是唯一")]),a._v(" "),s("li",[a._v("可选链?.")]),a._v(" "),s("li",[a._v("Object.entries()=>Object.fromEntries()=>对象")]),a._v(" "),s("li",[a._v("Array.at() =>获取某个索引的元素 arr = [0, 1, 2] arr.at(2) =>就是2")]),a._v(" "),s("li",[a._v("Array.from()将类数组和可遍历(iterable)对象转数组 =>数组")]),a._v(" "),s("li",[a._v("find()=>数组")]),a._v(" "),s("li",[a._v("includes()=>数组")]),a._v(" "),s("li",[a._v("flat(),flatMap()=>数组")]),a._v(" "),s("li",[a._v("Object.assign()=>对象")])]),a._v(" "),s("h4",{attrs:{id:"proxy和reflect-》改变this指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proxy和reflect-》改变this指向"}},[a._v("#")]),a._v(" proxy和reflect=》改变this指向")]),a._v(" "),s("ul",[s("li",[a._v("proxy代理对象，可以拦截对象的读和写操作")]),a._v(" "),s("li",[a._v("let proxy = new Proxy(target, handler) target就是要代理的对象 handler定义了代理后的操作\n=》比如代理后的读写操作get，set就是在handler里")]),a._v(" "),s("li",[a._v("reflect反射，(不是构造函数不能通过new调用)，提供拦截js操作的方法=》比如reflect.defineProperty")]),a._v(" "),s("li",[a._v("作用修改某些object的返回结果，比如Object.defineProperty无法定义时会抛出错误，而reflect只会返回false")]),a._v(" "),s("li",[a._v("与proxy相对应，proxy对象的方法，在reflect对象上都能找到")]),a._v(" "),s("li",[a._v("reflect所有属性和方法都是静态的")])]),a._v(" "),s("h5",{attrs:{id:"常用api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用api"}},[a._v("#")]),a._v(" 常用api：")]),a._v(" "),s("ul",[s("li",[a._v("reflect.apply等同apply=》改变this指向")]),a._v(" "),s("li",[a._v("reflect.defineProperty等同Object.defineProperty")])]),a._v(" "),s("h4",{attrs:{id:"es7"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es7"}},[a._v("#")]),a._v(" ES7")]),a._v(" "),s("ul",[s("li",[a._v("Array.prototype.includes()")]),a._v(" "),s("li",[a._v("**幂运算符")])]),a._v(" "),s("h4",{attrs:{id:"es8"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es8"}},[a._v("#")]),a._v(" ES8")]),a._v(" "),s("ul",[s("li",[a._v("async await")]),a._v(" "),s("li",[a._v("Object.values()")]),a._v(" "),s("li",[a._v("Object.entries()")])]),a._v(" "),s("h4",{attrs:{id:"es9"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es9"}},[a._v("#")]),a._v(" ES9")]),a._v(" "),s("ul",[s("li",[a._v("for await ... of")]),a._v(" "),s("li",[a._v("对象扩展操作符{...obj}")]),a._v(" "),s("li",[a._v("promise.prototype.finally()")])]),a._v(" "),s("h4",{attrs:{id:"es10"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es10"}},[a._v("#")]),a._v(" ES10")]),a._v(" "),s("ul",[s("li",[a._v("Array,prototype.flat()/flatMap()")]),a._v(" "),s("li",[a._v("Object.fromEntries()")]),a._v(" "),s("li",[a._v("String.prototype.matchAll()")]),a._v(" "),s("li",[a._v("BigInt")])]),a._v(" "),s("h4",{attrs:{id:"es11"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es11"}},[a._v("#")]),a._v(" ES11")]),a._v(" "),s("ul",[s("li",[a._v("promise.allSettled")]),a._v(" "),s("li",[a._v("可选链?.")]),a._v(" "),s("li",[a._v("空值合并运算符??=》左侧为null或undefined，返回右侧，否则返回左侧")])]),a._v(" "),s("h4",{attrs:{id:"es12-》2021-02-20"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es12-》2021-02-20"}},[a._v("#")]),a._v(" ES12=》2021.02.20")]),a._v(" "),s("ul",[s("li",[a._v("String.prototype.replaceAll() =>a.replaceAll('2', '3') 直接替换，不用通过之前/g全局更新的方式")]),a._v(" "),s("li",[a._v("Promise.any =>和promise.race类似，但它会等到所有promise都失败之后，才返回失败的值。.race一个成功就返回第一个promise的值作为返回值")]),a._v(" "),s("li",[a._v("WeakRef")])]),a._v(" "),s("h4",{attrs:{id:"es13-》2022-在今年6月已经成为标准"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es13-》2022-在今年6月已经成为标准"}},[a._v("#")]),a._v(" ES13=》2022 在今年6月已经成为标准")]),a._v(" "),s("p",[a._v("Array.at()")]),a._v(" "),s("p",[a._v("语法糖：糖衣语法，语法糖能够增强程序的可读性，减少代码出错的机会，把复杂的方法进行封装。\nforEach就属于语法糖")]),a._v(" "),s("h3",{attrs:{id:"_6-es5和es6监听对象属性改变区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-es5和es6监听对象属性改变区别"}},[a._v("#")]),a._v(" 6.es5和es6监听对象属性改变区别？")]),a._v(" "),s("p",[a._v("ES5:通过defineProperty，如果属性不在对象中，则不能监听")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Object.defineProperty(user,'name',{\n    set:function(key,value){}\n})\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("p",[a._v("ES6:通过proxy代理，即使属性不在对象中，也可以监听")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("var user = new Proxy({}，{\n    set:function(target,key,value,receiver){}\n})\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("h3",{attrs:{id:"_7-async-await实现了generator-如何实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-async-await实现了generator-如何实现"}},[a._v("#")]),a._v(" 7.async,await实现了generator，如何实现？")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function* myGenerator() {\nconsole.log(yield Promise.resolve(1))   //1\nconsole.log(yield Promise.resolve(2))   //2\n}\nfunction run(myGenerator) {\nvar g = gen(); //由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在step()之前,否则会进入死循环\n\tfunction step(val) {  //封装一个方法, 递归执行next()\n\t\tvar res = g.next(val)  //获取迭代器对象，并返回resolve的值\n\t\tif (res.done) return res.value; //递归终止条件\n\t\tres.value.then(val => {  //Promise的then方法是实现自动迭代的前提\n\t\t\tstep(val)   //等待Promise完成就自动执行下一个next，并传入resolve的值\n\t\t})\n\t}\n\tstep(); //第一次执行\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br")])]),s("h4",{attrs:{id:"generator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[a._v("#")]),a._v(" generator？")]),a._v(" "),s("p",[a._v(".next()返回一个对象{value: '',done: true}=>当done为true表示都执行完毕\n第一个yield拿到的是第二个next()传递的参数")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function *test() {\n    let input1 = yield \"1111\"\n    console.log(input1)\n}\nlet tt = test()\nlet a = tt.next('333')\nconsole.log(a)\nlet b = tt.next('444') \nconsole.log(b)\n// 结果\n{ value: '1111', done: false } // 第一次next到yield输出就结束了 拿不到传递的333\n444\n{ value: undefined, done: true } // 第二次next才能被接收到输出444\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br")])]),s("h3",{attrs:{id:"_8-foreach-for-of区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-foreach-for-of区别"}},[a._v("#")]),a._v(" 8.forEach,for of区别？")]),a._v(" "),s("ul",[s("li",[a._v("forEach里面不能执行异步函数，for of可以")]),a._v(" "),s("li",[a._v("forEach不支持break，continue，for of可以")])]),a._v(" "),s("h4",{attrs:{id:"for-of-和-for-in区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#for-of-和-for-in区别"}},[a._v("#")]),a._v(" for...of 和 for...in区别？")]),a._v(" "),s("ul",[s("li",[a._v("for of常用来遍历数组，for in遍历对象(for in 遍历会到原型上)")]),a._v(" "),s("li",[a._v("for of不能直接遍历对象")])]),a._v(" "),s("h3",{attrs:{id:"_9-async和await缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-async和await缺点"}},[a._v("#")]),a._v(" 9.async和await缺点？")]),a._v(" "),s("p",[a._v("await会阻塞代码，滥用可能会导致代码失去并发性")]),a._v(" "),s("h3",{attrs:{id:"_10-set和map有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-set和map有什么区别"}},[a._v("#")]),a._v(" 10.set和map有什么区别？")]),a._v(" "),s("ul",[s("li",[a._v("set类似于数组，但是所有值都是唯一的")]),a._v(" "),s("li",[a._v("map类似于对象，也是键值对的集合。对象要求键是字符串，map允许任意类型当成是键")])]),a._v(" "),s("h4",{attrs:{id:"set为什么能去重"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set为什么能去重"}},[a._v("#")]),a._v(" set为什么能去重？")]),a._v(" "),s("ul",[s("li",[a._v("会先调用对象的hash方法，获取hash结果")]),a._v(" "),s("li",[a._v("如果结果相同，调用eq()方法去判断二者的值是否相等,eq本质就是==，都相等就去重")])]),a._v(" "),s("h3",{attrs:{id:"_11-map和weakmap区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-map和weakmap区别"}},[a._v("#")]),a._v(" 11.map和weakMap区别？")]),a._v(" "),s("ul",[s("li",[a._v("map可使用任何数据类型作为key，weakMap只能用引用类型作为key。")]),a._v(" "),s("li",[a._v("map不会被垃圾回收，weakMap会被垃圾回收。因为weakMap是弱引用，不在内部维护两个数组，所以也无法遍历(没有keys(),values(),entries()，size，clear())\n(weakMap只有get(),set(),has(),delete())")])]),a._v(" "),s("h4",{attrs:{id:"set和weakset区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set和weakset区别"}},[a._v("#")]),a._v(" set和weakSet区别？")]),a._v(" "),s("p",[a._v("weakSet是弱引用，无法遍历。并且只能存对象引用，不能存放值，set都可以")]),a._v(" "),s("h3",{attrs:{id:"_12-作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-作用"}},[a._v("#")]),a._v(" 12.??作用")]),a._v(" "),s("ul",[s("li",[a._v("和||(或)类似，只有变量为null或undefined才使用后面的值")]),a._v(" "),s("li",[a._v("而||只要前面是false就取后面")])]),a._v(" "),s("h4",{attrs:{id:"区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[a._v("#")]),a._v(" 区别")]),a._v(" "),s("ul",[s("li",[a._v("0||1结果1 0??1结果0")]),a._v(" "),s("li",[a._v("false||123结果123 false??123结果false")])]),a._v(" "),s("h3",{attrs:{id:"_13-什么是可选链-如何访问数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-什么是可选链-如何访问数组"}},[a._v("#")]),a._v(" 13.什么是可选链？如何访问数组？")]),a._v(" "),s("ul",[s("li",[a._v("?.操作符，可以嵌套获取对象的属性值。且对象的属性值可能是undefined或null。a?.b?.c")]),a._v(" "),s("li",[a._v("obj?.a?.[0]即可访问数据，通过数组下标")])]),a._v(" "),s("h3",{attrs:{id:"_14-异步的几种解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-异步的几种解决方案"}},[a._v("#")]),a._v(" 14.异步的几种解决方案？")]),a._v(" "),s("ul",[s("li",[a._v("回调函数")]),a._v(" "),s("li",[a._v("promise")]),a._v(" "),s("li",[a._v("generator")]),a._v(" "),s("li",[a._v("async/await")])])])}),[],!1,null,null,null);s.default=n.exports}}]);