(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{290:function(a,e,s){"use strict";s.r(e);var t=s(14),r=Object(t.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#webpack"}},[a._v("Webpack")]),e("ul",[e("li",[e("a",{attrs:{href:"#_1-什么是webpack"}},[a._v("1.什么是webpack？")])]),e("li",[e("a",{attrs:{href:"#_2-webpack有哪些配置"}},[a._v("2.webpack有哪些配置？")])]),e("li",[e("a",{attrs:{href:"#_3-code-splitting-代码切割-splitchunks"}},[a._v("3.code splitting 代码切割=>splitChunks？")])]),e("li",[e("a",{attrs:{href:"#_4-如何做打包体积分析"}},[a._v("4.如何做打包体积分析?")])]),e("li",[e("a",{attrs:{href:"#_5-什么是模块"}},[a._v("5.什么是模块？")])]),e("li",[e("a",{attrs:{href:"#_6-webpack运行时-runtime-做了什么"}},[a._v("6.webpack运行时(Runtime)做了什么？")])]),e("li",[e("a",{attrs:{href:"#_7-webpack的工作流程"}},[a._v("7.webpack的工作流程？")])]),e("li",[e("a",{attrs:{href:"#_8-webpack和gulp区别"}},[a._v("8.webpack和gulp区别？")])]),e("li",[e("a",{attrs:{href:"#_9-webpack有哪些常见的loader和plugin"}},[a._v("9.webpack有哪些常见的loader和plugin？")])]),e("li",[e("a",{attrs:{href:"#loader和plugin区别"}},[a._v("loader和plugin区别")])]),e("li",[e("a",{attrs:{href:"#_10-loader开发-分同步和异步loader"}},[a._v("10.loader开发？(分同步和异步loader)")])]),e("li",[e("a",{attrs:{href:"#_11-plugin开发"}},[a._v("11.plugin开发？")])]),e("li",[e("a",{attrs:{href:"#_12-source-map有哪些配置"}},[a._v("12.source map有哪些配置？")])]),e("li",[e("a",{attrs:{href:"#_13-treeshaking了解过吗"}},[a._v("13.TreeShaking了解过吗？")])]),e("li",[e("a",{attrs:{href:"#_14-hash-contenthash-chunkhash区别-都是hash策略"}},[a._v("14.hash，contentHash，chunkHash区别？(都是hash策略)")])]),e("li",[e("a",{attrs:{href:"#_15-ast及应用"}},[a._v("15.AST及应用？")])]),e("li",[e("a",{attrs:{href:"#_16-webpack中什么是hmr"}},[a._v("16.webpack中什么是HMR？")])]),e("li",[e("a",{attrs:{href:"#_17-如何提升webpack构建资源的速度"}},[a._v("17.如何提升webpack构建资源的速度？")])]),e("li",[e("a",{attrs:{href:"#_18-webpack-rollup-vite如何加载json-image等非js资源"}},[a._v("18.webpack/rollup/vite如何加载json,image等非js资源？")])]),e("li",[e("a",{attrs:{href:"#_19-如何将js资源注入到html中"}},[a._v("19.如何将js资源注入到html中？")])]),e("li",[e("a",{attrs:{href:"#_20-为什么可以在webpack配置文件使用path模块"}},[a._v("20.为什么可以在webpack配置文件使用path模块？")])]),e("li",[e("a",{attrs:{href:"#_21-mode有几种模式"}},[a._v("21.mode有几种模式？")])]),e("li",[e("a",{attrs:{href:"#_22-vue-loader实现原理是什么"}},[a._v("22.vue-loader实现原理是什么？")])]),e("li",[e("a",{attrs:{href:"#_23-webpack4为什么选择了terser"}},[a._v("23.webpack4为什么选择了terser?")])]),e("li",[e("a",{attrs:{href:"#_24-minify原理"}},[a._v("24.minify原理？")])]),e("li",[e("a",{attrs:{href:"#_25-webpack打包流程"}},[a._v("25.webpack打包流程？")])]),e("li",[e("a",{attrs:{href:"#_26-配置时thread-loader在前还是cache-loader"}},[a._v("*26.配置时thread-loader在前还是cache-loader？")])]),e("li",[e("a",{attrs:{href:"#_27-babel-loader-cache-loader缓存的区别"}},[a._v("*27.babel-loader,cache-loader缓存的区别？")])]),e("li",[e("a",{attrs:{href:"#_28-proxy原理"}},[a._v("28.proxy原理？")])]),e("li",[e("a",{attrs:{href:"#_29-webpack生命周期"}},[a._v("29.webpack生命周期")])])])])])]),e("p"),a._v(" "),e("h2",{attrs:{id:"webpack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[a._v("#")]),a._v(" Webpack")]),a._v(" "),e("h3",{attrs:{id:"_1-什么是webpack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是webpack"}},[a._v("#")]),a._v(" 1.什么是webpack？")]),a._v(" "),e("ul",[e("li",[a._v("webpack(基于node，只能处理js和json文件)是一个打包工具，在webpack里一切文件皆是模块")]),a._v(" "),e("li",[a._v("他做的事情是分析你的项目结构，找到js模块以及它的一些浏览器不能直接运行的语言比如scss，ts等，将其打包成合适的格式给浏览器使用")])]),a._v(" "),e("h4",{attrs:{id:"为什么要用webpack对前端进行打包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用webpack对前端进行打包"}},[a._v("#")]),a._v(" 为什么要用webpack对前端进行打包？")]),a._v(" "),e("ol",[e("li",[a._v("打包后体积更新页面加载更快")]),a._v(" "),e("li",[a._v("编译高级语法(TS，ES6)")])]),a._v(" "),e("ul",[e("li",[a._v("原生支持tree shaking(去除用不上的代码)")]),a._v(" "),e("li",[a._v("webpack中tree-shaking是通过uglifySPlugin来处理js，通过purify-css处理css")]),a._v(" "),e("li",[a._v("主要四个模块entry output loader plugins")])]),a._v(" "),e("h4",{attrs:{id:"webpack3和4区别-webpack4号称零配置开箱即用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack3和4区别-webpack4号称零配置开箱即用"}},[a._v("#")]),a._v(" webpack3和4区别(webpack4号称零配置开箱即用)")]),a._v(" "),e("ul",[e("li",[a._v("4相对于3分包做了优化，移除CommonsChunkPlugin用splitChunksPlugin切割代码")]),a._v(" "),e("li",[a._v("分离css原来用extract-text-webpack-plugin，现在用MiniCssExtractPlugin")]),a._v(" "),e("li",[a._v("增加mode属性")]),a._v(" "),e("li",[a._v("默认的压缩插件从uglifyjs-webpack-plugin变成terser-webpack-plugin")]),a._v(" "),e("li",[a._v("webpack4:支持零配置直接打包，按约定以src/index.js为入口,dist/main.js为出口")])]),a._v(" "),e("h4",{attrs:{id:"webpack4和5区别-webpack5node最低要求10-13"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack4和5区别-webpack5node最低要求10-13"}},[a._v("#")]),a._v(" webpack4和5区别(webpack5node最低要求10.13)")]),a._v(" "),e("ul",[e("li",[a._v("webpack4加载资源需要不同的loader(file-loader,url-loader等)，")]),a._v(" "),e("li",[a._v("而webpack5有资源模块(asset module)来替代，比如file-loader可以用asset/resource，url-loader可以用asset/inline来替代")]),a._v(" "),e("li",[a._v("webpack5支持原生worker")]),a._v(" "),e("li",[a._v("缓存在webpack5默认开启，缓存在内存里(cacheDirectory)")])]),a._v(" "),e("h3",{attrs:{id:"_2-webpack有哪些配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-webpack有哪些配置"}},[a._v("#")]),a._v(" 2.webpack有哪些配置？")]),a._v(" "),e("ul",[e("li",[a._v("mode:模式")]),a._v(" "),e("li",[a._v("entry:入口")]),a._v(" "),e("li",[a._v("output:出口")]),a._v(" "),e("li",[a._v("optimization：策略，比如分包splitChunks=》node_modules，moduleL配置根据正则匹配对应加载器\nplugin:配置插件，resolve配置模块如何解析=》vue配置别名会被精准匹配=》用来配置importVue时候的vue路径，context指定entry的根路径")])]),a._v(" "),e("h3",{attrs:{id:"_3-code-splitting-代码切割-splitchunks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-code-splitting-代码切割-splitchunks"}},[a._v("#")]),a._v(" 3.code splitting 代码切割=>splitChunks？")]),a._v(" "),e("p",[a._v("默认所有代码会被打包到一起，bundle体积会太大，通过分包进行优化")]),a._v(" "),e("ul",[e("li",[a._v("import()动态导入=>按需加载")])]),a._v(" "),e("h4",{attrs:{id:"魔法注释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#魔法注释"}},[a._v("#")]),a._v(" 魔法注释")]),a._v(" "),e("p",[a._v("目的就是设置动态导入的文件打包出来的名称, 命名相同的会被打包到一起")]),a._v(" "),e("ul",[e("li",[a._v("splitChunksPlugin可以将公共的依赖模块提取到已有的chunk中，在optimization中配置")]),a._v(" "),e("li",[a._v("通过entry来手动分离=》多入口打包=>存在多个打包结果有相同模块的情况，需要将optimization的splitChunks的chunks设置为'all'(将公共模块提取到单独的bundle)=>重要")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("optimization: {\n    splitChunks: {\n        chunks: 'all' | 'async' | 'initial' =》 默认只将异步导入的模块单独打包  all是所有都单独打包，最后打在一个文件上 initial是都单独打包，打包到各自的文件上\n    }\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br")])]),e("h4",{attrs:{id:"code-splitting-代码切割-是如何动态加载chunk的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#code-splitting-代码切割-是如何动态加载chunk的"}},[a._v("#")]),a._v(" code splitting(代码切割) 是如何动态加载chunk的")]),a._v(" "),e("p",[a._v("主要是通过jsonp的方式来动态加载chunk")]),a._v(" "),e("h4",{attrs:{id:"webpack分包与合包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack分包与合包"}},[a._v("#")]),a._v(" webpack分包与合包")]),a._v(" "),e("ul",[e("li",[a._v("webpack4.0之前通过commonChunkPlugin来分包")]),a._v(" "),e("li",[a._v("webpack4.0之后通过设置optimization.splitChunks来分包")])]),a._v(" "),e("h4",{attrs:{id:"optimization"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#optimization"}},[a._v("#")]),a._v(" optimization")]),a._v(" "),e("ul",[e("li",[a._v("usedExports: true, 打包结果中只导出外部用到的成员")]),a._v(" "),e("li",[a._v("minimize: true 压缩打包结果\n=>生产默认开启tree-shaking，如果没有开启可以通过配置usedExports和minimize开启=》一个标记无用的代码，一个用来压缩时进行清除")]),a._v(" "),e("li",[a._v("sideEffects：用来删除副作用代码\n=>先去webpack.config.js的optimization设置sideEffect为true来开启功能，再去package.json设置sideEffects为false，标记代码没有副作用\n=>如果想标记哪些文件有副作用，在package.json的sideEffects可以定义一个数组，里面放有副作用的文件路径")])]),a._v(" "),e("h3",{attrs:{id:"_4-如何做打包体积分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何做打包体积分析"}},[a._v("#")]),a._v(" 4.如何做打包体积分析?")]),a._v(" "),e("ul",[e("li",[a._v("通过webpack-bundle-analyzer分析打包体积")]),a._v(" "),e("li",[a._v("原理是根据webpack打包后的stats数据进行分析，在webpack compiler的done hook进行处理")]),a._v(" "),e("li",[a._v("在可视化页面中，可以看到三个选项。1.stat每个模块原始体积2.parsed经webpack打包后的体积3.gzip经gzip压缩后的体积")])]),a._v(" "),e("h4",{attrs:{id:"webpack如何优化项目体积"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack如何优化项目体积"}},[a._v("#")]),a._v(" webpack如何优化项目体积")]),a._v(" "),e("p",[a._v("uglify或terser进行js压缩，使用commonChunk分离第三方代码，使用externals配置来提取常用库(这样不会被打到bundle中，使用时通过cdn来引入)")]),a._v(" "),e("h3",{attrs:{id:"_5-什么是模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-什么是模块"}},[a._v("#")]),a._v(" 5.什么是模块？")]),a._v(" "),e("p",[a._v("将一个复杂的项目按一定的规范封装成几个模块，只是向外部暴露一些方法来进行通信")]),a._v(" "),e("h4",{attrs:{id:"module-chunk-bundle区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#module-chunk-bundle区别"}},[a._v("#")]),a._v(" module，chunk，bundle区别")]),a._v(" "),e("p",[a._v("webpack中一切都是(module) 多个模块合成一个chunk(代码块) bundle是最终输出文件")]),a._v(" "),e("h3",{attrs:{id:"_6-webpack运行时-runtime-做了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-webpack运行时-runtime-做了什么"}},[a._v("#")]),a._v(" 6.webpack运行时(Runtime)做了什么？")]),a._v(" "),e("ul",[e("li",[a._v("webpack打包后的bundle实际就是个立即执行函数(IIFE)")])]),a._v(" "),e("h4",{attrs:{id:"webpack4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack4"}},[a._v("#")]),a._v(" webpack4")]),a._v(" "),e("p",[a._v("立即执行函数主要这几块，__webpack__modules存放编译后的模块内容，__webpack__module_cache用来做模块缓存(缓存被引用过的模块)，\n__webpack__require__是模块引用函数，然后还有几个工具函数，最后通过__webpack_require，传递索引0，即入口文件来启动整个项目")]),a._v(" "),e("h4",{attrs:{id:"webpack5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack5"}},[a._v("#")]),a._v(" webpack5")]),a._v(" "),e("p",[a._v("在立即执行函数里主要是这几块，__webpack__modules用来存放编译后的模块的js内容，__webpack__module_cache__用来做模块缓存，\n__webpack_require__是模块引用函数，来实现模块的导入导出，最后通过__webpack_require引入入口文件main.js启动整个项目=》不通过索引，而是具体文件位置?")]),a._v(" "),e("ol",[e("li",[a._v("__webpack_modules__是一个维护所有模块的数组。将入口模块解析成AST，根据AST深度优先搜索所有的模块，并构建出这个模块数组。\n每个模块都由一个包裹函数(module,module.export,"),e("strong",[a._v("webpack_require")]),a._v(")对模块进行包裹构成")]),a._v(" "),e("li",[a._v("__webpack_require__手动实现加载一个模块。对已加载过的模块进行缓存，对未加载过的模块，通过id定位到__webpack_modules__中的包裹函数，\nid就是数组的key(索引)，执行并返回module.export，最后缓存")]),a._v(" "),e("li",[e("strong",[a._v("webpack_require")]),a._v("(0)运行入口模块=》也就是配置的main.js\nrollup不会将所有模块放在modules中进行维护，它是将所有模块进行展开，如果两个模块中的变量名发生冲突，会直接重新命名")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("name.js const name = '111'\nfriend.js const name = '111'\n=> const name$1 = '111' const name = '111'\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("h3",{attrs:{id:"_7-webpack的工作流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-webpack的工作流程"}},[a._v("#")]),a._v(" 7.webpack的工作流程？")]),a._v(" "),e("ol",[e("li",[a._v("合并命令行和webpack配置文件里配置的参数，得到最终的配置对象=>webpack CLI作用(通过yargs模块解析命令行参数)")]),a._v(" "),e("li",[a._v("初始化compiler对象，加载所有配置的插件")]),a._v(" "),e("li",[a._v("执行compiler对象的run方法开始编译")]),a._v(" "),e("li",[a._v("根据配置的entry找到入口文件，解析模块依赖形成依赖树。递归依赖树，将每个模块交给对应的loader处理")]),a._v(" "),e("li",[a._v("根据entry和output配置生成代码块chunk")]),a._v(" "),e("li",[a._v("根据output输出chunk到对应文件目录")])]),a._v(" "),e("h3",{attrs:{id:"_8-webpack和gulp区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-webpack和gulp区别"}},[a._v("#")]),a._v(" 8.webpack和gulp区别？")]),a._v(" "),e("ul",[e("li",[a._v("侧重点不同，webpack侧重模块打包，gulp侧重流程管理。")]),a._v(" "),e("li",[a._v("gulp通过配置task任务，来定义任务的执行顺序，按顺序对项目进行构建")]),a._v(" "),e("li",[a._v("webpack把图片，js文件，css文件等看成是模块，通过加载器(loader)和插件(plugins)对资源进行处理")])]),a._v(" "),e("h3",{attrs:{id:"_9-webpack有哪些常见的loader和plugin"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-webpack有哪些常见的loader和plugin"}},[a._v("#")]),a._v(" 9.webpack有哪些常见的loader和plugin？")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("babel-loader => es6+转es5")])]),a._v(" "),e("li",[e("p",[a._v("css-loader => 加载css并压缩(支持模块化) =》打包css文件需要同时使用css-loader和style-loader=>style-loader用来注入css")])]),a._v(" "),e("li",[e("p",[a._v("style-loader => 通过script方式把css注入js中")])]),a._v(" "),e("li",[e("p",[a._v("image-loader：加载并且压缩图片文件")])]),a._v(" "),e("li",[e("p",[a._v("vue-loader => 加载 Vue.js 单文件组件")])]),a._v(" "),e("li",[e("p",[a._v("*sass-loader =>把sass转成css =》核心原理是通过ast\n=>同一个模块同时use多个loader，执行顺序从后往前=》常见打包css，用到了style-loader和css-loader")])]),a._v(" "),e("li",[e("p",[a._v("uglifyjs-webpack-plugin 通过uglify压缩js代码")])]),a._v(" "),e("li",[e("p",[a._v("mini-css-extract-plugin 分离css文件，支持按需加载")])]),a._v(" "),e("li",[e("p",[a._v("html-webpack-plugin 会把webpack打包后的静态资源注入到html中")])]),a._v(" "),e("li",[e("p",[a._v("webpack-bundle-analyzer 分析文件体积")])]),a._v(" "),e("li",[e("p",[a._v("copy-webpack-plugin 指定需要拷贝的目录会拷贝到dist下")])]),a._v(" "),e("li",[e("p",[a._v("clean-webpack-plugin 清除dist目录\n=》webpack为每个工作环节都预留了钩子，插件只要找合适的时机去做指定的事情即可")])])]),a._v(" "),e("h3",{attrs:{id:"loader和plugin区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#loader和plugin区别"}},[a._v("#")]),a._v(" loader和plugin区别")]),a._v(" "),e("ul",[e("li",[a._v("webpack本身只能解析js文件，想打包其他文件就需要引入对应loader进行处理")]),a._v(" "),e("li",[a._v("plugin是用来扩展webpack功能。")])]),a._v(" "),e("h4",{attrs:{id:"loader作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#loader作用"}},[a._v("#")]),a._v(" loader作用")]),a._v(" "),e("p",[a._v("loader是用来处理其他类型的文件比如将less转成css文件，es6转es5，ts转js等")]),a._v(" "),e("h4",{attrs:{id:"loader执行顺序-pre-normal-inline-post"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#loader执行顺序-pre-normal-inline-post"}},[a._v("#")]),a._v(" loader执行顺序(pre>normal>inline>post)")]),a._v(" "),e("p",[a._v("从右到左，从下到上")]),a._v(" "),e("h4",{attrs:{id:"loader为什么右边的先执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#loader为什么右边的先执行"}},[a._v("#")]),a._v(" loader为什么右边的先执行")]),a._v(" "),e("p",[a._v("函数组合有两种方式，一种从左往右(类似pipe流)，一种从右往左(compose),webpack采用的是第二种")]),a._v(" "),e("h3",{attrs:{id:"_10-loader开发-分同步和异步loader"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-loader开发-分同步和异步loader"}},[a._v("#")]),a._v(" 10.loader开发？(分同步和异步loader)")]),a._v(" "),e("p",[a._v("定义一个函数用来对资源进行处理，并导出(函数不能用箭头函数，因为过程中会改变this指向，用箭头函数会报错)\n(输入是加载到的资源，输出是处理后的结果)")]),a._v(" "),e("h3",{attrs:{id:"_11-plugin开发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-plugin开发"}},[a._v("#")]),a._v(" 11.plugin开发？")]),a._v(" "),e("ul",[e("li",[a._v("plugin是通过钩子机制实现的。在不同事件节点上挂载不同的任务来扩展插件=>插件是通过在生命周期的钩子中挂载函数实现扩展")]),a._v(" "),e("li",[a._v("插件是一个函数或者类，必须包含apply方法")]),a._v(" "),e("li",[a._v("把插件定义为一个类，在类中定义apply方法，参数是compiler(完整的webpack环境配置)，再通过compiler的钩子emit来实现。钩子第一个参数是插件名，")]),a._v(" "),e("li",[a._v("第二个compilation是上下文， 通过compilation.assets就可以拿到本次打包的资源，然后再做相应处理(主要是source函数和size函数)，\n最后执行callback(也是第二个参数里的)")])]),a._v(" "),e("h3",{attrs:{id:"_12-source-map有哪些配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-source-map有哪些配置"}},[a._v("#")]),a._v(" 12.source map有哪些配置？")]),a._v(" "),e("p",[a._v("sourceMap作用：映射文件，用来将打包后的代码映射到源码文件中，便于定位错误")]),a._v(" "),e("ul",[e("li",[a._v("eval 使用eval执行模块代码，构建速度快(只能知道文件路径，不知道具体行信息)")]),a._v(" "),e("li",[a._v("sourceMap 有行信息，产生.map文件")]),a._v(" "),e("li",[a._v("cheap 包含行信息，但是和源代码还是有差异")]),a._v(" "),e("li",[a._v("module 得到loader处理前的代码，和源代码一模一样")]),a._v(" "),e("li",[a._v("inline:不单独生成.map文件(较少见此配置)\n使用cheap-module-eval-source-map模式，打包出来的就和源代码一模一样=》开发时推荐使用，启动打包慢，监视的情况重新打包快\n较优配置生产环境使用none，推荐使用nosources-source-map不会暴露所有源代码，只会展示出现问题的代码位置")])]),a._v(" "),e("h4",{attrs:{id:"常规使用配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常规使用配置"}},[a._v("#")]),a._v(" 常规使用配置")]),a._v(" "),e("ul",[e("li",[a._v("开发环境：cheap-module-eval-source-map")]),a._v(" "),e("li",[a._v("生产环境：cheap-module-source-map")])]),a._v(" "),e("h3",{attrs:{id:"_13-treeshaking了解过吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-treeshaking了解过吗"}},[a._v("#")]),a._v(" 13.TreeShaking了解过吗？")]),a._v(" "),e("p",[a._v("tree shaking前提是esm")]),a._v(" "),e("h4",{attrs:{id:"treeshaking原理是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#treeshaking原理是什么"}},[a._v("#")]),a._v(" TreeShaking原理是什么")]),a._v(" "),e("p",[a._v("是基于ESModule进行静态分析，通过AST将用不到的代码进行移除。还可以通过引入支持treeShaking的包来减少打包体积。比如lodash-es替换lodash")]),a._v(" "),e("h3",{attrs:{id:"_14-hash-contenthash-chunkhash区别-都是hash策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-hash-contenthash-chunkhash区别-都是hash策略"}},[a._v("#")]),a._v(" 14.hash，contentHash，chunkHash区别？(都是hash策略)")]),a._v(" "),e("p",[a._v("=》一般服务器都会对前端资源设置静态资源缓存，需要通过合理的hash策略来使性能达到最佳\n通过文件名+文件哈希值的方式判断资源是否有更新\n只要项目有文件改变就会改变hash\ncontentHash和单位文件内容相关，指定文件发生改变才会改变\nchunkHash和打包生成的chunk相关，不同入口不同")]),a._v(" "),e("h4",{attrs:{id:"作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[a._v("#")]),a._v(" 作用")]),a._v(" "),e("p",[a._v("依赖的公共模块一般很少更改(没有更改即公共模块hash不变,不同模块用不同的hash策略)，可以利于长期缓存=》比如css用contentHash来判断")]),a._v(" "),e("h3",{attrs:{id:"_15-ast及应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-ast及应用"}},[a._v("#")]),a._v(" 15.AST及应用？")]),a._v(" "),e("p",[a._v("AST是抽象语法树的简称\n涉及ts转js sass/less转css es6转es5\n生成AST涉及词法分析(应用=>代码检查，语法高亮)和语法分析两个阶段")]),a._v(" "),e("h4",{attrs:{id:"ast核心步骤-不同的语言拥有不同的解析器-js用babel"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ast核心步骤-不同的语言拥有不同的解析器-js用babel"}},[a._v("#")]),a._v(" AST核心步骤 不同的语言拥有不同的解析器 js用babel")]),a._v(" "),e("ol",[e("li",[a._v("把代码解析成AST")]),a._v(" "),e("li",[a._v("把TS的AST转换JS的AST")]),a._v(" "),e("li",[a._v("再把AST转成代码")])]),a._v(" "),e("h3",{attrs:{id:"_16-webpack中什么是hmr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-webpack中什么是hmr"}},[a._v("#")]),a._v(" 16.webpack中什么是HMR？")]),a._v(" "),e("p",[a._v("HMR(Hot Module Replacement)热模块替换.无需刷新即可替换掉旧模块\n将修改的模块实时替换到页面上\n开启方式：")]),a._v(" "),e("ul",[e("li",[a._v("通过webpack-dev-server --hot可以开启 =>devServer替代方式是开启--watch模式+browserSync(当dist发生变更就会刷新浏览器)")]),a._v(" "),e("li",[a._v("devServer的hot设置为true，引入插件HotModuleReplacementPlugin")])]),a._v(" "),e("h4",{attrs:{id:"webpack热更新原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack热更新原理"}},[a._v("#")]),a._v(" webpack热更新原理")]),a._v(" "),e("p",[a._v("(webpack通过watch监听到文件变化，变化就重新打包)")]),a._v(" "),e("ul",[e("li",[a._v("客户端从服务端拉取最新的代码进行chunk diff(就是将本次打包的chunk与上一次进行对比)")]),a._v(" "),e("li",[a._v("WDS(Webpack-dev-server)与浏览器之间维护了一个websocket，资源发生变化WDS会向客户端推送更新，会带上本次打包生成的hash。")]),a._v(" "),e("li",[a._v("拿到hash后WDS(Webpack-dev-server)发起ajax请求来获取更改内容(文件列表和hash)。通过jsonp获取该chunk增量更新")])]),a._v(" "),e("h3",{attrs:{id:"_17-如何提升webpack构建资源的速度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-如何提升webpack构建资源的速度"}},[a._v("#")]),a._v(" 17.如何提升webpack构建资源的速度？")]),a._v(" "),e("p",[a._v("使用speed-measure-webpack-plugin可评估每个loader和plugin的执行耗时")]),a._v(" "),e("ol",[e("li",[a._v("webpack耗时最久是负责AST转换的loader，使用js性能低下，可以换成rust编写的swc-loader")]),a._v(" "),e("li",[a._v("webpack5内置缓存插件，可通过cache: {type: filesyetem}开启，将Module，chunk，moduleChunk等信息序列化到磁盘中，二次构建避免重新编译\n比如一个js文件配置了eslint，ts，babel等loader，有可能执行多次编译，开启持久化缓存，再次编译无需解析AST\nwebpack4中也可以用cache-loader对loader进行缓存，但是目前已经是@deprecated(不久的将来会取消)的状态")]),a._v(" "),e("li",[a._v("thread-loader官方推荐开启多进程的loader，可以对babel解析AST时开启多进程处理，提升编译性能")])]),a._v(" "),e("h3",{attrs:{id:"_18-webpack-rollup-vite如何加载json-image等非js资源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-webpack-rollup-vite如何加载json-image等非js资源"}},[a._v("#")]),a._v(" 18.webpack/rollup/vite如何加载json,image等非js资源？")]),a._v(" "),e("ul",[e("li",[a._v("通过loader转成模块的形式")]),a._v(" "),e("li",[a._v("比如处理css通过css-loader和style-loader。css-loader通过postcss来解析处理css中的url和@import，转成模块引入")]),a._v(" "),e("li",[a._v("再用style-loader将样式注入到dom中，原理是使用DOM提供的API去构建style标签，把css内容注入到style中")]),a._v(" "),e("li",[a._v("由于性能问题(css会在js资源加载完后加载，容易出现页面抖动，且性能低)，在生产环境我们通常需要单独加载css资源，")]),a._v(" "),e("li",[a._v("所以要借助mini-css-exact-plugin将css单独抽离出来。\n(rollup只允许通过插件的方式进行扩展)")])]),a._v(" "),e("h3",{attrs:{id:"_19-如何将js资源注入到html中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-如何将js资源注入到html中"}},[a._v("#")]),a._v(" 19.如何将js资源注入到html中？")]),a._v(" "),e("p",[a._v("原理是：当webpack生成js资源后，获取其文件名及publicPath，最后将其注入到html中。\n(可以通过html-webpack-plugin)")]),a._v(" "),e("h3",{attrs:{id:"_20-为什么可以在webpack配置文件使用path模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-为什么可以在webpack配置文件使用path模块"}},[a._v("#")]),a._v(" 20.为什么可以在webpack配置文件使用path模块？")]),a._v(" "),e("p",[a._v("因为webpack的配置文件是运行在nodejs环境中，所以可以在这个文件中使用所有nodejs的内置模块")]),a._v(" "),e("h3",{attrs:{id:"_21-mode有几种模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21-mode有几种模式"}},[a._v("#")]),a._v(" 21.mode有几种模式？")]),a._v(" "),e("p",[a._v("production,development,none=>默认production")]),a._v(" "),e("h3",{attrs:{id:"_22-vue-loader实现原理是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_22-vue-loader实现原理是什么"}},[a._v("#")]),a._v(" 22.vue-loader实现原理是什么？")]),a._v(" "),e("ul",[e("li",[a._v("vue-loader会把sfc中的内容拆分为template，script，style三个虚拟模块，分别匹配webpack配置中对于的rules，")]),a._v(" "),e("li",[a._v("比如script会匹配所有跟处理js或ts相关的loader")]),a._v(" "),e("li",[a._v("template中的内容会通过vue complier转换成render函数后合并到script虚拟模块中")]),a._v(" "),e("li",[a._v("scoped style会经过vue-loader/style-post-loader处理，成为只匹配特定元素的私有样式")])]),a._v(" "),e("h3",{attrs:{id:"_23-webpack4为什么选择了terser"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_23-webpack4为什么选择了terser"}},[a._v("#")]),a._v(" 23.webpack4为什么选择了terser?")]),a._v(" "),e("p",[a._v("因为uglify-js不支持ES6+,webpack4默认内置使用terser-webpack-plugin")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("terser开启多进程能显著加快构建速度，建议开启\nmodule.exports = {\n    optimization: {\n        minimizer: [\n            new TerserPlugin({\n                parallel: true,\n            }),\n        ],\n    },\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br")])]),e("h4",{attrs:{id:"如何自动去除console-log-可以通过terser插件的drop-console"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何自动去除console-log-可以通过terser插件的drop-console"}},[a._v("#")]),a._v(" 如何自动去除console.log=>可以通过terser插件的drop_console？")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('optimization: {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          compress: {\n            drop_console: false, // 默认false，设置为true, 则会删除所有console.* 相关的代码。\n            pure_funcs: ["console.log"], // 单纯禁用console.log\n          }\n        }\n      })\n    ]\n  }\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br")])]),e("h3",{attrs:{id:"_24-minify原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_24-minify原理"}},[a._v("#")]),a._v(" 24.minify原理？")]),a._v(" "),e("p",[a._v("先AST分析，再根据配置的策略来生成更小体积的AST，最后生成代码")]),a._v(" "),e("h4",{attrs:{id:"js文件压缩做了什么-》terser-uglifyjs做了哪些东西"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js文件压缩做了什么-》terser-uglifyjs做了哪些东西"}},[a._v("#")]),a._v(" js文件压缩做了什么 =》terser/uglifyjs做了哪些东西")]),a._v(" "),e("ul",[e("li",[a._v("去除空格，换行符，注释")]),a._v(" "),e("li",[a._v("把较长的变量名替换为短名称")]),a._v(" "),e("li",[a._v("编译预计算 let minute = 60 * 1000; let minute = 60000;")]),a._v(" "),e("li",[a._v("合并声明及布尔值简化")])]),a._v(" "),e("h4",{attrs:{id:"为什么要压缩js文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要压缩js文件"}},[a._v("#")]),a._v(" 为什么要压缩js文件？")]),a._v(" "),e("p",[a._v("减少js代码体积，提高执行速度。并且压缩后不具备可读性，防止被人轻易使用")]),a._v(" "),e("h4",{attrs:{id:"如何压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何压缩"}},[a._v("#")]),a._v(" 如何压缩")]),a._v(" "),e("ul",[e("li",[a._v("terser｜uglify等库来进行压缩")]),a._v(" "),e("li",[a._v("gzip压缩，在nginx开启")]),a._v(" "),e("li",[a._v("替换大体积的第三方库=>moment=>dayjs")]),a._v(" "),e("li",[a._v("使用支持treeShaking的库 lodash => lodash/es")]),a._v(" "),e("li",[a._v("不支持treeShaking的库，按需引入使用的模块")]),a._v(" "),e("li",[a._v("code splitting 路由懒加载")]),a._v(" "),e("li",[a._v("splitChunksPlugin 分包(需要注意避免把一个库多次引用多次打包) => 分包不能把总体积变小，但能提高加载性能")])]),a._v(" "),e("h3",{attrs:{id:"_25-webpack打包流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_25-webpack打包流程"}},[a._v("#")]),a._v(" 25.webpack打包流程？")]),a._v(" "),e("ol",[e("li",[a._v("根据配置webpack.config.js进行初始化")]),a._v(" "),e("li",[a._v("使用各种配置的loader对文件进行解析")]),a._v(" "),e("li",[a._v("生成AST语法树，根据语法树找到依赖文件，对依赖文件进行递归，直到该文件没有依赖文件为止")]),a._v(" "),e("li",[a._v("打包生成chunk")])]),a._v(" "),e("h4",{attrs:{id:"多进程打包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多进程打包"}},[a._v("#")]),a._v(" 多进程打包")]),a._v(" "),e("p",[a._v("thread-loader=>webpack运行在node环境上")]),a._v(" "),e("h3",{attrs:{id:"_26-配置时thread-loader在前还是cache-loader"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_26-配置时thread-loader在前还是cache-loader"}},[a._v("#")]),a._v(" *26.配置时thread-loader在前还是cache-loader？")]),a._v(" "),e("p",[a._v("应该是thread-loader,这样cache-loader也能使用到多进程")]),a._v(" "),e("h3",{attrs:{id:"_27-babel-loader-cache-loader缓存的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_27-babel-loader-cache-loader缓存的区别"}},[a._v("#")]),a._v(" *27.babel-loader,cache-loader缓存的区别？")]),a._v(" "),e("p",[a._v("babel-loader根据内容缓存，cache-loader根据mtime(修改时间)来缓存")]),a._v(" "),e("h3",{attrs:{id:"_28-proxy原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_28-proxy原理"}},[a._v("#")]),a._v(" 28.proxy原理？")]),a._v(" "),e("p",[a._v("webpack-dev-server本地启动一个服务器，然后与目标服务器之前进行请求不存在跨域")]),a._v(" "),e("h3",{attrs:{id:"_29-webpack生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_29-webpack生命周期"}},[a._v("#")]),a._v(" 29.webpack生命周期")]),a._v(" "),e("p",[a._v("// TODO")])])}),[],!1,null,null,null);e.default=r.exports}}]);