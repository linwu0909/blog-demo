(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{280:function(_,v,a){"use strict";a.r(v);var t=a(14),s=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#经典排序算法-数据结构"}},[_._v("经典排序算法+数据结构")]),v("ul",[v("li",[v("a",{attrs:{href:"#_1-比较类排序"}},[_._v("1.比较类排序")])]),v("li",[v("a",{attrs:{href:"#_2-非比较排序"}},[_._v("2.非比较排序")])]),v("li",[v("a",{attrs:{href:"#_3-快排实现思路"}},[_._v("3.快排实现思路")])]),v("li",[v("a",{attrs:{href:"#_4-二叉查找树-bst树"}},[_._v("4.二叉查找树(BST树)")])]),v("li",[v("a",{attrs:{href:"#_5-斐波那契数列"}},[_._v("5.斐波那契数列")])]),v("li",[v("a",{attrs:{href:"#_6-二叉树"}},[_._v("6.二叉树")])]),v("li",[v("a",{attrs:{href:"#_7-二叉堆"}},[_._v("*7.二叉堆")])]),v("li",[v("a",{attrs:{href:"#复杂度分析"}},[_._v("复杂度分析")])]),v("li",[v("a",{attrs:{href:"#_8-链表"}},[_._v("8.链表")])]),v("li",[v("a",{attrs:{href:"#_9-栈"}},[_._v("9.栈")])]),v("li",[v("a",{attrs:{href:"#_10-队列"}},[_._v("10.队列")])]),v("li",[v("a",{attrs:{href:"#_11-图的特性"}},[_._v("11.图的特性")])]),v("li",[v("a",{attrs:{href:"#_12-算法思想"}},[_._v("12.算法思想")])])])])])]),v("p"),_._v(" "),v("h2",{attrs:{id:"经典排序算法-数据结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#经典排序算法-数据结构"}},[_._v("#")]),_._v(" 经典排序算法+数据结构")]),_._v(" "),v("h3",{attrs:{id:"_1-比较类排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-比较类排序"}},[_._v("#")]),_._v(" 1.比较类排序")]),_._v(" "),v("h4",{attrs:{id:"交换排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#交换排序"}},[_._v("#")]),_._v(" 交换排序")]),_._v(" "),v("ul",[v("li",[_._v("冒泡排序：依次比较相邻两个数，前面比后面的大就交换位置。N个数字要进行N-1次排序(N-1趟就有序了)\n最好时间复杂度是O(n) 平均时间复杂度O(n^2) 稳定 空间复杂度是O(1)")]),_._v(" "),v("li",[_._v("快速排序 通常将第一个元素作为基准元素，将数组比基准元素小的放左边，大的放右边。\n再对左右两边的元素进行同样的比较，直到无法拆分为止。\n时间复杂度O(nlogn) 空间复杂度O(nlong) 不稳定")])]),_._v(" "),v("h4",{attrs:{id:"插入排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#插入排序"}},[_._v("#")]),_._v(" 插入排序")]),_._v(" "),v("ul",[v("li",[_._v("简单插入排序 先插入数组中第一个数，再次插入时在已排序的新数组中从后向前扫描比较，找到相应位置插入。\n最好O(n) 时间复杂度都是O(n^2) 稳定 空间复杂度是O(1)")]),_._v(" "),v("li",[_._v("希尔排序")])]),_._v(" "),v("h4",{attrs:{id:"选择排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[_._v("#")]),_._v(" 选择排序")]),_._v(" "),v("ul",[v("li",[_._v("简单选择排序: 找到最小的元素，放到起始位置，再从剩余元素中找到最小的元素，放到第二个位置，依次类推\n时间复杂度都是O(n^2) 不稳定 空间复杂度是O(1)")]),_._v(" "),v("li",[_._v("堆排序")])]),_._v(" "),v("h3",{attrs:{id:"_2-非比较排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-非比较排序"}},[_._v("#")]),_._v(" 2.非比较排序")]),_._v(" "),v("p",[_._v("计数排序、桶排序、基数排序")]),_._v(" "),v("ul",[v("li",[_._v("稳定性：a原本在b前面，a==b，排序之后ab顺序改变为不稳定，否则为稳定")]),_._v(" "),v("li",[_._v("时间复杂度：总的操作次数")]),_._v(" "),v("li",[_._v("空间复杂度：算法执行所需的空间大小")])]),_._v(" "),v("h4",{attrs:{id:"平均时间复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#平均时间复杂度"}},[_._v("#")]),_._v(" 平均时间复杂度：")]),_._v(" "),v("ul",[v("li",[_._v("O(n^2) 插入排序 选择排序 冒泡排序")]),_._v(" "),v("li",[_._v("O(nlog2n) 堆排序 归并排序")]),_._v(" "),v("li",[_._v("O(nlogn) 快速排序")])]),_._v(" "),v("h4",{attrs:{id:"空间复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[_._v("#")]),_._v(" 空间复杂度：")]),_._v(" "),v("ul",[v("li",[_._v("O(1) 插入排序 希尔排序 选择排序 堆排序 冒泡排序")]),_._v(" "),v("li",[_._v("O(logn) 快速排序")]),_._v(" "),v("li",[_._v("O(n) 归并排序")])]),_._v(" "),v("h5",{attrs:{id:"稳定性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#稳定性"}},[_._v("#")]),_._v(" 稳定性：")]),_._v(" "),v("ul",[v("li",[_._v("稳定：插入排序 冒泡排序 归并排序 非比较排序都稳定")]),_._v(" "),v("li",[_._v("不稳定：希尔排序 选择排序 堆排序 快速排序")])]),_._v(" "),v("h3",{attrs:{id:"_3-快排实现思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-快排实现思路"}},[_._v("#")]),_._v(" 3.快排实现思路")]),_._v(" "),v("ul",[v("li",[_._v("通常将第一个元素作为基准元素，将数组比基准元素小的放左边，大的放右边。")]),_._v(" "),v("li",[_._v("再对左右两边的元素进行同样的比较，直到无法拆分为止。")])]),_._v(" "),v("h3",{attrs:{id:"_4-二叉查找树-bst树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-二叉查找树-bst树"}},[_._v("#")]),_._v(" 4.二叉查找树(BST树)")]),_._v(" "),v("ul",[v("li",[_._v("又称二叉搜索树。每个节点左子节点小于该节点，右子节点大于等于该节点")]),_._v(" "),v("li",[_._v("最小值是树最左端的节点，最大值是树最右端的节点")])]),_._v(" "),v("h4",{attrs:{id:"常见查找算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见查找算法"}},[_._v("#")]),_._v(" 常见查找算法")]),_._v(" "),v("ul",[v("li",[_._v("顺序查找：也称线性查找，是最低效的查找算法。时间复杂度O(n) 空间复杂度O(1)")]),_._v(" "),v("li",[_._v("二分查找：也称折半查找，要求待查找数组已排序。选择中间数，查找数比中间数小去左边子数组找，比中间数大去右边子数组找，以此类推。")]),_._v(" "),v("li",[_._v("时间复杂度是O(logn) 空间复杂度O(1)")])]),_._v(" "),v("h3",{attrs:{id:"_5-斐波那契数列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-斐波那契数列"}},[_._v("#")]),_._v(" 5.斐波那契数列")]),_._v(" "),v("p",[_._v("0,1,1,2,3,5,8...")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("function fib(n) {\nif (n < 2 && n >= 0) return n\nreturn fib(n - 1) + fib(n - 2)\n}\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br")])]),v("h3",{attrs:{id:"_6-二叉树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-二叉树"}},[_._v("#")]),_._v(" 6.二叉树")]),_._v(" "),v("ul",[v("li",[_._v("二叉树每个节点最多有两个节点，分别是左节点，右节点。仅有一个根节点，节点间不能闭环(普通树可以有多个子节点)")]),_._v(" "),v("li",[_._v("当一颗二叉树的叶子节点数量满时，就是满二叉树")]),_._v(" "),v("li",[_._v("二叉查找树(二叉搜索树BST)特点是根节点都比左节点大，比右节点小")]),_._v(" "),v("li",[_._v("平衡二叉树(AVL)：左右子树的高度差不能大于1")]),_._v(" "),v("li",[_._v("先序遍历中左右、中序遍历左中右、后序遍历左右中")])]),_._v(" "),v("h3",{attrs:{id:"_7-二叉堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-二叉堆"}},[_._v("#")]),_._v(" *7.二叉堆")]),_._v(" "),v("ul",[v("li",[_._v("堆是一个完全二叉树")]),_._v(" "),v("li",[_._v("任意节点小于或大于它的所有子节点")]),_._v(" "),v("li",[_._v("堆总是一颗完全树，除了最底层，其他层的节点都被元素填满，且最底层从左到右填入")]),_._v(" "),v("li",[_._v("根节点最大的堆是大根堆，最小的堆是小根堆")])]),_._v(" "),v("h3",{attrs:{id:"复杂度分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析"}},[_._v("#")]),_._v(" 复杂度分析")]),_._v(" "),v("ul",[v("li",[_._v("时间复杂度：衡量代码执行的时间,取最大的为其时间复杂度(并不是真正的代码执行的时间。而是表示时间随数据规模增加的趋势)")]),_._v(" "),v("li",[_._v("空间复杂度：执行过程临时占用的存储空间大小(表示空间随数据规模增加的趋势。原地算法就是不用多余的空间O(1))")])]),_._v(" "),v("h4",{attrs:{id:"常见复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见复杂度"}},[_._v("#")]),_._v(" 常见复杂度")]),_._v(" "),v("ul",[v("li",[_._v("O(1) 原地算法")]),_._v(" "),v("li",[_._v("O(logn) 二分查找")]),_._v(" "),v("li",[_._v("O(n) 常数for循环(1个，2个for循环，非嵌套)")]),_._v(" "),v("li",[_._v("O(n^2) 嵌套for循环，如冒泡排序")])]),_._v(" "),v("h3",{attrs:{id:"_8-链表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-链表"}},[_._v("#")]),_._v(" 8.链表")]),_._v(" "),v("p",[_._v("单链表：只有一个方向，从头节点到尾节点")]),_._v(" "),v("ul",[v("li",[_._v("追加节点：初始化节点，遍历到链尾，链尾元素的next指向该节点=》当链表为null，直接将head指向该节点即可")]),_._v(" "),v("li",[_._v("查找：遍历单链表，判断节点值是否等于查找值，等于返回true，否则继续遍历，遍历完都没有返回false=》链表为null返回false")]),_._v(" "),v("li",[_._v("在position位置插入：初始化一个节点，遍历到position前一个节点，在该节点后插入节点")]),_._v(" "),v("li",[_._v("删除：遍历单链表，找到待删除节点，删除")]),_._v(" "),v("li",[_._v("复杂度：从头开始查找，复杂度是O(n) 插入或删除在某个节点后插入或删除的时间复杂度都是O(1)\n双链表：有两个方向，从头节点到尾节点，从尾节点到头节点")]),_._v(" "),v("li",[_._v("在position位置插入：初始化一个节点，遍历链表到position前一个节点，在该节点后插入节点")]),_._v(" "),v("li",[_._v("删除：遍历双链表，找到待删除节点，删除")]),_._v(" "),v("li",[_._v("查找：同单链表")]),_._v(" "),v("li",[_._v("复杂度：查找前驱后后继节点的时间复杂度都是O(1)，其他节点是O(n)\n插入或删除：插入或删除前驱或后继节点的时间复杂度都是O(1)\n循环单链表：链尾的next指向头节点")])]),_._v(" "),v("h3",{attrs:{id:"_9-栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-栈"}},[_._v("#")]),_._v(" 9.栈")]),_._v(" "),v("ul",[v("li",[_._v("栈是后进先出(LIFO/Last In First Out)")]),_._v(" "),v("li",[_._v("查找：从栈头开始查找，时间复杂度是O(n)")]),_._v(" "),v("li",[_._v("插入和删除：时间复杂度是O(1)\n*调用栈又称执行上下文栈，用来管理函数执行上下文的栈结构。")])]),_._v(" "),v("h3",{attrs:{id:"_10-队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-队列"}},[_._v("#")]),_._v(" 10.队列")]),_._v(" "),v("ul",[v("li",[_._v("队列是先进先出(FIFO/First In First Out)")]),_._v(" "),v("li",[_._v("特有方法有enqueue进队，dequeue出队，front获取队头元素")]),_._v(" "),v("li",[_._v("查找：从对头开始查找，时间复杂度是O(n)")]),_._v(" "),v("li",[_._v("插入和删除：时间复杂度是O(1)")]),_._v(" "),v("li",[_._v("双端队列(Deque):队头和队尾都可以进队和出队")]),_._v(" "),v("li",[_._v("滑动窗口：滑动窗口就是运行在一个大数组上的子列表")])]),_._v(" "),v("h3",{attrs:{id:"_11-图的特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-图的特性"}},[_._v("#")]),_._v(" 11.图的特性")]),_._v(" "),v("ul",[v("li",[_._v("图的每个节点可以连接0或多个元素，两点相连的是边，节点也被称作顶点。一个顶点的度是指与该顶点相连的边的条数")]),_._v(" "),v("li",[_._v("如果所有的边都有方向就是有向图，否则就是无向图。")]),_._v(" "),v("li",[_._v("顶点的边可以从自己出发再连接回自己，这样的图就是自环，没有环的图就是无环图=》无环无向的图也被称作树")]),_._v(" "),v("li",[_._v("从任一节点出发沿着各条边可以访问图中任意节点的图是连通图")]),_._v(" "),v("li",[_._v("当一个图中两两不同的顶点之间都有一条边相连，这样的图就是完全图。每个顶点都有图的顶点-1条边=》n个顶点每个顶点都有n-1条边")]),_._v(" "),v("li",[_._v("图中很少顶点互相相连是稀疏图，否则是稠密图")])]),_._v(" "),v("h3",{attrs:{id:"_12-算法思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-算法思想"}},[_._v("#")]),_._v(" 12.算法思想")]),_._v(" "),v("ol",[v("li",[_._v("递归：适用斐波那契数列，回溯，数的遍历，图的搜索")]),_._v(" "),v("li",[_._v("分治：分而治之。适用快速排序，归并排序，二分查找")]),_._v(" "),v("li",[_._v("贪心：期望通过局部最优选择获取整体最优选择。")]),_._v(" "),v("li",[_._v("回溯：试探法，每一步作出选择，发现无法获取期望结果就回溯回去重新选择。适用于深度优先遍历，全排列")]),_._v(" "),v("li",[_._v("动态规划：将复杂问题分解成小问题，与分治不同的是它要求问题之间是关联的，不是独立的。适用于求最优解，爬楼梯，硬币找零，最长公共子序列")]),_._v(" "),v("li",[_._v("枚举算法：将问题的所有答案一一列举，再根据条件判断答案是否符合，保留符合抛弃不符合")])])])}),[],!1,null,null,null);v.default=s.exports}}]);