<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶之路</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/icon.png">
    <meta name="description" content="linwu0909个人站点">
    
    <link rel="preload" href="/assets/css/0.styles.d6ad21ed.css" as="style"><link rel="preload" href="/assets/js/app.a4ba95f7.js" as="script"><link rel="preload" href="/assets/js/2.67e62386.js" as="script"><link rel="preload" href="/assets/js/25.9c781b1b.js" as="script"><link rel="prefetch" href="/assets/js/10.a509ebb0.js"><link rel="prefetch" href="/assets/js/11.f6c7ea4e.js"><link rel="prefetch" href="/assets/js/12.d41f06f2.js"><link rel="prefetch" href="/assets/js/13.c3e870d4.js"><link rel="prefetch" href="/assets/js/14.30322894.js"><link rel="prefetch" href="/assets/js/15.86aa2619.js"><link rel="prefetch" href="/assets/js/16.c3bf8266.js"><link rel="prefetch" href="/assets/js/17.558a6e40.js"><link rel="prefetch" href="/assets/js/18.7260607d.js"><link rel="prefetch" href="/assets/js/19.610728e5.js"><link rel="prefetch" href="/assets/js/20.9a25090f.js"><link rel="prefetch" href="/assets/js/21.8265851e.js"><link rel="prefetch" href="/assets/js/22.07a30c30.js"><link rel="prefetch" href="/assets/js/23.0bd65a47.js"><link rel="prefetch" href="/assets/js/24.484698e4.js"><link rel="prefetch" href="/assets/js/26.78631bc5.js"><link rel="prefetch" href="/assets/js/27.eafd817a.js"><link rel="prefetch" href="/assets/js/3.758fc587.js"><link rel="prefetch" href="/assets/js/4.8afd5cf5.js"><link rel="prefetch" href="/assets/js/5.4f1a5aca.js"><link rel="prefetch" href="/assets/js/6.cc47db6f.js"><link rel="prefetch" href="/assets/js/7.64d96c12.js"><link rel="prefetch" href="/assets/js/8.64e93bc9.js"><link rel="prefetch" href="/assets/js/9.ae8eb319.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d6ad21ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端进阶之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端综合" class="dropdown-title"><span class="title">前端综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端综合" class="mobile-dropdown-title"><span class="title">前端综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front/html.html" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front/js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/front/es6.html" class="nav-link">
  ES6+
</a></li><li class="dropdown-item"><!----> <a href="/front/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/node/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构和算法" class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据结构和算法" class="mobile-dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/base.html" class="nav-link">
  经典排序算法+数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/leetCode100.html" class="nav-link">
  LeetCode100
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/handWrite.html" class="nav-link">
  手写各种实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工程化" class="dropdown-title"><span class="title">前端工程化</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端工程化" class="mobile-dropdown-title"><span class="title">前端工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/engineer/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/engineer/webpack.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/engineer/pack.html" class="nav-link">
  Gulp
</a></li></ul></div></div> <a href="https://github.com/linwu0909" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端综合" class="dropdown-title"><span class="title">前端综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端综合" class="mobile-dropdown-title"><span class="title">前端综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front/html.html" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front/js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/front/es6.html" class="nav-link">
  ES6+
</a></li><li class="dropdown-item"><!----> <a href="/front/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/node/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构和算法" class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据结构和算法" class="mobile-dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/base.html" class="nav-link">
  经典排序算法+数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/leetCode100.html" class="nav-link">
  LeetCode100
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/handWrite.html" class="nav-link">
  手写各种实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工程化" class="dropdown-title"><span class="title">前端工程化</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端工程化" class="mobile-dropdown-title"><span class="title">前端工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/engineer/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/engineer/webpack.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/engineer/pack.html" class="nav-link">
  Gulp
</a></li></ul></div></div> <a href="https://github.com/linwu0909" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/node/#node" class="sidebar-link">Node</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/node/#_1-node引入模块的过程是什么-来自深入浅出nodejs" class="sidebar-link">1.node引入模块的过程是什么？(来自深入浅出nodejs)</a></li><li class="sidebar-sub-header"><a href="/node/#_2-nodejs有哪些全局对象" class="sidebar-link">2.nodejs有哪些全局对象？</a></li><li class="sidebar-sub-header"><a href="/node/#_3-process常用方法" class="sidebar-link">3.process常用方法？</a></li><li class="sidebar-sub-header"><a href="/node/#_4-nodejs的事件循环" class="sidebar-link">4.nodejs的事件循环?</a></li><li class="sidebar-sub-header"><a href="/node/#_5-有使用过buffer吗" class="sidebar-link">5.有使用过buffer吗?</a></li><li class="sidebar-sub-header"><a href="/node/#_6-nodejs同步和异步怎么理解" class="sidebar-link">6.nodejs同步和异步怎么理解？</a></li><li class="sidebar-sub-header"><a href="/node/#_7-如何防止程序奔溃" class="sidebar-link">7.如何防止程序奔溃？</a></li><li class="sidebar-sub-header"><a href="/node/#_8-怎么调试nodejs" class="sidebar-link">8.怎么调试nodejs？</a></li><li class="sidebar-sub-header"><a href="/node/#_9-node网络模块有哪些" class="sidebar-link">9.node网络模块有哪些?</a></li><li class="sidebar-sub-header"><a href="/node/#_10-npm作用" class="sidebar-link">10.npm作用？</a></li><li class="sidebar-sub-header"><a href="/node/#_11-nodejs导入模块和导入js文件有什么区别" class="sidebar-link">11.nodejs导入模块和导入js文件有什么区别?</a></li><li class="sidebar-sub-header"><a href="/node/#_12-有使用过stream流吗" class="sidebar-link">12.有使用过stream流吗?</a></li><li class="sidebar-sub-header"><a href="/node/#_13-fs模块常用" class="sidebar-link">13.fs模块常用?</a></li><li class="sidebar-sub-header"><a href="/node/#_14-nodejs优缺点" class="sidebar-link">14.nodejs优缺点？</a></li><li class="sidebar-sub-header"><a href="/node/#_15-nodejs模块加载和使用规则是什么-》cjs" class="sidebar-link">15.nodejs模块加载和使用规则是什么？=》cjs</a></li><li class="sidebar-sub-header"><a href="/node/#_16-常见npm命令" class="sidebar-link">16.常见npm命令？</a></li><li class="sidebar-sub-header"><a href="/node/#_17-什么是前后端分离" class="sidebar-link">17.什么是前后端分离？</a></li><li class="sidebar-sub-header"><a href="/node/#_18-v8垃圾回收机制-v8限制64位机器内存最大约1-4g-32机器0-7g。node-v14版本的内存为2g-v8自身是用c-》完整" class="sidebar-link">18.v8垃圾回收机制(v8限制64位机器内存最大约1.4G,32机器0.7G。node v14版本的内存为2G，V8自身是用C++)=》完整</a></li><li class="sidebar-sub-header"><a href="/node/#内存分配机制" class="sidebar-link">内存分配机制？</a></li><li class="sidebar-sub-header"><a href="/node/#_19-express和koa区别" class="sidebar-link">19.express和koa区别？</a></li><li class="sidebar-sub-header"><a href="/node/#_20-ts和js区别及优缺点" class="sidebar-link">20.ts和js区别及优缺点？</a></li><li class="sidebar-sub-header"><a href="/node/#_21-node是单线程单进程如何高效利用多核cpu" class="sidebar-link">21.node是单线程单进程如何高效利用多核CPU？</a></li><li class="sidebar-sub-header"><a href="/node/#_22-什么是ipc" class="sidebar-link">22.什么是IPC？</a></li><li class="sidebar-sub-header"><a href="/node/#_23-大文件上传和断点续传如何实现" class="sidebar-link">23.大文件上传和断点续传如何实现？</a></li><li class="sidebar-sub-header"><a href="/node/#_24-ts中const和readonly区别" class="sidebar-link">24.ts中const和readonly区别？</a></li><li class="sidebar-sub-header"><a href="/node/#_25-ts中的this和js中的this有什么区别" class="sidebar-link">25.ts中的this和js中的this有什么区别？</a></li><li class="sidebar-sub-header"><a href="/node/#_26-nodejs和js区别是什么" class="sidebar-link">26.nodejs和js区别是什么？</a></li><li class="sidebar-sub-header"><a href="/node/#_27-npm-i与npm-ci的区别是什么" class="sidebar-link">27.npm i与npm ci的区别是什么？</a></li><li class="sidebar-sub-header"><a href="/node/#_28-node中循环引用会发生什么" class="sidebar-link">28.node中循环引用会发生什么？</a></li><li class="sidebar-sub-header"><a href="/node/#_29-v8如何执行js代码" class="sidebar-link">29.v8如何执行js代码？</a></li><li class="sidebar-sub-header"><a href="/node/#_30-node中如何读取可读流的内容" class="sidebar-link">30.node中如何读取可读流的内容？</a></li><li class="sidebar-sub-header"><a href="/node/#_31-如何读取大文件内容" class="sidebar-link">31.如何读取大文件内容？</a></li><li class="sidebar-sub-header"><a href="/node/#_32-如何查看文件状态-文件最后修改时间" class="sidebar-link">32.如何查看文件状态/文件最后修改时间？</a></li><li class="sidebar-sub-header"><a href="/node/#_33-说说对bff" class="sidebar-link">33.说说对BFF？</a></li><li class="sidebar-sub-header"><a href="/node/#_34-koa-router实现原理" class="sidebar-link">34.koa-router实现原理？</a></li><li class="sidebar-sub-header"><a href="/node/#_35-node如何调用c" class="sidebar-link">35.node如何调用c++？</a></li><li class="sidebar-sub-header"><a href="/node/#_36-什么是中间件-举例" class="sidebar-link">36.什么是中间件-举例？</a></li><li class="sidebar-sub-header"><a href="/node/#_37-fs-extra有使用过吗" class="sidebar-link">37.fs-extra有使用过吗？</a></li><li class="sidebar-sub-header"><a href="/node/#_38-如何监控文件的变动" class="sidebar-link">38.如何监控文件的变动？</a></li><li class="sidebar-sub-header"><a href="/node/#_39-node-max-old-space-size-4096什么意思" class="sidebar-link">39.node --max-old-space-size=4096什么意思？</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#node">Node</a><ul><li><a href="#_1-node引入模块的过程是什么-来自深入浅出nodejs">1.node引入模块的过程是什么？(来自深入浅出nodejs)</a></li><li><a href="#_2-nodejs有哪些全局对象">2.nodejs有哪些全局对象？</a></li><li><a href="#_3-process常用方法">3.process常用方法？</a></li><li><a href="#_4-nodejs的事件循环">4.nodejs的事件循环?</a></li><li><a href="#_5-有使用过buffer吗">5.有使用过buffer吗?</a></li><li><a href="#_6-nodejs同步和异步怎么理解">6.nodejs同步和异步怎么理解？</a></li><li><a href="#_7-如何防止程序奔溃">7.如何防止程序奔溃？</a></li><li><a href="#_8-怎么调试nodejs">8.怎么调试nodejs？</a></li><li><a href="#_9-node网络模块有哪些">9.node网络模块有哪些?</a></li><li><a href="#_10-npm作用">10.npm作用？</a></li><li><a href="#_11-nodejs导入模块和导入js文件有什么区别">11.nodejs导入模块和导入js文件有什么区别?</a></li><li><a href="#_12-有使用过stream流吗">12.有使用过stream流吗?</a></li><li><a href="#_13-fs模块常用">13.fs模块常用?</a></li><li><a href="#_14-nodejs优缺点">14.nodejs优缺点？</a></li><li><a href="#_15-nodejs模块加载和使用规则是什么-》cjs">15.nodejs模块加载和使用规则是什么？=》cjs</a></li><li><a href="#_16-常见npm命令">16.常见npm命令？</a></li><li><a href="#_17-什么是前后端分离">17.什么是前后端分离？</a></li><li><a href="#_18-v8垃圾回收机制-v8限制64位机器内存最大约1-4g-32机器0-7g。node-v14版本的内存为2g-v8自身是用c-》完整">18.v8垃圾回收机制(v8限制64位机器内存最大约1.4G,32机器0.7G。node v14版本的内存为2G，V8自身是用C++)=》完整</a></li><li><a href="#内存分配机制">内存分配机制？</a></li><li><a href="#_19-express和koa区别">19.express和koa区别？</a></li><li><a href="#_20-ts和js区别及优缺点">20.ts和js区别及优缺点？</a></li><li><a href="#_21-node是单线程单进程如何高效利用多核cpu">21.node是单线程单进程如何高效利用多核CPU？</a></li><li><a href="#_22-什么是ipc">22.什么是IPC？</a></li><li><a href="#_23-大文件上传和断点续传如何实现">23.大文件上传和断点续传如何实现？</a></li><li><a href="#_24-ts中const和readonly区别">24.ts中const和readonly区别？</a></li><li><a href="#_25-ts中的this和js中的this有什么区别">25.ts中的this和js中的this有什么区别？</a></li><li><a href="#_26-nodejs和js区别是什么">26.nodejs和js区别是什么？</a></li><li><a href="#_27-npm-i与npm-ci的区别是什么">27.npm i与npm ci的区别是什么？</a></li><li><a href="#_28-node中循环引用会发生什么">28.node中循环引用会发生什么？</a></li><li><a href="#_29-v8如何执行js代码">29.v8如何执行js代码？</a></li><li><a href="#_30-node中如何读取可读流的内容">30.node中如何读取可读流的内容？</a></li><li><a href="#_31-如何读取大文件内容">31.如何读取大文件内容？</a></li><li><a href="#_32-如何查看文件状态-文件最后修改时间">32.如何查看文件状态/文件最后修改时间？</a></li><li><a href="#_33-说说对bff">33.说说对BFF？</a></li><li><a href="#_34-koa-router实现原理">34.koa-router实现原理？</a></li><li><a href="#_35-node如何调用c">35.node如何调用c++？</a></li><li><a href="#_36-什么是中间件-举例">36.什么是中间件-举例？</a></li><li><a href="#_37-fs-extra有使用过吗">37.fs-extra有使用过吗？</a></li><li><a href="#_38-如何监控文件的变动">38.如何监控文件的变动？</a></li><li><a href="#_39-node-max-old-space-size-4096什么意思">39.node --max-old-space-size=4096什么意思？</a></li></ul></li></ul></div><p></p> <h2 id="node"><a href="#node" class="header-anchor">#</a> Node</h2> <h3 id="_1-node引入模块的过程是什么-来自深入浅出nodejs"><a href="#_1-node引入模块的过程是什么-来自深入浅出nodejs" class="header-anchor">#</a> 1.node引入模块的过程是什么？(来自深入浅出nodejs)</h3> <p>路径分析(分析是node的核心模块，如http，还是文件路径或者是第三方依赖)
-&gt;文件定位(后缀优先级js&gt;json&gt;node)
-&gt;编译执行</p> <ul><li>node会对引入过的模块进行缓存，缓存的是编译执行后的对象。从缓存加载不需要这三步。</li> <li>node模块分为两类：node提供的核心模块，用户编写的文件模块。</li> <li>核心模块加载速度比文件模块快(因为有部分模块在node进程启动时就被直接加载进内存，这部分文件不需要再进行文件定位和编译执行)。</li></ul> <h3 id="_2-nodejs有哪些全局对象"><a href="#_2-nodejs有哪些全局对象" class="header-anchor">#</a> 2.nodejs有哪些全局对象？</h3> <p>global,process,console,module,export</p> <h3 id="_3-process常用方法"><a href="#_3-process常用方法" class="header-anchor">#</a> 3.process常用方法？</h3> <p>process.env process.argv process.exit</p> <h3 id="_4-nodejs的事件循环"><a href="#_4-nodejs的事件循环" class="header-anchor">#</a> 4.nodejs的事件循环?</h3> <p>(执行中是IO事件，setImmediate在当前队列中立即执行，setTimeout/setInterval把执行定时到下一个队列
process.nextTick在当前队列执行完,下次遍历前执行)</p> <ul><li><p>顺序：IO事件-&gt;setImmediate-&gt;setTimeout/setInterval-&gt;process.nextTick</p></li> <li><p>总共是6个阶段，</p></li> <li><p>从poll开始，这个阶段会检查是否有io事件，执行io相关回调</p></li> <li><p>到check阶段，这个阶段会执行setImediate的回调</p></li> <li><p>到close callback 这个阶段执行关闭的回调函数</p></li> <li><p>到timer 这个阶段会执行setTimeout和setInterval的回调</p></li> <li><p>到pending callback这个阶段执行之前延迟的回调</p></li> <li><p>到idle,prepare阶段，这个是node系统内部使用的</p></li> <li><p>回到poll开始新的循环。算是一次Tick</p></li> <li><p>setTimeout/setInterval 属于定时器阶段(timer) poll控制timer何时执行</p></li> <li><p>setImmediate属于check阶段</p></li> <li><p>nextTick会优先setImmediate和setTimeout</p></li> <li><p>timer(定时器)：执行setTimeout和setInterval的回调
=&gt;pending callback(待定的回调)
=&gt;idle,prepare(仅系统内部使用)
=&gt;poll(轮询)：检查新的io事件，执行与IO相关的回调
=&gt;check(检测) 执行setImmediate的回调
=&gt;close callback(关闭的回调函数) 关闭的回调函数
(微任务会在每个阶段执行完立即执行)</p></li></ul> <h3 id="_5-有使用过buffer吗"><a href="#_5-有使用过buffer吗" class="header-anchor">#</a> 5.有使用过buffer吗?</h3> <p>buffer主要处理二进制数据，在文件上传有用到。=》支持for...of
(引入typedArray之前，js没有读取获操作二进制数据的机制，typeArray用来实现Uint8Array=》8位无符号整型数组，typedArray是统称)
buffer实例类似整型数组，但buffer的大小是固定的无法改变(V8堆外分配内存)，全局变量不需要require</p> <h4 id="常用api"><a href="#常用api" class="header-anchor">#</a> 常用api</h4> <ul><li>Buffer.concat(list,[length])返回一个合并了list中所有buffer的新buffer</li> <li>Buffer.from(array)使用数组创建buffer</li> <li>Buffer.alloc(size)创建一个buffer空间</li> <li>Buffer.isBuffer(obj)判断是否是buffer</li></ul> <h3 id="_6-nodejs同步和异步怎么理解"><a href="#_6-nodejs同步和异步怎么理解" class="header-anchor">#</a> 6.nodejs同步和异步怎么理解？</h3> <ul><li>同步会阻塞IO，所以一般只在项目启动时使用，用来加载配置文件，初始化各种中间件。</li> <li>异步是通过一次次循环事件队列来实现</li></ul> <h3 id="_7-如何防止程序奔溃"><a href="#_7-如何防止程序奔溃" class="header-anchor">#</a> 7.如何防止程序奔溃？</h3> <p>通过try catch捕获异常(可以设置一个全局异常处理器，捕获程序抛出的异常,捕获到把异常打印到控制台)</p> <h3 id="_8-怎么调试nodejs"><a href="#_8-怎么调试nodejs" class="header-anchor">#</a> 8.怎么调试nodejs？</h3> <p>node-- debug 文件名</p> <h3 id="_9-node网络模块有哪些"><a href="#_9-node网络模块有哪些" class="header-anchor">#</a> 9.node网络模块有哪些?</h3> <p>常用HTTP</p> <h3 id="_10-npm作用"><a href="#_10-npm作用" class="header-anchor">#</a> 10.npm作用？</h3> <p>是包管理器，可以管理项目的依赖及依赖版本号</p> <h3 id="_11-nodejs导入模块和导入js文件有什么区别"><a href="#_11-nodejs导入模块和导入js文件有什么区别" class="header-anchor">#</a> 11.nodejs导入模块和导入js文件有什么区别?</h3> <p>导入模块按名称导入，导入文件按路径导入</p> <h3 id="_12-有使用过stream流吗"><a href="#_12-有使用过stream流吗" class="header-anchor">#</a> 12.有使用过stream流吗?</h3> <p>主要用在读写文件。=》流可读，可写，或者可读可写
=》fs.createReadStream('a.txt') fs.createWriteStream('a.txt')</p> <h4 id="buffer和stream之间如何转换"><a href="#buffer和stream之间如何转换" class="header-anchor">#</a> buffer和stream之间如何转换？</h4> <p>=》stream to buffer
通过stream.on(data, data=&gt;buffer.push(data))把每个buffer插入buffers数组，然后再通过buffer.concat把这些buffer组合到一起
=》buffer to stream
可以通过duplex(可读可写流)把缓存push到stream中
let stream = new Duplex() stream.push(buffer)</p> <h4 id="buffer和stream区别"><a href="#buffer和stream区别" class="header-anchor">#</a> buffer和stream区别？</h4> <p>buffer是取完数据一次性操作，stream是边取边操作</p> <h3 id="_13-fs模块常用"><a href="#_13-fs模块常用" class="header-anchor">#</a> 13.fs模块常用?</h3> <ul><li>文件流 fs.createReadStream('a.txt') fs.createWriteStream('a.txt')</li> <li>同步文件读写 fs.readFileSync() fs.writeFileSync()</li> <li>异步文件读写 fs.readFile() fs.writeFile()</li></ul> <h3 id="_14-nodejs优缺点"><a href="#_14-nodejs优缺点" class="header-anchor">#</a> 14.nodejs优缺点？</h3> <ul><li>非阻塞IO，适合IO密集型的场景(CPU密集型给node主要挑战是：如果有长时间的计算将导致CPU时间片不能释放，使后续IO无法发起。IO阻塞的性能浪费远比CPU小)</li> <li>单进程，单线程。不用担心锁和线程同步的问题(js部分是单线程，但是底层IO操作用到了libuv，这块不是单线程)
(缺点：一旦一个地方崩溃，整个系统都崩溃)
*node跨平台是通过libuv库，事件循环也是这个库实现的</li></ul> <h3 id="_15-nodejs模块加载和使用规则是什么-》cjs"><a href="#_15-nodejs模块加载和使用规则是什么-》cjs" class="header-anchor">#</a> 15.nodejs模块加载和使用规则是什么？=》cjs</h3> <ul><li>遵循commonjs规范，使用require加载文件 使用exports/module.export导出文件 =》cjs不能直接在浏览器使用</li> <li>commonjs主要为nodejs设计，早期浏览器使用的规范是amd=》commonjs是同步的，amd是异步的</li> <li>amd代表库是require.js,早期commonjs代表库是sea.js，由淘宝玉伯开发
=》现在统一为nodejs遵循commonjs规范，浏览器遵循esm规范(es6才有的)</li></ul> <h4 id="exports和module-export区别"><a href="#exports和module-export区别" class="header-anchor">#</a> exports和module.export区别</h4> <p>本质无区别,最终暴露的都是module.export。但不能直接对exports赋值，没有任何效果</p> <h4 id="amd和cmd区别"><a href="#amd和cmd区别" class="header-anchor">#</a> amd和cmd区别</h4> <ul><li>amd加载完模块会立马执行。cmd加载完没有立即执行，等遇到require才执行。</li> <li>amd是异步引入模块，cmd是同步引入模块</li></ul> <h4 id="umd"><a href="#umd" class="header-anchor">#</a> umd</h4> <ul><li>umd兼容cjs和esm=》以amd为基础，加了特殊处理去兼容cjs</li> <li>umd和esm前后端通用</li></ul> <h4 id="cjs-commonjs-和esm-es-module-区别"><a href="#cjs-commonjs-和esm-es-module-区别" class="header-anchor">#</a> cjs(commonjs)和esm(es module)区别？</h4> <ul><li>cjs是module.export导出，require导入，esm是export导出，import</li> <li>cjs是动态导入，esm是静态导入支持tree shaking</li> <li>cjs是被加载时运行，esm是编译时候运行。</li> <li>cjs输出的是值的浅拷贝，esm输出值的引用((输出值拷贝，输出后改变值，输出值不变。输出值引用会变)</li> <li>cjs会缓存，第一次被加载会完整运行整个文件并输出一个对象，拷贝在内存中，下次加载文件，直接去内存中取</li></ul> <h3 id="_16-常见npm命令"><a href="#_16-常见npm命令" class="header-anchor">#</a> 16.常见npm命令？</h3> <p>npm install | npm uninstall | npm init | npm config set</p> <h3 id="_17-什么是前后端分离"><a href="#_17-什么是前后端分离" class="header-anchor">#</a> 17.什么是前后端分离？</h3> <p>前端通过ajax调用后端提供的接口进行数据交互</p> <h3 id="_18-v8垃圾回收机制-v8限制64位机器内存最大约1-4g-32机器0-7g。node-v14版本的内存为2g-v8自身是用c-》完整"><a href="#_18-v8垃圾回收机制-v8限制64位机器内存最大约1-4g-32机器0-7g。node-v14版本的内存为2g-v8自身是用c-》完整" class="header-anchor">#</a> 18.v8垃圾回收机制(v8限制64位机器内存最大约1.4G,32机器0.7G。node v14版本的内存为2G，V8自身是用C++)=》完整</h3> <p>(64位新生代空间64M,老生代1400MB 32位新生代空间32M,老生代700M)</p> <ul><li>实际应用中，对象生命周期长短不一，不同算法只能针对特定情况具有最好的效果，所以V8采用分代式垃圾回收。</li> <li>分代式垃圾回收机制，将内存区分成老年代和新生代。(新生代内存占用小可以用复制的方式，老生代内存占用大不能用)</li> <li>新生代中存放的是生存时间短的对象，老生代中存放的是生存时间长的对象。</li> <li>新生代回收使用scavenge算法(牺牲空间换时间，具体实现采用了cheney算法):通过将存活对象在两个semiSpace空间中复制来实现垃圾回收。</li> <li>cheney算法：它将堆内存一分为二，每个部分称为semiSpace，只有一个在使用中，使用中的是from，空闲的是to空间。</li> <li>分配对象会在from空间进行分配，回收会检查from存活的对象，非存活对象会被释放，存活对象会复制到to空间，然后清空from空间，最后from，to交换
=》拷贝和交换from，to空间主要是为了让内存空间保持连续</li> <li>scavenge算法缺点是只能使用堆内存的一半，由划分空间和复制机制决定的。但因为它只复制存活的对象，而对于生命周期短的场景来说存活对象只占少部分，所以由时间效率上的优势。</li> <li>新生代中的对象生命周期较短所以适用scavenge算法。
(scavenge算法有很大的空间开销。所以老生代不适合，会浪费大量内存)</li></ul> <h4 id="一开始都在新生代中-达到对象晋升条件后晋升为老生代"><a href="#一开始都在新生代中-达到对象晋升条件后晋升为老生代" class="header-anchor">#</a> 一开始都在新生代中，达到对象晋升条件后晋升为老生代</h4> <ol><li>对象经历过一次Scavenge回收</li> <li>To空间已经使用超过25%(To空间对象会很快移动到老年代，防止新生代的空间被耗尽)</li></ol> <h4 id="为什么是25"><a href="#为什么是25" class="header-anchor">#</a> 为什么是25%？</h4> <p>当这次scavenge回收完成后，会发生角色交换，如果占比过高，会影响后续的内存分配</p> <h4 id="老年代使用什么算法"><a href="#老年代使用什么算法" class="header-anchor">#</a> 老年代使用什么算法？</h4> <p>老年代回收使用标记清除+标记整理算法
对老年代进行一次扫描，标记存活的对象，进行第二次扫描，清除未被标记的对象
将存活对象往内存的一端移动(整理)，清除掉存活对象外的内存</p> <h4 id="老生代为什么还要用标记整理"><a href="#老生代为什么还要用标记整理" class="header-anchor">#</a> 老生代为什么还要用标记整理？</h4> <p>因为进行一次清除后，内存空间会出现不连续的情况(会对后续内存分配造成影响)。所以需要整理碎片空间(使内存空间变得连续)</p> <h4 id="全停顿问题-全停顿影响性能"><a href="#全停顿问题-全停顿影响性能" class="header-anchor">#</a> 全停顿问题(全停顿影响性能)</h4> <p>垃圾回收时需要将应用逻辑先暂停下来，等执行完垃圾回收再继续执行应用逻辑，这就是全停顿，对新生代影响较小，但对老生代影响大。
老生代引入增量标记，将标记阶段分成若干个步骤，每运行一段时间就让程序执行一会，再进行标记(主线程停顿进行垃圾回收然后继续执行主线程然后再垃圾回收)</p> <h4 id="三色标记法-黑白灰"><a href="#三色标记法-黑白灰" class="header-anchor">#</a> 三色标记法(黑白灰)：</h4> <p>黑色表示被GC ROOT引用，而且子节点已经标记完成
灰色表示被GC ROOT引用，但是子节点还没被处理
白色表示这个节点没有被访问到，如果本轮垃圾回收结束，节点还是白色，说明是垃圾数据，对应内存会被回收
增量回收是并发进行的，增量回收条件：
不能让黑色节点指向白色节点。
通常使用写屏障(Write-barrier)机制来实现这个约束条件：
当发生了黑色节点引用了白色节点的情况，写屏障会强制将被引用的白色节点变成灰色，这种方法也被称为强三色不变性</p> <h4 id="对象如何释放"><a href="#对象如何释放" class="header-anchor">#</a> 对象如何释放？</h4> <p>可达性算法。将GC ROOT对象作为起始点，向下搜索，搜索经过的路径称为引用链。当对象到起始点没有任何引用链就是不可用。
即使不可达的对象，也不是立即释放，会先进行标记，然后进行筛选，会被放进一个队列中依次进行回收
如果又有对象引用，就不会被回收。如果一个新生代对象经过多次复制后还存活，会晋升到老年代
对象From空间复制到To空间，如果To空间超过25%，也会直接晋升到老年代
(新生代用全停顿问题不大，因为新生代垃圾回收速度快)</p> <h3 id="内存分配机制"><a href="#内存分配机制" class="header-anchor">#</a> 内存分配机制？</h3> <ol><li>分配你需要的内存</li> <li>使用分配到的内存读/写</li> <li>不需要的时候释放</li> <li>(C语言可以通过代码手动分配和手动释放，即手动垃圾回收。这两个java和js都默认处理，即自动垃圾回收)</li></ol> <h3 id="_19-express和koa区别"><a href="#_19-express和koa区别" class="header-anchor">#</a> 19.express和koa区别？</h3> <ul><li>express内置了许多中间件。koa没有</li> <li>express包含路由，视图渲染等特性，koa只有http模块</li> <li>express主要通过回调实现异步函数，koa主要通过async，await的方式来处理异步</li></ul> <h3 id="_20-ts和js区别及优缺点"><a href="#_20-ts和js区别及优缺点" class="header-anchor">#</a> 20.ts和js区别及优缺点？</h3> <ul><li>ts是js的超集，有js的所有功能</li></ul> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h4> <p>ts需要编译成js才能被浏览器执行，声明类型麻烦</p> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <ul><li>ts在编译期就进行类型检查，js在程序运行时才进行类型检查</li> <li>ts可以自动进行类型推导</li> <li>(ts是静态类型，js是动态类型)</li></ul> <h3 id="_21-node是单线程单进程如何高效利用多核cpu"><a href="#_21-node是单线程单进程如何高效利用多核cpu" class="header-anchor">#</a> 21.node是单线程单进程如何高效利用多核CPU？</h3> <p>node提供了child_process，通过启动多进程的方式来高效利用</p> <h3 id="_22-什么是ipc"><a href="#_22-什么是ipc" class="header-anchor">#</a> 22.什么是IPC？</h3> <p>IPC指InterProcess Communication,即进程间通信</p> <h3 id="_23-大文件上传和断点续传如何实现"><a href="#_23-大文件上传和断点续传如何实现" class="header-anchor">#</a> 23.大文件上传和断点续传如何实现？</h3> <ul><li>前端：核心是利用Blob.prototype.slice来返回文件的切片，再并发上传切片。</li> <li>后端：按标识合并切片=》通过读写流(readStream/writeStream)将切片写入最终文件</li></ul> <h4 id="流程"><a href="#流程" class="header-anchor">#</a> 流程</h4> <ol><li>按设置的切片大小对文件进行切片(返回的是个数组，每个切片都带有索引，因为并发上传的切片可能会打乱切片顺序)=&gt;文件内容和切片下标生成hash</li> <li>通过Promise.all并发上传所有切片=&gt;后端通过multiparty来处理前端的formData</li> <li>再发送一次请求通知后端合并切片</li> <li>进度条通过upload的onprogress监听进度=&gt;使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度
断点续传：后端保存已上传的切片hash，前端上传时后端会校验该切片是否已上传，已上传的切片就不再上传</li></ol> <h3 id="_24-ts中const和readonly区别"><a href="#_24-ts中const和readonly区别" class="header-anchor">#</a> 24.ts中const和readonly区别？</h3> <p>1.const是静态常量(不能同时和static使用)，由类型访问
readonly是动态常量，由实例访问
2.const必须在字段声明时初始化，readonly非必须</p> <h3 id="_25-ts中的this和js中的this有什么区别"><a href="#_25-ts中的this和js中的this有什么区别" class="header-anchor">#</a> 25.ts中的this和js中的this有什么区别？</h3> <p>// TODO</p> <h3 id="_26-nodejs和js区别是什么"><a href="#_26-nodejs和js区别是什么" class="header-anchor">#</a> 26.nodejs和js区别是什么？</h3> <ul><li>nodejs是运行环境，js是语言(执行js可以在浏览器也可以在nodejs上。因为都内置了js引擎)</li> <li>js在浏览器有dom，bom等浏览器相关对象,nodejs有文件系统，网络系统等</li></ul> <h3 id="_27-npm-i与npm-ci的区别是什么"><a href="#_27-npm-i与npm-ci的区别是什么" class="header-anchor">#</a> 27.npm i与npm ci的区别是什么？</h3> <ul><li>npm ci会删除node_modules文件夹</li> <li>npm ci要求项目中必须有package-lock.json否则不起作用，npm i不要求</li></ul> <h3 id="_28-node中循环引用会发生什么"><a href="#_28-node中循环引用会发生什么" class="header-anchor">#</a> 28.node中循环引用会发生什么？</h3> <p>在cjs中，遇到require时，会执行require模块中的代码，并缓存执行结果。下次再加载就会直接去取缓存结果，所以不会出现无限循环引用的情况</p> <h3 id="_29-v8如何执行js代码"><a href="#_29-v8如何执行js代码" class="header-anchor">#</a> 29.v8如何执行js代码？</h3> <p>parser生成抽象语法树=&gt;Ignition生成字节码(字节码不能直接在处理器上运行，需要解释器转成机器码)=&gt;编译器TuiboFan来编译成机器码</p> <h4 id="怎么知道v8版本号"><a href="#怎么知道v8版本号" class="header-anchor">#</a> 怎么知道v8版本号？</h4> <p>console.log(process.versions)</p> <h3 id="_30-node中如何读取可读流的内容"><a href="#_30-node中如何读取可读流的内容" class="header-anchor">#</a> 30.node中如何读取可读流的内容？</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 通过stream流
let data = &quot;&quot;;
stream.on(&quot;data&quot;, (chunk) =&gt; (data += chunk));
stream.on(&quot;end&quot;, () =&gt; console.log(data));
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_31-如何读取大文件内容"><a href="#_31-如何读取大文件内容" class="header-anchor">#</a> 31.如何读取大文件内容？</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>import { createReadStream } from &quot;fs&quot;;
const stream = createReadStream(&quot;bigfile.json&quot;);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_32-如何查看文件状态-文件最后修改时间"><a href="#_32-如何查看文件状态-文件最后修改时间" class="header-anchor">#</a> 32.如何查看文件状态/文件最后修改时间？</h3> <p>node stats</p> <h3 id="_33-说说对bff"><a href="#_33-说说对bff" class="header-anchor">#</a> 33.说说对BFF？</h3> <ul><li>BFF层可以对前端的数据进行处理再给后端</li> <li>优点：后端改动，只需改动BFF层，无需去改前端代码</li></ul> <h3 id="_34-koa-router实现原理"><a href="#_34-koa-router实现原理" class="header-anchor">#</a> 34.koa-router实现原理？</h3> <p>正则匹配=》采用的是path-to-regexp库</p> <h3 id="_35-node如何调用c"><a href="#_35-node如何调用c" class="header-anchor">#</a> 35.node如何调用c++？</h3> <p>通过napi</p> <h3 id="_36-什么是中间件-举例"><a href="#_36-什么是中间件-举例" class="header-anchor">#</a> 36.什么是中间件-举例？</h3> <p>比如路由中间件，全局异常捕获中间件，权限中间件</p> <h3 id="_37-fs-extra有使用过吗"><a href="#_37-fs-extra有使用过吗" class="header-anchor">#</a> 37.fs-extra有使用过吗？</h3> <p>是fs的扩展，继承了fs的所有方法，扩展了更多的功能，给fs的方法添加了promise的支持</p> <h3 id="_38-如何监控文件的变动"><a href="#_38-如何监控文件的变动" class="header-anchor">#</a> 38.如何监控文件的变动？</h3> <p>node有提供一个fs.watch</p> <h3 id="_39-node-max-old-space-size-4096什么意思"><a href="#_39-node-max-old-space-size-4096什么意思" class="header-anchor">#</a> 39.node --max-old-space-size=4096什么意思？</h3> <p>最大内存4G</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a4ba95f7.js" defer></script><script src="/assets/js/2.67e62386.js" defer></script><script src="/assets/js/25.9c781b1b.js" defer></script>
  </body>
</html>
