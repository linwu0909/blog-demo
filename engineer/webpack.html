<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶之路</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/icon.png">
    <meta name="description" content="linwu0909个人站点">
    
    <link rel="preload" href="/assets/css/0.styles.d6ad21ed.css" as="style"><link rel="preload" href="/assets/js/app.a4ba95f7.js" as="script"><link rel="preload" href="/assets/js/2.67e62386.js" as="script"><link rel="preload" href="/assets/js/18.7260607d.js" as="script"><link rel="prefetch" href="/assets/js/10.a509ebb0.js"><link rel="prefetch" href="/assets/js/11.f6c7ea4e.js"><link rel="prefetch" href="/assets/js/12.d41f06f2.js"><link rel="prefetch" href="/assets/js/13.c3e870d4.js"><link rel="prefetch" href="/assets/js/14.30322894.js"><link rel="prefetch" href="/assets/js/15.86aa2619.js"><link rel="prefetch" href="/assets/js/16.c3bf8266.js"><link rel="prefetch" href="/assets/js/17.558a6e40.js"><link rel="prefetch" href="/assets/js/19.610728e5.js"><link rel="prefetch" href="/assets/js/20.9a25090f.js"><link rel="prefetch" href="/assets/js/21.8265851e.js"><link rel="prefetch" href="/assets/js/22.07a30c30.js"><link rel="prefetch" href="/assets/js/23.0bd65a47.js"><link rel="prefetch" href="/assets/js/24.484698e4.js"><link rel="prefetch" href="/assets/js/25.9c781b1b.js"><link rel="prefetch" href="/assets/js/26.78631bc5.js"><link rel="prefetch" href="/assets/js/27.eafd817a.js"><link rel="prefetch" href="/assets/js/3.758fc587.js"><link rel="prefetch" href="/assets/js/4.8afd5cf5.js"><link rel="prefetch" href="/assets/js/5.4f1a5aca.js"><link rel="prefetch" href="/assets/js/6.cc47db6f.js"><link rel="prefetch" href="/assets/js/7.64d96c12.js"><link rel="prefetch" href="/assets/js/8.64e93bc9.js"><link rel="prefetch" href="/assets/js/9.ae8eb319.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d6ad21ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端进阶之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端综合" class="dropdown-title"><span class="title">前端综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端综合" class="mobile-dropdown-title"><span class="title">前端综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front/html.html" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front/js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/front/es6.html" class="nav-link">
  ES6+
</a></li><li class="dropdown-item"><!----> <a href="/front/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构和算法" class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据结构和算法" class="mobile-dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/base.html" class="nav-link">
  经典排序算法+数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/leetCode100.html" class="nav-link">
  LeetCode100
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/handWrite.html" class="nav-link">
  手写各种实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工程化" class="dropdown-title"><span class="title">前端工程化</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端工程化" class="mobile-dropdown-title"><span class="title">前端工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/engineer/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/engineer/webpack.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/engineer/pack.html" class="nav-link">
  Gulp
</a></li></ul></div></div> <a href="https://github.com/linwu0909" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端综合" class="dropdown-title"><span class="title">前端综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端综合" class="mobile-dropdown-title"><span class="title">前端综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front/html.html" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front/js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/front/es6.html" class="nav-link">
  ES6+
</a></li><li class="dropdown-item"><!----> <a href="/front/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构和算法" class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据结构和算法" class="mobile-dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/base.html" class="nav-link">
  经典排序算法+数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/leetCode100.html" class="nav-link">
  LeetCode100
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/handWrite.html" class="nav-link">
  手写各种实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工程化" class="dropdown-title"><span class="title">前端工程化</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端工程化" class="mobile-dropdown-title"><span class="title">前端工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/engineer/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/engineer/webpack.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/engineer/pack.html" class="nav-link">
  Gulp
</a></li></ul></div></div> <a href="https://github.com/linwu0909" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/engineer/webpack.html#webpack" class="sidebar-link">Webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_1-什么是webpack" class="sidebar-link">1.什么是webpack？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_2-webpack有哪些配置" class="sidebar-link">2.webpack有哪些配置？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_3-code-splitting-代码切割-splitchunks" class="sidebar-link">3.code splitting 代码切割=&gt;splitChunks？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_4-如何做打包体积分析" class="sidebar-link">4.如何做打包体积分析?</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_5-什么是模块" class="sidebar-link">5.什么是模块？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_6-webpack运行时-runtime-做了什么" class="sidebar-link">6.webpack运行时(Runtime)做了什么？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_7-webpack的工作流程" class="sidebar-link">7.webpack的工作流程？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_8-webpack和gulp区别" class="sidebar-link">8.webpack和gulp区别？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_9-webpack有哪些常见的loader和plugin" class="sidebar-link">9.webpack有哪些常见的loader和plugin？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#loader和plugin区别" class="sidebar-link">loader和plugin区别</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_10-loader开发-分同步和异步loader" class="sidebar-link">10.loader开发？(分同步和异步loader)</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_11-plugin开发" class="sidebar-link">11.plugin开发？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_12-source-map有哪些配置" class="sidebar-link">12.source map有哪些配置？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_13-treeshaking了解过吗" class="sidebar-link">13.TreeShaking了解过吗？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_14-hash-contenthash-chunkhash区别-都是hash策略" class="sidebar-link">14.hash，contentHash，chunkHash区别？(都是hash策略)</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_15-ast及应用" class="sidebar-link">15.AST及应用？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_16-webpack中什么是hmr" class="sidebar-link">16.webpack中什么是HMR？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_17-如何提升webpack构建资源的速度" class="sidebar-link">17.如何提升webpack构建资源的速度？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_18-webpack-rollup-vite如何加载json-image等非js资源" class="sidebar-link">18.webpack/rollup/vite如何加载json,image等非js资源？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_19-如何将js资源注入到html中" class="sidebar-link">19.如何将js资源注入到html中？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_20-为什么可以在webpack配置文件使用path模块" class="sidebar-link">20.为什么可以在webpack配置文件使用path模块？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_21-mode有几种模式" class="sidebar-link">21.mode有几种模式？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_22-vue-loader实现原理是什么" class="sidebar-link">22.vue-loader实现原理是什么？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_23-webpack4为什么选择了terser" class="sidebar-link">23.webpack4为什么选择了terser?</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_24-minify原理" class="sidebar-link">24.minify原理？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_25-webpack打包流程" class="sidebar-link">25.webpack打包流程？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_26-配置时thread-loader在前还是cache-loader" class="sidebar-link">*26.配置时thread-loader在前还是cache-loader？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_27-babel-loader-cache-loader缓存的区别" class="sidebar-link">*27.babel-loader,cache-loader缓存的区别？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_28-proxy原理" class="sidebar-link">28.proxy原理？</a></li><li class="sidebar-sub-header"><a href="/engineer/webpack.html#_29-webpack生命周期" class="sidebar-link">29.webpack生命周期</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#webpack">Webpack</a><ul><li><a href="#_1-什么是webpack">1.什么是webpack？</a></li><li><a href="#_2-webpack有哪些配置">2.webpack有哪些配置？</a></li><li><a href="#_3-code-splitting-代码切割-splitchunks">3.code splitting 代码切割=&gt;splitChunks？</a></li><li><a href="#_4-如何做打包体积分析">4.如何做打包体积分析?</a></li><li><a href="#_5-什么是模块">5.什么是模块？</a></li><li><a href="#_6-webpack运行时-runtime-做了什么">6.webpack运行时(Runtime)做了什么？</a></li><li><a href="#_7-webpack的工作流程">7.webpack的工作流程？</a></li><li><a href="#_8-webpack和gulp区别">8.webpack和gulp区别？</a></li><li><a href="#_9-webpack有哪些常见的loader和plugin">9.webpack有哪些常见的loader和plugin？</a></li><li><a href="#loader和plugin区别">loader和plugin区别</a></li><li><a href="#_10-loader开发-分同步和异步loader">10.loader开发？(分同步和异步loader)</a></li><li><a href="#_11-plugin开发">11.plugin开发？</a></li><li><a href="#_12-source-map有哪些配置">12.source map有哪些配置？</a></li><li><a href="#_13-treeshaking了解过吗">13.TreeShaking了解过吗？</a></li><li><a href="#_14-hash-contenthash-chunkhash区别-都是hash策略">14.hash，contentHash，chunkHash区别？(都是hash策略)</a></li><li><a href="#_15-ast及应用">15.AST及应用？</a></li><li><a href="#_16-webpack中什么是hmr">16.webpack中什么是HMR？</a></li><li><a href="#_17-如何提升webpack构建资源的速度">17.如何提升webpack构建资源的速度？</a></li><li><a href="#_18-webpack-rollup-vite如何加载json-image等非js资源">18.webpack/rollup/vite如何加载json,image等非js资源？</a></li><li><a href="#_19-如何将js资源注入到html中">19.如何将js资源注入到html中？</a></li><li><a href="#_20-为什么可以在webpack配置文件使用path模块">20.为什么可以在webpack配置文件使用path模块？</a></li><li><a href="#_21-mode有几种模式">21.mode有几种模式？</a></li><li><a href="#_22-vue-loader实现原理是什么">22.vue-loader实现原理是什么？</a></li><li><a href="#_23-webpack4为什么选择了terser">23.webpack4为什么选择了terser?</a></li><li><a href="#_24-minify原理">24.minify原理？</a></li><li><a href="#_25-webpack打包流程">25.webpack打包流程？</a></li><li><a href="#_26-配置时thread-loader在前还是cache-loader">*26.配置时thread-loader在前还是cache-loader？</a></li><li><a href="#_27-babel-loader-cache-loader缓存的区别">*27.babel-loader,cache-loader缓存的区别？</a></li><li><a href="#_28-proxy原理">28.proxy原理？</a></li><li><a href="#_29-webpack生命周期">29.webpack生命周期</a></li></ul></li></ul></div><p></p> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> Webpack</h2> <h3 id="_1-什么是webpack"><a href="#_1-什么是webpack" class="header-anchor">#</a> 1.什么是webpack？</h3> <ul><li>webpack(基于node，只能处理js和json文件)是一个打包工具，在webpack里一切文件皆是模块</li> <li>他做的事情是分析你的项目结构，找到js模块以及它的一些浏览器不能直接运行的语言比如scss，ts等，将其打包成合适的格式给浏览器使用</li></ul> <h4 id="为什么要用webpack对前端进行打包"><a href="#为什么要用webpack对前端进行打包" class="header-anchor">#</a> 为什么要用webpack对前端进行打包？</h4> <ol><li>打包后体积更新页面加载更快</li> <li>编译高级语法(TS，ES6)</li></ol> <ul><li>原生支持tree shaking(去除用不上的代码)</li> <li>webpack中tree-shaking是通过uglifySPlugin来处理js，通过purify-css处理css</li> <li>主要四个模块entry output loader plugins</li></ul> <h4 id="webpack3和4区别-webpack4号称零配置开箱即用"><a href="#webpack3和4区别-webpack4号称零配置开箱即用" class="header-anchor">#</a> webpack3和4区别(webpack4号称零配置开箱即用)</h4> <ul><li>4相对于3分包做了优化，移除CommonsChunkPlugin用splitChunksPlugin切割代码</li> <li>分离css原来用extract-text-webpack-plugin，现在用MiniCssExtractPlugin</li> <li>增加mode属性</li> <li>默认的压缩插件从uglifyjs-webpack-plugin变成terser-webpack-plugin</li> <li>webpack4:支持零配置直接打包，按约定以src/index.js为入口,dist/main.js为出口</li></ul> <h4 id="webpack4和5区别-webpack5node最低要求10-13"><a href="#webpack4和5区别-webpack5node最低要求10-13" class="header-anchor">#</a> webpack4和5区别(webpack5node最低要求10.13)</h4> <ul><li>webpack4加载资源需要不同的loader(file-loader,url-loader等)，</li> <li>而webpack5有资源模块(asset module)来替代，比如file-loader可以用asset/resource，url-loader可以用asset/inline来替代</li> <li>webpack5支持原生worker</li> <li>缓存在webpack5默认开启，缓存在内存里(cacheDirectory)</li></ul> <h3 id="_2-webpack有哪些配置"><a href="#_2-webpack有哪些配置" class="header-anchor">#</a> 2.webpack有哪些配置？</h3> <ul><li>mode:模式</li> <li>entry:入口</li> <li>output:出口</li> <li>optimization：策略，比如分包splitChunks=》node_modules，moduleL配置根据正则匹配对应加载器
plugin:配置插件，resolve配置模块如何解析=》vue配置别名会被精准匹配=》用来配置importVue时候的vue路径，context指定entry的根路径</li></ul> <h3 id="_3-code-splitting-代码切割-splitchunks"><a href="#_3-code-splitting-代码切割-splitchunks" class="header-anchor">#</a> 3.code splitting 代码切割=&gt;splitChunks？</h3> <p>默认所有代码会被打包到一起，bundle体积会太大，通过分包进行优化</p> <ul><li>import()动态导入=&gt;按需加载</li></ul> <h4 id="魔法注释"><a href="#魔法注释" class="header-anchor">#</a> 魔法注释</h4> <p>目的就是设置动态导入的文件打包出来的名称, 命名相同的会被打包到一起</p> <ul><li>splitChunksPlugin可以将公共的依赖模块提取到已有的chunk中，在optimization中配置</li> <li>通过entry来手动分离=》多入口打包=&gt;存在多个打包结果有相同模块的情况，需要将optimization的splitChunks的chunks设置为'all'(将公共模块提取到单独的bundle)=&gt;重要</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>optimization: {
    splitChunks: {
        chunks: 'all' | 'async' | 'initial' =》 默认只将异步导入的模块单独打包  all是所有都单独打包，最后打在一个文件上 initial是都单独打包，打包到各自的文件上
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="code-splitting-代码切割-是如何动态加载chunk的"><a href="#code-splitting-代码切割-是如何动态加载chunk的" class="header-anchor">#</a> code splitting(代码切割) 是如何动态加载chunk的</h4> <p>主要是通过jsonp的方式来动态加载chunk</p> <h4 id="webpack分包与合包"><a href="#webpack分包与合包" class="header-anchor">#</a> webpack分包与合包</h4> <ul><li>webpack4.0之前通过commonChunkPlugin来分包</li> <li>webpack4.0之后通过设置optimization.splitChunks来分包</li></ul> <h4 id="optimization"><a href="#optimization" class="header-anchor">#</a> optimization</h4> <ul><li>usedExports: true, 打包结果中只导出外部用到的成员</li> <li>minimize: true 压缩打包结果
=&gt;生产默认开启tree-shaking，如果没有开启可以通过配置usedExports和minimize开启=》一个标记无用的代码，一个用来压缩时进行清除</li> <li>sideEffects：用来删除副作用代码
=&gt;先去webpack.config.js的optimization设置sideEffect为true来开启功能，再去package.json设置sideEffects为false，标记代码没有副作用
=&gt;如果想标记哪些文件有副作用，在package.json的sideEffects可以定义一个数组，里面放有副作用的文件路径</li></ul> <h3 id="_4-如何做打包体积分析"><a href="#_4-如何做打包体积分析" class="header-anchor">#</a> 4.如何做打包体积分析?</h3> <ul><li>通过webpack-bundle-analyzer分析打包体积</li> <li>原理是根据webpack打包后的stats数据进行分析，在webpack compiler的done hook进行处理</li> <li>在可视化页面中，可以看到三个选项。1.stat每个模块原始体积2.parsed经webpack打包后的体积3.gzip经gzip压缩后的体积</li></ul> <h4 id="webpack如何优化项目体积"><a href="#webpack如何优化项目体积" class="header-anchor">#</a> webpack如何优化项目体积</h4> <p>uglify或terser进行js压缩，使用commonChunk分离第三方代码，使用externals配置来提取常用库(这样不会被打到bundle中，使用时通过cdn来引入)</p> <h3 id="_5-什么是模块"><a href="#_5-什么是模块" class="header-anchor">#</a> 5.什么是模块？</h3> <p>将一个复杂的项目按一定的规范封装成几个模块，只是向外部暴露一些方法来进行通信</p> <h4 id="module-chunk-bundle区别"><a href="#module-chunk-bundle区别" class="header-anchor">#</a> module，chunk，bundle区别</h4> <p>webpack中一切都是(module) 多个模块合成一个chunk(代码块) bundle是最终输出文件</p> <h3 id="_6-webpack运行时-runtime-做了什么"><a href="#_6-webpack运行时-runtime-做了什么" class="header-anchor">#</a> 6.webpack运行时(Runtime)做了什么？</h3> <ul><li>webpack打包后的bundle实际就是个立即执行函数(IIFE)</li></ul> <h4 id="webpack4"><a href="#webpack4" class="header-anchor">#</a> webpack4</h4> <p>立即执行函数主要这几块，__webpack__modules存放编译后的模块内容，__webpack__module_cache用来做模块缓存(缓存被引用过的模块)，
__webpack__require__是模块引用函数，然后还有几个工具函数，最后通过__webpack_require，传递索引0，即入口文件来启动整个项目</p> <h4 id="webpack5"><a href="#webpack5" class="header-anchor">#</a> webpack5</h4> <p>在立即执行函数里主要是这几块，__webpack__modules用来存放编译后的模块的js内容，__webpack__module_cache__用来做模块缓存，
__webpack_require__是模块引用函数，来实现模块的导入导出，最后通过__webpack_require引入入口文件main.js启动整个项目=》不通过索引，而是具体文件位置?</p> <ol><li>__webpack_modules__是一个维护所有模块的数组。将入口模块解析成AST，根据AST深度优先搜索所有的模块，并构建出这个模块数组。
每个模块都由一个包裹函数(module,module.export,<strong>webpack_require</strong>)对模块进行包裹构成</li> <li>__webpack_require__手动实现加载一个模块。对已加载过的模块进行缓存，对未加载过的模块，通过id定位到__webpack_modules__中的包裹函数，
id就是数组的key(索引)，执行并返回module.export，最后缓存</li> <li><strong>webpack_require</strong>(0)运行入口模块=》也就是配置的main.js
rollup不会将所有模块放在modules中进行维护，它是将所有模块进行展开，如果两个模块中的变量名发生冲突，会直接重新命名</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>name.js const name = '111'
friend.js const name = '111'
=&gt; const name$1 = '111' const name = '111'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_7-webpack的工作流程"><a href="#_7-webpack的工作流程" class="header-anchor">#</a> 7.webpack的工作流程？</h3> <ol><li>合并命令行和webpack配置文件里配置的参数，得到最终的配置对象=&gt;webpack CLI作用(通过yargs模块解析命令行参数)</li> <li>初始化compiler对象，加载所有配置的插件</li> <li>执行compiler对象的run方法开始编译</li> <li>根据配置的entry找到入口文件，解析模块依赖形成依赖树。递归依赖树，将每个模块交给对应的loader处理</li> <li>根据entry和output配置生成代码块chunk</li> <li>根据output输出chunk到对应文件目录</li></ol> <h3 id="_8-webpack和gulp区别"><a href="#_8-webpack和gulp区别" class="header-anchor">#</a> 8.webpack和gulp区别？</h3> <ul><li>侧重点不同，webpack侧重模块打包，gulp侧重流程管理。</li> <li>gulp通过配置task任务，来定义任务的执行顺序，按顺序对项目进行构建</li> <li>webpack把图片，js文件，css文件等看成是模块，通过加载器(loader)和插件(plugins)对资源进行处理</li></ul> <h3 id="_9-webpack有哪些常见的loader和plugin"><a href="#_9-webpack有哪些常见的loader和plugin" class="header-anchor">#</a> 9.webpack有哪些常见的loader和plugin？</h3> <ul><li><p>babel-loader =&gt; es6+转es5</p></li> <li><p>css-loader =&gt; 加载css并压缩(支持模块化) =》打包css文件需要同时使用css-loader和style-loader=&gt;style-loader用来注入css</p></li> <li><p>style-loader =&gt; 通过script方式把css注入js中</p></li> <li><p>image-loader：加载并且压缩图片文件</p></li> <li><p>vue-loader =&gt; 加载 Vue.js 单文件组件</p></li> <li><p>*sass-loader =&gt;把sass转成css =》核心原理是通过ast
=&gt;同一个模块同时use多个loader，执行顺序从后往前=》常见打包css，用到了style-loader和css-loader</p></li> <li><p>uglifyjs-webpack-plugin 通过uglify压缩js代码</p></li> <li><p>mini-css-extract-plugin 分离css文件，支持按需加载</p></li> <li><p>html-webpack-plugin 会把webpack打包后的静态资源注入到html中</p></li> <li><p>webpack-bundle-analyzer 分析文件体积</p></li> <li><p>copy-webpack-plugin 指定需要拷贝的目录会拷贝到dist下</p></li> <li><p>clean-webpack-plugin 清除dist目录
=》webpack为每个工作环节都预留了钩子，插件只要找合适的时机去做指定的事情即可</p></li></ul> <h3 id="loader和plugin区别"><a href="#loader和plugin区别" class="header-anchor">#</a> loader和plugin区别</h3> <ul><li>webpack本身只能解析js文件，想打包其他文件就需要引入对应loader进行处理</li> <li>plugin是用来扩展webpack功能。</li></ul> <h4 id="loader作用"><a href="#loader作用" class="header-anchor">#</a> loader作用</h4> <p>loader是用来处理其他类型的文件比如将less转成css文件，es6转es5，ts转js等</p> <h4 id="loader执行顺序-pre-normal-inline-post"><a href="#loader执行顺序-pre-normal-inline-post" class="header-anchor">#</a> loader执行顺序(pre&gt;normal&gt;inline&gt;post)</h4> <p>从右到左，从下到上</p> <h4 id="loader为什么右边的先执行"><a href="#loader为什么右边的先执行" class="header-anchor">#</a> loader为什么右边的先执行</h4> <p>函数组合有两种方式，一种从左往右(类似pipe流)，一种从右往左(compose),webpack采用的是第二种</p> <h3 id="_10-loader开发-分同步和异步loader"><a href="#_10-loader开发-分同步和异步loader" class="header-anchor">#</a> 10.loader开发？(分同步和异步loader)</h3> <p>定义一个函数用来对资源进行处理，并导出(函数不能用箭头函数，因为过程中会改变this指向，用箭头函数会报错)
(输入是加载到的资源，输出是处理后的结果)</p> <h3 id="_11-plugin开发"><a href="#_11-plugin开发" class="header-anchor">#</a> 11.plugin开发？</h3> <ul><li>plugin是通过钩子机制实现的。在不同事件节点上挂载不同的任务来扩展插件=&gt;插件是通过在生命周期的钩子中挂载函数实现扩展</li> <li>插件是一个函数或者类，必须包含apply方法</li> <li>把插件定义为一个类，在类中定义apply方法，参数是compiler(完整的webpack环境配置)，再通过compiler的钩子emit来实现。钩子第一个参数是插件名，</li> <li>第二个compilation是上下文， 通过compilation.assets就可以拿到本次打包的资源，然后再做相应处理(主要是source函数和size函数)，
最后执行callback(也是第二个参数里的)</li></ul> <h3 id="_12-source-map有哪些配置"><a href="#_12-source-map有哪些配置" class="header-anchor">#</a> 12.source map有哪些配置？</h3> <p>sourceMap作用：映射文件，用来将打包后的代码映射到源码文件中，便于定位错误</p> <ul><li>eval 使用eval执行模块代码，构建速度快(只能知道文件路径，不知道具体行信息)</li> <li>sourceMap 有行信息，产生.map文件</li> <li>cheap 包含行信息，但是和源代码还是有差异</li> <li>module 得到loader处理前的代码，和源代码一模一样</li> <li>inline:不单独生成.map文件(较少见此配置)
使用cheap-module-eval-source-map模式，打包出来的就和源代码一模一样=》开发时推荐使用，启动打包慢，监视的情况重新打包快
较优配置生产环境使用none，推荐使用nosources-source-map不会暴露所有源代码，只会展示出现问题的代码位置</li></ul> <h4 id="常规使用配置"><a href="#常规使用配置" class="header-anchor">#</a> 常规使用配置</h4> <ul><li>开发环境：cheap-module-eval-source-map</li> <li>生产环境：cheap-module-source-map</li></ul> <h3 id="_13-treeshaking了解过吗"><a href="#_13-treeshaking了解过吗" class="header-anchor">#</a> 13.TreeShaking了解过吗？</h3> <p>tree shaking前提是esm</p> <h4 id="treeshaking原理是什么"><a href="#treeshaking原理是什么" class="header-anchor">#</a> TreeShaking原理是什么</h4> <p>是基于ESModule进行静态分析，通过AST将用不到的代码进行移除。还可以通过引入支持treeShaking的包来减少打包体积。比如lodash-es替换lodash</p> <h3 id="_14-hash-contenthash-chunkhash区别-都是hash策略"><a href="#_14-hash-contenthash-chunkhash区别-都是hash策略" class="header-anchor">#</a> 14.hash，contentHash，chunkHash区别？(都是hash策略)</h3> <p>=》一般服务器都会对前端资源设置静态资源缓存，需要通过合理的hash策略来使性能达到最佳
通过文件名+文件哈希值的方式判断资源是否有更新
只要项目有文件改变就会改变hash
contentHash和单位文件内容相关，指定文件发生改变才会改变
chunkHash和打包生成的chunk相关，不同入口不同</p> <h4 id="作用"><a href="#作用" class="header-anchor">#</a> 作用</h4> <p>依赖的公共模块一般很少更改(没有更改即公共模块hash不变,不同模块用不同的hash策略)，可以利于长期缓存=》比如css用contentHash来判断</p> <h3 id="_15-ast及应用"><a href="#_15-ast及应用" class="header-anchor">#</a> 15.AST及应用？</h3> <p>AST是抽象语法树的简称
涉及ts转js sass/less转css es6转es5
生成AST涉及词法分析(应用=&gt;代码检查，语法高亮)和语法分析两个阶段</p> <h4 id="ast核心步骤-不同的语言拥有不同的解析器-js用babel"><a href="#ast核心步骤-不同的语言拥有不同的解析器-js用babel" class="header-anchor">#</a> AST核心步骤 不同的语言拥有不同的解析器 js用babel</h4> <ol><li>把代码解析成AST</li> <li>把TS的AST转换JS的AST</li> <li>再把AST转成代码</li></ol> <h3 id="_16-webpack中什么是hmr"><a href="#_16-webpack中什么是hmr" class="header-anchor">#</a> 16.webpack中什么是HMR？</h3> <p>HMR(Hot Module Replacement)热模块替换.无需刷新即可替换掉旧模块
将修改的模块实时替换到页面上
开启方式：</p> <ul><li>通过webpack-dev-server --hot可以开启 =&gt;devServer替代方式是开启--watch模式+browserSync(当dist发生变更就会刷新浏览器)</li> <li>devServer的hot设置为true，引入插件HotModuleReplacementPlugin</li></ul> <h4 id="webpack热更新原理"><a href="#webpack热更新原理" class="header-anchor">#</a> webpack热更新原理</h4> <p>(webpack通过watch监听到文件变化，变化就重新打包)</p> <ul><li>客户端从服务端拉取最新的代码进行chunk diff(就是将本次打包的chunk与上一次进行对比)</li> <li>WDS(Webpack-dev-server)与浏览器之间维护了一个websocket，资源发生变化WDS会向客户端推送更新，会带上本次打包生成的hash。</li> <li>拿到hash后WDS(Webpack-dev-server)发起ajax请求来获取更改内容(文件列表和hash)。通过jsonp获取该chunk增量更新</li></ul> <h3 id="_17-如何提升webpack构建资源的速度"><a href="#_17-如何提升webpack构建资源的速度" class="header-anchor">#</a> 17.如何提升webpack构建资源的速度？</h3> <p>使用speed-measure-webpack-plugin可评估每个loader和plugin的执行耗时</p> <ol><li>webpack耗时最久是负责AST转换的loader，使用js性能低下，可以换成rust编写的swc-loader</li> <li>webpack5内置缓存插件，可通过cache: {type: filesyetem}开启，将Module，chunk，moduleChunk等信息序列化到磁盘中，二次构建避免重新编译
比如一个js文件配置了eslint，ts，babel等loader，有可能执行多次编译，开启持久化缓存，再次编译无需解析AST
webpack4中也可以用cache-loader对loader进行缓存，但是目前已经是@deprecated(不久的将来会取消)的状态</li> <li>thread-loader官方推荐开启多进程的loader，可以对babel解析AST时开启多进程处理，提升编译性能</li></ol> <h3 id="_18-webpack-rollup-vite如何加载json-image等非js资源"><a href="#_18-webpack-rollup-vite如何加载json-image等非js资源" class="header-anchor">#</a> 18.webpack/rollup/vite如何加载json,image等非js资源？</h3> <ul><li>通过loader转成模块的形式</li> <li>比如处理css通过css-loader和style-loader。css-loader通过postcss来解析处理css中的url和@import，转成模块引入</li> <li>再用style-loader将样式注入到dom中，原理是使用DOM提供的API去构建style标签，把css内容注入到style中</li> <li>由于性能问题(css会在js资源加载完后加载，容易出现页面抖动，且性能低)，在生产环境我们通常需要单独加载css资源，</li> <li>所以要借助mini-css-exact-plugin将css单独抽离出来。
(rollup只允许通过插件的方式进行扩展)</li></ul> <h3 id="_19-如何将js资源注入到html中"><a href="#_19-如何将js资源注入到html中" class="header-anchor">#</a> 19.如何将js资源注入到html中？</h3> <p>原理是：当webpack生成js资源后，获取其文件名及publicPath，最后将其注入到html中。
(可以通过html-webpack-plugin)</p> <h3 id="_20-为什么可以在webpack配置文件使用path模块"><a href="#_20-为什么可以在webpack配置文件使用path模块" class="header-anchor">#</a> 20.为什么可以在webpack配置文件使用path模块？</h3> <p>因为webpack的配置文件是运行在nodejs环境中，所以可以在这个文件中使用所有nodejs的内置模块</p> <h3 id="_21-mode有几种模式"><a href="#_21-mode有几种模式" class="header-anchor">#</a> 21.mode有几种模式？</h3> <p>production,development,none=&gt;默认production</p> <h3 id="_22-vue-loader实现原理是什么"><a href="#_22-vue-loader实现原理是什么" class="header-anchor">#</a> 22.vue-loader实现原理是什么？</h3> <ul><li>vue-loader会把sfc中的内容拆分为template，script，style三个虚拟模块，分别匹配webpack配置中对于的rules，</li> <li>比如script会匹配所有跟处理js或ts相关的loader</li> <li>template中的内容会通过vue complier转换成render函数后合并到script虚拟模块中</li> <li>scoped style会经过vue-loader/style-post-loader处理，成为只匹配特定元素的私有样式</li></ul> <h3 id="_23-webpack4为什么选择了terser"><a href="#_23-webpack4为什么选择了terser" class="header-anchor">#</a> 23.webpack4为什么选择了terser?</h3> <p>因为uglify-js不支持ES6+,webpack4默认内置使用terser-webpack-plugin</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>terser开启多进程能显著加快构建速度，建议开启
module.exports = {
    optimization: {
        minimizer: [
            new TerserPlugin({
                parallel: true,
            }),
        ],
    },
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="如何自动去除console-log-可以通过terser插件的drop-console"><a href="#如何自动去除console-log-可以通过terser插件的drop-console" class="header-anchor">#</a> 如何自动去除console.log=&gt;可以通过terser插件的drop_console？</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: false, // 默认false，设置为true, 则会删除所有console.* 相关的代码。
            pure_funcs: [&quot;console.log&quot;], // 单纯禁用console.log
          }
        }
      })
    ]
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_24-minify原理"><a href="#_24-minify原理" class="header-anchor">#</a> 24.minify原理？</h3> <p>先AST分析，再根据配置的策略来生成更小体积的AST，最后生成代码</p> <h4 id="js文件压缩做了什么-》terser-uglifyjs做了哪些东西"><a href="#js文件压缩做了什么-》terser-uglifyjs做了哪些东西" class="header-anchor">#</a> js文件压缩做了什么 =》terser/uglifyjs做了哪些东西</h4> <ul><li>去除空格，换行符，注释</li> <li>把较长的变量名替换为短名称</li> <li>编译预计算 let minute = 60 * 1000; let minute = 60000;</li> <li>合并声明及布尔值简化</li></ul> <h4 id="为什么要压缩js文件"><a href="#为什么要压缩js文件" class="header-anchor">#</a> 为什么要压缩js文件？</h4> <p>减少js代码体积，提高执行速度。并且压缩后不具备可读性，防止被人轻易使用</p> <h4 id="如何压缩"><a href="#如何压缩" class="header-anchor">#</a> 如何压缩</h4> <ul><li>terser｜uglify等库来进行压缩</li> <li>gzip压缩，在nginx开启</li> <li>替换大体积的第三方库=&gt;moment=&gt;dayjs</li> <li>使用支持treeShaking的库 lodash =&gt; lodash/es</li> <li>不支持treeShaking的库，按需引入使用的模块</li> <li>code splitting 路由懒加载</li> <li>splitChunksPlugin 分包(需要注意避免把一个库多次引用多次打包) =&gt; 分包不能把总体积变小，但能提高加载性能</li></ul> <h3 id="_25-webpack打包流程"><a href="#_25-webpack打包流程" class="header-anchor">#</a> 25.webpack打包流程？</h3> <ol><li>根据配置webpack.config.js进行初始化</li> <li>使用各种配置的loader对文件进行解析</li> <li>生成AST语法树，根据语法树找到依赖文件，对依赖文件进行递归，直到该文件没有依赖文件为止</li> <li>打包生成chunk</li></ol> <h4 id="多进程打包"><a href="#多进程打包" class="header-anchor">#</a> 多进程打包</h4> <p>thread-loader=&gt;webpack运行在node环境上</p> <h3 id="_26-配置时thread-loader在前还是cache-loader"><a href="#_26-配置时thread-loader在前还是cache-loader" class="header-anchor">#</a> *26.配置时thread-loader在前还是cache-loader？</h3> <p>应该是thread-loader,这样cache-loader也能使用到多进程</p> <h3 id="_27-babel-loader-cache-loader缓存的区别"><a href="#_27-babel-loader-cache-loader缓存的区别" class="header-anchor">#</a> *27.babel-loader,cache-loader缓存的区别？</h3> <p>babel-loader根据内容缓存，cache-loader根据mtime(修改时间)来缓存</p> <h3 id="_28-proxy原理"><a href="#_28-proxy原理" class="header-anchor">#</a> 28.proxy原理？</h3> <p>webpack-dev-server本地启动一个服务器，然后与目标服务器之前进行请求不存在跨域</p> <h3 id="_29-webpack生命周期"><a href="#_29-webpack生命周期" class="header-anchor">#</a> 29.webpack生命周期</h3> <p>// TODO</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a4ba95f7.js" defer></script><script src="/assets/js/2.67e62386.js" defer></script><script src="/assets/js/18.7260607d.js" defer></script>
  </body>
</html>
