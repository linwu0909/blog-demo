<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶之路</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/icon.png">
    <meta name="description" content="linwu0909个人站点">
    
    <link rel="preload" href="/assets/css/0.styles.d6ad21ed.css" as="style"><link rel="preload" href="/assets/js/app.a4ba95f7.js" as="script"><link rel="preload" href="/assets/js/2.67e62386.js" as="script"><link rel="preload" href="/assets/js/27.eafd817a.js" as="script"><link rel="prefetch" href="/assets/js/10.a509ebb0.js"><link rel="prefetch" href="/assets/js/11.f6c7ea4e.js"><link rel="prefetch" href="/assets/js/12.d41f06f2.js"><link rel="prefetch" href="/assets/js/13.c3e870d4.js"><link rel="prefetch" href="/assets/js/14.30322894.js"><link rel="prefetch" href="/assets/js/15.86aa2619.js"><link rel="prefetch" href="/assets/js/16.c3bf8266.js"><link rel="prefetch" href="/assets/js/17.558a6e40.js"><link rel="prefetch" href="/assets/js/18.7260607d.js"><link rel="prefetch" href="/assets/js/19.610728e5.js"><link rel="prefetch" href="/assets/js/20.9a25090f.js"><link rel="prefetch" href="/assets/js/21.8265851e.js"><link rel="prefetch" href="/assets/js/22.07a30c30.js"><link rel="prefetch" href="/assets/js/23.0bd65a47.js"><link rel="prefetch" href="/assets/js/24.484698e4.js"><link rel="prefetch" href="/assets/js/25.9c781b1b.js"><link rel="prefetch" href="/assets/js/26.78631bc5.js"><link rel="prefetch" href="/assets/js/3.758fc587.js"><link rel="prefetch" href="/assets/js/4.8afd5cf5.js"><link rel="prefetch" href="/assets/js/5.4f1a5aca.js"><link rel="prefetch" href="/assets/js/6.cc47db6f.js"><link rel="prefetch" href="/assets/js/7.64d96c12.js"><link rel="prefetch" href="/assets/js/8.64e93bc9.js"><link rel="prefetch" href="/assets/js/9.ae8eb319.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d6ad21ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端进阶之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端综合" class="dropdown-title"><span class="title">前端综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端综合" class="mobile-dropdown-title"><span class="title">前端综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front/html.html" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front/js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/front/es6.html" class="nav-link">
  ES6+
</a></li><li class="dropdown-item"><!----> <a href="/front/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构和算法" class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据结构和算法" class="mobile-dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/base.html" class="nav-link">
  经典排序算法+数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/leetCode100.html" class="nav-link">
  LeetCode100
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/handWrite.html" class="nav-link">
  手写各种实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工程化" class="dropdown-title"><span class="title">前端工程化</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端工程化" class="mobile-dropdown-title"><span class="title">前端工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/engineer/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/engineer/webpack.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/engineer/pack.html" class="nav-link">
  Gulp
</a></li></ul></div></div> <a href="https://github.com/linwu0909" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端综合" class="dropdown-title"><span class="title">前端综合</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端综合" class="mobile-dropdown-title"><span class="title">前端综合</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/front/html.html" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/front/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/front/js.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/front/es6.html" class="nav-link">
  ES6+
</a></li><li class="dropdown-item"><!----> <a href="/front/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/front/promise.html" class="nav-link">
  Promise
</a></li></ul></div></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据结构和算法" class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据结构和算法" class="mobile-dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/base.html" class="nav-link">
  经典排序算法+数据结构
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/leetCode100.html" class="nav-link">
  LeetCode100
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/handWrite.html" class="nav-link">
  手写各种实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端工程化" class="dropdown-title"><span class="title">前端工程化</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端工程化" class="mobile-dropdown-title"><span class="title">前端工程化</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/engineer/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/engineer/webpack.html" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/engineer/pack.html" class="nav-link">
  Gulp
</a></li></ul></div></div> <a href="https://github.com/linwu0909" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/#vue" class="sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/#_1-生命周期" class="sidebar-link">1.生命周期?</a></li><li class="sidebar-sub-header"><a href="/vue/#_2-v-if和v-show的区别" class="sidebar-link">2.v-if和v-show的区别？</a></li><li class="sidebar-sub-header"><a href="/vue/#_3-vue组件封装-全局可用" class="sidebar-link">3.vue组件封装 全局可用？</a></li><li class="sidebar-sub-header"><a href="/vue/#_4-vue中的data为什么是个函数" class="sidebar-link">4.vue中的data为什么是个函数？</a></li><li class="sidebar-sub-header"><a href="/vue/#_5-深度监听" class="sidebar-link">5.深度监听？</a></li><li class="sidebar-sub-header"><a href="/vue/#_6-keep-alive作用" class="sidebar-link">6.keep-alive作用？</a></li><li class="sidebar-sub-header"><a href="/vue/#_7-vue-router传参" class="sidebar-link">7.vue-router传参？</a></li><li class="sidebar-sub-header"><a href="/vue/#_8-vue的数据流" class="sidebar-link">8.vue的数据流？</a></li><li class="sidebar-sub-header"><a href="/vue/#_9-v-router路由守卫有哪些参数-如何实现" class="sidebar-link">9.v-router路由守卫有哪些参数，如何实现？</a></li><li class="sidebar-sub-header"><a href="/vue/#_10-vuex有哪些参数-作用" class="sidebar-link">10.vuex有哪些参数，作用？</a></li><li class="sidebar-sub-header"><a href="/vue/#_11-mvvm模型的理解及与mvc区别-vue-mvvm-当model变化会触发view更新" class="sidebar-link">11.mvvm模型的理解及与MVC区别 =&gt; vue-mvvm 当model变化会触发view更新？</a></li><li class="sidebar-sub-header"><a href="/vue/#_12-v-for为什么一定要绑定key" class="sidebar-link">12.v-for为什么一定要绑定key？</a></li><li class="sidebar-sub-header"><a href="/vue/#_13-vue的inject和eventbus" class="sidebar-link">13.vue的inject和eventbus？</a></li><li class="sidebar-sub-header"><a href="/vue/#_14-vue2和vue3响应式原理实现差异" class="sidebar-link">14.vue2和vue3响应式原理实现差异？</a></li><li class="sidebar-sub-header"><a href="/vue/#_15-v-model可以用什么替代" class="sidebar-link">15.v-model可以用什么替代?</a></li><li class="sidebar-sub-header"><a href="/vue/#_16-vue组件销毁-所有自定义事件-emit-on定义的事件-和原生事件都会解绑吗" class="sidebar-link">16.vue组件销毁，所有自定义事件($emit，$on定义的事件)和原生事件都会解绑吗?</a></li><li class="sidebar-sub-header"><a href="/vue/#_17-vue怎么区分开发环境和生产环境" class="sidebar-link">17.vue怎么区分开发环境和生产环境？</a></li><li class="sidebar-sub-header"><a href="/vue/#_18-如何设置css只在当前组件起作用" class="sidebar-link">18.如何设置css只在当前组件起作用？</a></li><li class="sidebar-sub-header"><a href="/vue/#_19-todo" class="sidebar-link">19.// TODO</a></li><li class="sidebar-sub-header"><a href="/vue/#_20-route和router有什么区别" class="sidebar-link">20.route和router有什么区别？</a></li><li class="sidebar-sub-header"><a href="/vue/#_21-vue是挂载在哪个标签上" class="sidebar-link">21.vue是挂载在哪个标签上？</a></li><li class="sidebar-sub-header"><a href="/vue/#_22-computed和watch区别是什么" class="sidebar-link">22.computed和watch区别是什么？</a></li><li class="sidebar-sub-header"><a href="/vue/#_23-vue模版编译原理-为什么要用template" class="sidebar-link">23.vue模版编译原理？为什么要用template？</a></li><li class="sidebar-sub-header"><a href="/vue/#_24-vue的挂载过程" class="sidebar-link">24.vue的挂载过程？</a></li><li class="sidebar-sub-header"><a href="/vue/#_25-说说组件传值的几种方式" class="sidebar-link">25.说说组件传值的几种方式？</a></li><li class="sidebar-sub-header"><a href="/vue/#_26-如何解决vue初始化页面闪动问题" class="sidebar-link">26.如何解决vue初始化页面闪动问题？</a></li><li class="sidebar-sub-header"><a href="/vue/#_27-什么是spa-有什么优点和缺点" class="sidebar-link">27.什么是SPA，有什么优点和缺点？</a></li><li class="sidebar-sub-header"><a href="/vue/#_28-在哪个生命周期发起数据请求" class="sidebar-link">28.在哪个生命周期发起数据请求？</a></li><li class="sidebar-sub-header"><a href="/vue/#_29-vue-router的几种模式-hash和history有什么区别" class="sidebar-link">29.vue-router的几种模式?hash和history有什么区别？</a></li><li class="sidebar-sub-header"><a href="/vue/#_30-vue数据频繁变化-为什么只以最后一次为准" class="sidebar-link">30.vue数据频繁变化，为什么只以最后一次为准？</a></li><li class="sidebar-sub-header"><a href="/vue/#_31-vue和react区别" class="sidebar-link">31.vue和react区别？</a></li><li class="sidebar-sub-header"><a href="/vue/#_32-v-html有什么问题" class="sidebar-link">32.v-html有什么问题？</a></li><li class="sidebar-sub-header"><a href="/vue/#_33-v-if和v-for为什么不建议混合使用" class="sidebar-link">33.v-if和v-for为什么不建议混合使用？</a></li><li class="sidebar-sub-header"><a href="/vue/#_34-vue2和vue3区别" class="sidebar-link">34.vue2和vue3区别？</a></li><li class="sidebar-sub-header"><a href="/vue/#_35-计算属性-computed-和实例方法-method-有什么区别" class="sidebar-link">*35.计算属性(computed)和实例方法(method)有什么区别？</a></li><li class="sidebar-sub-header"><a href="/vue/#_36-父子组件生命周期" class="sidebar-link">36.父子组件生命周期？</a></li><li class="sidebar-sub-header"><a href="/vue/#_37-非props属性有什么特点-如何解决props层级过深的问题" class="sidebar-link">37.非props属性有什么特点，如何解决props层级过深的问题？</a></li><li class="sidebar-sub-header"><a href="/vue/#_38-如何编写可复用的组件" class="sidebar-link">38.如何编写可复用的组件？</a></li><li class="sidebar-sub-header"><a href="/vue/#_39-插槽slot" class="sidebar-link">39.插槽slot？</a></li><li class="sidebar-sub-header"><a href="/vue/#_40-如何声明一个过滤器" class="sidebar-link">40.如何声明一个过滤器？</a></li><li class="sidebar-sub-header"><a href="/vue/#_41-react-vue的router实现原理" class="sidebar-link">41.react/vue的router实现原理？</a></li><li class="sidebar-sub-header"><a href="/vue/#_42-mixin作用" class="sidebar-link">42.mixin作用？</a></li><li class="sidebar-sub-header"><a href="/vue/#_43-vue-use作用" class="sidebar-link">43.vue.use作用？</a></li><li class="sidebar-sub-header"><a href="/vue/#_44-vue中使用的设计模式" class="sidebar-link">44.vue中使用的设计模式？</a></li><li class="sidebar-sub-header"><a href="/vue/#_45-vue脚手架" class="sidebar-link">45.vue脚手架？</a></li><li class="sidebar-sub-header"><a href="/vue/#_46-为什么使用-set" class="sidebar-link">46.为什么使用$set？</a></li><li class="sidebar-sub-header"><a href="/vue/#_47-常用修饰符" class="sidebar-link">47.常用修饰符？</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#vue">Vue</a><ul><li><a href="#_1-生命周期">1.生命周期?</a></li><li><a href="#_2-v-if和v-show的区别">2.v-if和v-show的区别？</a></li><li><a href="#_3-vue组件封装-全局可用">3.vue组件封装 全局可用？</a></li><li><a href="#_4-vue中的data为什么是个函数">4.vue中的data为什么是个函数？</a></li><li><a href="#_5-深度监听">5.深度监听？</a></li><li><a href="#_6-keep-alive作用">6.keep-alive作用？</a></li><li><a href="#_7-vue-router传参">7.vue-router传参？</a></li><li><a href="#_8-vue的数据流">8.vue的数据流？</a></li><li><a href="#_9-v-router路由守卫有哪些参数-如何实现">9.v-router路由守卫有哪些参数，如何实现？</a></li><li><a href="#_10-vuex有哪些参数-作用">10.vuex有哪些参数，作用？</a></li><li><a href="#_11-mvvm模型的理解及与mvc区别-vue-mvvm-当model变化会触发view更新">11.mvvm模型的理解及与MVC区别 =&gt; vue-mvvm 当model变化会触发view更新？</a></li><li><a href="#_12-v-for为什么一定要绑定key">12.v-for为什么一定要绑定key？</a></li><li><a href="#_13-vue的inject和eventbus">13.vue的inject和eventbus？</a></li><li><a href="#_14-vue2和vue3响应式原理实现差异">14.vue2和vue3响应式原理实现差异？</a></li><li><a href="#_15-v-model可以用什么替代">15.v-model可以用什么替代?</a></li><li><a href="#_16-vue组件销毁-所有自定义事件-emit-on定义的事件-和原生事件都会解绑吗">16.vue组件销毁，所有自定义事件($emit，$on定义的事件)和原生事件都会解绑吗?</a></li><li><a href="#_17-vue怎么区分开发环境和生产环境">17.vue怎么区分开发环境和生产环境？</a></li><li><a href="#_18-如何设置css只在当前组件起作用">18.如何设置css只在当前组件起作用？</a></li><li><a href="#_19-todo">19.// TODO</a></li><li><a href="#_20-route和router有什么区别">20.route和router有什么区别？</a></li><li><a href="#_21-vue是挂载在哪个标签上">21.vue是挂载在哪个标签上？</a></li><li><a href="#_22-computed和watch区别是什么">22.computed和watch区别是什么？</a></li><li><a href="#_23-vue模版编译原理-为什么要用template">23.vue模版编译原理？为什么要用template？</a></li><li><a href="#_24-vue的挂载过程">24.vue的挂载过程？</a></li><li><a href="#_25-说说组件传值的几种方式">25.说说组件传值的几种方式？</a></li><li><a href="#_26-如何解决vue初始化页面闪动问题">26.如何解决vue初始化页面闪动问题？</a></li><li><a href="#_27-什么是spa-有什么优点和缺点">27.什么是SPA，有什么优点和缺点？</a></li><li><a href="#_28-在哪个生命周期发起数据请求">28.在哪个生命周期发起数据请求？</a></li><li><a href="#_29-vue-router的几种模式-hash和history有什么区别">29.vue-router的几种模式?hash和history有什么区别？</a></li><li><a href="#_30-vue数据频繁变化-为什么只以最后一次为准">30.vue数据频繁变化，为什么只以最后一次为准？</a></li><li><a href="#_31-vue和react区别">31.vue和react区别？</a></li><li><a href="#_32-v-html有什么问题">32.v-html有什么问题？</a></li><li><a href="#_33-v-if和v-for为什么不建议混合使用">33.v-if和v-for为什么不建议混合使用？</a></li><li><a href="#_34-vue2和vue3区别">34.vue2和vue3区别？</a></li><li><a href="#_35-计算属性-computed-和实例方法-method-有什么区别">*35.计算属性(computed)和实例方法(method)有什么区别？</a></li><li><a href="#_36-父子组件生命周期">36.父子组件生命周期？</a></li><li><a href="#_37-非props属性有什么特点-如何解决props层级过深的问题">37.非props属性有什么特点，如何解决props层级过深的问题？</a></li><li><a href="#_38-如何编写可复用的组件">38.如何编写可复用的组件？</a></li><li><a href="#_39-插槽slot">39.插槽slot？</a></li><li><a href="#_40-如何声明一个过滤器">40.如何声明一个过滤器？</a></li><li><a href="#_41-react-vue的router实现原理">41.react/vue的router实现原理？</a></li><li><a href="#_42-mixin作用">42.mixin作用？</a></li><li><a href="#_43-vue-use作用">43.vue.use作用？</a></li><li><a href="#_44-vue中使用的设计模式">44.vue中使用的设计模式？</a></li><li><a href="#_45-vue脚手架">45.vue脚手架？</a></li><li><a href="#_46-为什么使用-set">46.为什么使用$set？</a></li><li><a href="#_47-常用修饰符">47.常用修饰符？</a></li></ul></li></ul></div><p></p> <h2 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h2> <h3 id="_1-生命周期"><a href="#_1-生命周期" class="header-anchor">#</a> 1.生命周期?</h3> <ul><li>生命周期就是vue实例从创建到销毁的过程。总共分为8个阶段(创建前后，载入前后，更新前后，销毁前后)</li> <li>在beforeCreate阶段，el(挂载元素)和data还没初始化完成</li> <li>created阶段，data初始化完成，可以访问方法和数据。但是el还没初始化完成</li> <li>beforeMount阶段，el也初始化完成，可以获取dom节点，但不能操作</li> <li>mounted阶段，挂载完毕，可以操作dom节点</li> <li>数据变化触发beforeUpdate和updated</li> <li>beforeDestroy阶段，可以销毁定时器和绑定的事件(此时实例还是可用的)</li> <li>destroyed阶段，改变data不会触发生命周期函数(dom 结构依然存在)</li></ul> <h4 id="第一次页面加载会触发哪几个钩子"><a href="#第一次页面加载会触发哪几个钩子" class="header-anchor">#</a> 第一次页面加载会触发哪几个钩子？</h4> <p>beforeCreate, created, beforeMount, mounted</p> <h4 id="dom渲染在哪个周期完成"><a href="#dom渲染在哪个周期完成" class="header-anchor">#</a> dom渲染在哪个周期完成？</h4> <p>mounted中就完成了</p> <h4 id="挂载和创建的区别"><a href="#挂载和创建的区别" class="header-anchor">#</a> 挂载和创建的区别？</h4> <p>创建之后只可访问数据不可操作dom，挂载后可以访问数据操作dom</p> <h4 id="vue生命周期钩子函数有哪些"><a href="#vue生命周期钩子函数有哪些" class="header-anchor">#</a> vue生命周期钩子函数有哪些？</h4> <p>beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed，activated，deactivated,
(errorCaptured当捕获一个子孙组件的错误时会调用)</p> <h3 id="_2-v-if和v-show的区别"><a href="#_2-v-if和v-show的区别" class="header-anchor">#</a> 2.v-if和v-show的区别？</h3> <ul><li>v-if实际是dom元素的创建和销毁</li> <li>v-show实际操作的是css的display属性 none/block
(v-show还减少了diff的对比，能优化操作中的性能)</li></ul> <h3 id="_3-vue组件封装-全局可用"><a href="#_3-vue组件封装-全局可用" class="header-anchor">#</a> 3.vue组件封装 全局可用？</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>在main.js引入，在使用的vue文件中直接&lt;my-swiper&gt;&lt;/my-swipe&gt;即可
import Swiper from './components/Swiper.vue'
Vue.component(&quot;my-swiper&quot;, Swiper)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_4-vue中的data为什么是个函数"><a href="#_4-vue中的data为什么是个函数" class="header-anchor">#</a> 4.vue中的data为什么是个函数？</h3> <p>组件之间共享data属性，如果不用函数写法，data的值会指向同一个引用地址，改变一个会影响其他
(函数写法，保证每次返回的都是一个新的对象，组件之间互相不影响)</p> <h3 id="_5-深度监听"><a href="#_5-深度监听" class="header-anchor">#</a> 5.深度监听？</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>watch: {
    a: {
        deep: true, // 开启深度监听
        handler() {
            
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_6-keep-alive作用"><a href="#_6-keep-alive作用" class="header-anchor">#</a> 6.keep-alive作用？</h3> <ul><li>主要作用缓存后只会走activated和deactivated，activated页面或组件被缓存每次进入页面会触发。deactivated组件离开触发</li> <li>路由从列表组件跳到详情页组件，再跳回列表组件，会重新渲染。可以通过缓存提高性能。</li> <li>可以实现分页后查看详情再跳回列表时，回到原来所在的页面</li></ul> <h3 id="_7-vue-router传参"><a href="#_7-vue-router传参" class="header-anchor">#</a> 7.vue-router传参？</h3> <ul><li>this.$router.params.id获取动态路由的参数/user/:id</li> <li>this.$router.query.id获取?后拼接的参数/user?id=123</li></ul> <h3 id="_8-vue的数据流"><a href="#_8-vue的数据流" class="header-anchor">#</a> 8.vue的数据流？</h3> <p>vue的数据流是单向的</p> <h4 id="vue是单向数据流-怎么v-model又是双向绑定"><a href="#vue是单向数据流-怎么v-model又是双向绑定" class="header-anchor">#</a> vue是单向数据流，怎么v-model又是双向绑定？</h4> <p>vue数据流是单向的，由父节点传给子节点。</p> <h3 id="_9-v-router路由守卫有哪些参数-如何实现"><a href="#_9-v-router路由守卫有哪些参数-如何实现" class="header-anchor">#</a> 9.v-router路由守卫有哪些参数，如何实现？</h3> <p>路由守卫分成全局守卫，路由独享守卫，组件内路由守卫</p> <ul><li>全局前置守卫beforeEach(to,from,next)</li> <li>路由独享守卫beforeEnter(to,from,next)</li> <li>组件内路由守卫beforeRouteEnter(to,from,next),beforeRouteUpdate(to,from,next),beforeRouteLeave(to,from,next)</li> <li>全局解析守卫beforeResolve(to,from,next)</li> <li>全局后置守卫afterEach(to,from)</li></ul> <h5 id="没有导航切换"><a href="#没有导航切换" class="header-anchor">#</a> 没有导航切换：</h5> <ul><li>beforeEach-&gt;beforeEnter-&gt;beforeRouteEnter-&gt;beforeResolve-&gt;afterEach</li></ul> <h5 id="有导航切换"><a href="#有导航切换" class="header-anchor">#</a> 有导航切换：</h5> <ul><li>beforeRouteLeave-&gt;beforeEach-&gt;beforeRouteEnter-&gt;beforeResolve-&gt;afterEach</li></ul> <h5 id="完整导航解析流程-来自官网"><a href="#完整导航解析流程-来自官网" class="header-anchor">#</a> 完整导航解析流程(来自官网)</h5> <ol><li>导航被触发。</li> <li>在失活的组件里调用 beforeRouteLeave 守卫。</li> <li>调用全局的 beforeEach 守卫。</li> <li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li> <li>在路由配置里调用 beforeEnter。</li> <li>解析异步路由组件。</li> <li>在被激活的组件里调用 beforeRouteEnter。</li> <li>调用全局的 beforeResolve 守卫 (2.5+)。</li> <li>导航被确认。</li> <li>调用全局的 afterEach 钩子。</li> <li>触发 DOM 更新。</li> <li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol> <h3 id="_10-vuex有哪些参数-作用"><a href="#_10-vuex有哪些参数-作用" class="header-anchor">#</a> 10.vuex有哪些参数，作用？</h3> <p>vuex是vue的状态管理。主要用来解决各组件间传值复杂和状态混乱的问题
=》无法持久化 可以通过localStorage实现</p> <ul><li>state 存放数据，不可以直接修改</li> <li>getter 类似与computed，用来计算</li> <li>mutation 函数，必须是同步方法 动态修改数据</li> <li>action 函数，如果有异步操作可以通过action代替mutation</li> <li>module 分模块，不同模块拥有自己的state，mutation，action，getter</li></ul> <h4 id="vuex改变全局参数"><a href="#vuex改变全局参数" class="header-anchor">#</a> VUEX改变全局参数？</h4> <p>异步方法通过dispatch(function)触发action，action再去commit触发mutation修改参数。同步方法直接通过commit触发mutation修改参数</p> <h4 id="注入原理"><a href="#注入原理" class="header-anchor">#</a> 注入原理？</h4> <p>通过Vue.use去安装vuex，插件内部有一个install方法，调用install方法把store注入到vuex实例中</p> <h3 id="_11-mvvm模型的理解及与mvc区别-vue-mvvm-当model变化会触发view更新"><a href="#_11-mvvm模型的理解及与mvc区别-vue-mvvm-当model变化会触发view更新" class="header-anchor">#</a> 11.mvvm模型的理解及与MVC区别 =&gt; vue-mvvm 当model变化会触发view更新？</h3> <ul><li>mvc model数据层 view视图层 controller控制层  各部分之间通信是单向的 view-&gt;controller-&gt;model-&gt;controller-&gt;view</li> <li>mvvm 由mvc演变而来 controller演变成viewModel 各部分之间通信都是双向的 当model变化vm会自动更新，view也会自动更新</li> <li>model&lt;-&gt;controller model&lt;-&gt;view =&gt; model和view 不直接进行通信</li></ul> <h3 id="_12-v-for为什么一定要绑定key"><a href="#_12-v-for为什么一定要绑定key" class="header-anchor">#</a> 12.v-for为什么一定要绑定key？</h3> <ul><li>key主要是用在虚拟dom上，在新旧节点对比时用来辨识节点，</li> <li>有key的话可以更快的找到对应的节点，没有key的话会采用就地复用的原则</li> <li>如果数据顺序被改变，vue不会移动元素来调整顺序，而是就地更新每个元素。</li></ul> <h4 id="key主要是用来解决什么问题-为什么不建议用index"><a href="#key主要是用来解决什么问题-为什么不建议用index" class="header-anchor">#</a> key主要是用来解决什么问题?为什么不建议用index？</h4> <p>尽量不用index作为key，否则在指定位置插入一个新元素，改变了index，这样就会导致后面所有元素都进行更新，因为后面的key都改变了</p> <h3 id="_13-vue的inject和eventbus"><a href="#_13-vue的inject和eventbus" class="header-anchor">#</a> 13.vue的inject和eventbus？</h3> <p>provide和inject是成对出现的，用来父组件向子孙组件传值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  provide() { // 父组件
    return {
      type: 'yeye',
      age: 60
    }
  }
  inject: ['age'] // 子孙组件
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>// main.js 定义
Vue.prototype.$eventBus = new Vue()
// 接收
this.$eventBus.$on('update', val =&gt; {})
// 发布
this.$eventBus.$emit('update', '更新信息')
// 销毁
this.$eventBus.$off('update', {})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_14-vue2和vue3响应式原理实现差异"><a href="#_14-vue2和vue3响应式原理实现差异" class="header-anchor">#</a> 14.vue2和vue3响应式原理实现差异？</h3> <ul><li>vue2的Object.defineProperty只能劫持对象属性，而vue3的proxy是直接代理对象</li> <li>vue3不用重写setter和getter方法(不用直接递归)所以性能高</li></ul> <h3 id="_15-v-model可以用什么替代"><a href="#_15-v-model可以用什么替代" class="header-anchor">#</a> 15.v-model可以用什么替代?</h3> <p>v-bind+v-on v-on定义事件获取输入的值进行设置，v-bind将这个值显示出来</p> <h3 id="_16-vue组件销毁-所有自定义事件-emit-on定义的事件-和原生事件都会解绑吗"><a href="#_16-vue组件销毁-所有自定义事件-emit-on定义的事件-和原生事件都会解绑吗" class="header-anchor">#</a> 16.vue组件销毁，所有自定义事件($emit，$on定义的事件)和原生事件都会解绑吗?</h3> <p>会自动解绑组件本身的事件，像定时器，addEventListener注册的监听器，都要在beforeDestroy的时候手动解绑</p> <h3 id="_17-vue怎么区分开发环境和生产环境"><a href="#_17-vue怎么区分开发环境和生产环境" class="header-anchor">#</a> 17.vue怎么区分开发环境和生产环境？</h3> <p>用webpack定义两套配置，一套开发，一套生产</p> <h3 id="_18-如何设置css只在当前组件起作用"><a href="#_18-如何设置css只在当前组件起作用" class="header-anchor">#</a> 18.如何设置css只在当前组件起作用？</h3> <p>在style标签添加scoped即可。</p> <h4 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h4> <p>编译后会将所有元素生成唯一的属性或者类名</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 代码
.btn {
}

// 编译后
.btn .jsx-1287234 {
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_19-todo"><a href="#_19-todo" class="header-anchor">#</a> 19.// TODO</h3> <h3 id="_20-route和router有什么区别"><a href="#_20-route和router有什么区别" class="header-anchor">#</a> 20.route和router有什么区别？</h3> <ul><li>route是路由信息对象，可以通过route获得path，hash，query等路由信息参数</li> <li>router是路由实现对象，可以用来跳转router.push()</li></ul> <h3 id="_21-vue是挂载在哪个标签上"><a href="#_21-vue是挂载在哪个标签上" class="header-anchor">#</a> 21.vue是挂载在哪个标签上？</h3> <p>vue是挂载在body标签里面(在vue中获取不到body标签)</p> <h3 id="_22-computed和watch区别是什么"><a href="#_22-computed和watch区别是什么" class="header-anchor">#</a> 22.computed和watch区别是什么？</h3> <ul><li>computed是计算属性不在data里声明，而watch监听的是data里的属性</li> <li>computed定义的值会进行缓存，watch不会。
(computed缓存是通过一个dirty属性进行控制，只有当其响应式数据发生变化时才会设置为true，触发重新计算)</li> <li>watch监听的是属性值，computed监听的是依赖值。依赖值不变的情况都会直接读取缓存，只有改变了才会重新计算</li></ul> <h3 id="_23-vue模版编译原理-为什么要用template"><a href="#_23-vue模版编译原理-为什么要用template" class="header-anchor">#</a> 23.vue模版编译原理？为什么要用template？</h3> <p>传递的是template属性，需要将template编译成render函数</p> <ol><li>通过正则将模版解析成AST语法树 template=&gt;ast语法树</li> <li>从AST语法树中找出静态节点进行标记=》目的是提高虚拟dom用diff算法比对时的性能</li> <li>(generate递归拼接为字符串)通过AST生成render函数
render函数作用是生成虚拟节点(递归是先子后父)</li></ol> <h4 id="抽象语法树ast和虚拟dom有什么区别"><a href="#抽象语法树ast和虚拟dom有什么区别" class="header-anchor">#</a> 抽象语法树AST和虚拟dom有什么区别？</h4> <p>ast做的是语法层面的转化，虚拟dom描述的是dom元素，可以增加自定义属性</p> <h3 id="_24-vue的挂载过程"><a href="#_24-vue的挂载过程" class="header-anchor">#</a> 24.vue的挂载过程？</h3> <ul><li>new Vue的时候会调用init方法，初始化数据，事件，生命周期这些</li> <li>然后通过$mount里面的mountComponent去执行render生成虚拟dom，再通过update将虚拟dom生成真实dom渲染到页面上</li></ul> <h3 id="_25-说说组件传值的几种方式"><a href="#_25-说说组件传值的几种方式" class="header-anchor">#</a> 25.说说组件传值的几种方式？</h3> <ol><li>父子通信 props和$emit =&gt;父组件通过props向子组件传递数据，子组件通过$emit通知父组件</li> <li>父子通信 $parent和$children =&gt;可以访问该组件所有方法和data。
要注意边界情况。如#app的$parent拿到new Vue的实例，再往上就是undefined。最底层拿$children拿到的是空数组，$children的值是数组，$parent的值是对象</li> <li>父子孙通信(跨级通信) provide和inject =&gt;父组件通过provide提供变量，子孙组件都能通过inject注入变量。
缺点不是响应式，但是如果传入的是可响应的就还是可响应的 =&gt;想要响应式可以通过传入父组件的实例或者是2.6.0新增的Vue.observable()</li> <li>父子通信 ref和refs =&gt;ref在普通dom元素上使用，指向的就是dom元素，在子组件上使用，指向的就是组件实例，可以直接调用组件方法和data</li> <li>全局通信 eventBus =&gt;可以向该中心发送通知和接收通知 =&gt;缺点是项目较大时难以维护 $emit定义事件名称及操作，$on接收该事件名称传递的值</li> <li>全局通信 Vuex =&gt;state，getter，mutation，action，module。解决了多个视图依赖同一状态和来自不同视图的行为需要变更同一状态的问题
=&gt;修改state的数据必须通过mutation进行，action也是要通过mutation</li> <li>全局通信 localStorage和sessionStorage =&gt;目的是持久化保存，缺点也是数据和状态比较混乱，不易维护
*8. 父子孙通信(跨级通信) $attrs和$listeners =&gt; $attrs和$listeners是两个对象，$attrs保存的是父组件中绑定的非props属性，$listener保存的是父组件中绑定的非原生事件</li></ol> <h3 id="_26-如何解决vue初始化页面闪动问题"><a href="#_26-如何解决vue初始化页面闪动问题" class="header-anchor">#</a> 26.如何解决vue初始化页面闪动问题？</h3> <p>v-cloak=》v-cloak里面设置display:none</p> <h3 id="_27-什么是spa-有什么优点和缺点"><a href="#_27-什么是spa-有什么优点和缺点" class="header-anchor">#</a> 27.什么是SPA，有什么优点和缺点？</h3> <p>SPA(single page application)单页面应用，仅在web页面初始化时加载相应的HTML，JS，CSS。
一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转。
=》利用路由机制实现内容切换(hash模式,局部刷新)</p> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点：</h4> <p>用户体验更好，避免了不必要的跳转和重复渲染，相对也能减轻服务器压力</p> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点：</h4> <p>初次加载耗时多，不利于SEO</p> <h3 id="_28-在哪个生命周期发起数据请求"><a href="#_28-在哪个生命周期发起数据请求" class="header-anchor">#</a> 28.在哪个生命周期发起数据请求？</h3> <p>在created，beforeMount，mounted都可以发起。</p> <h3 id="_29-vue-router的几种模式-hash和history有什么区别"><a href="#_29-vue-router的几种模式-hash和history有什么区别" class="header-anchor">#</a> 29.vue-router的几种模式?hash和history有什么区别？</h3> <p>两种：hash和history。默认hash模式，hash模式在url中会存在#符号，history模式不会</p> <ul><li>history需要后端nginx配置，url中的路径就是根目录下的相对路径，如果不用就会返回404</li> <li>hash模式只要index文件是真实路径即可</li></ul> <h3 id="_30-vue数据频繁变化-为什么只以最后一次为准"><a href="#_30-vue数据频繁变化-为什么只以最后一次为准" class="header-anchor">#</a> 30.vue数据频繁变化，为什么只以最后一次为准？</h3> <p>watcher里面有做去重操作：给每个dep引入id，watcher会记录所有dep的id，下次依赖收集的时候如果dep的id已经存在就不再收集watcher了
=》queueWatcher函数负责把对应的watcher收集到数组queue中，flushSchedulerQueue会从queue中取出watcher，然后执行watcher.run</p> <h3 id="_31-vue和react区别"><a href="#_31-vue和react区别" class="header-anchor">#</a> 31.vue和react区别？</h3> <ul><li>vue和react的diff算法不同
vue对比节点，如果元素类型相同，className不同，认为是不同元素会删除重建，react会认为是同类型节点，只修改节点属性
vue列表比对采用首尾指针，react采用从左到右比对的方式，当集合把最后一个节点移动到第一个，react会把前面的节点依次移动，而vue只会把最后一个移动到第一个</li> <li>响应式实现原理不同
react通过setState来更新状态=&gt;状态更新后组件也会重新渲染
vue通过defineProperty进行数据劫持再进行更新</li> <li>vue使用template模版编写，react使用jsx编写</li> <li>vue是双向数据流，react是单向数据流</li> <li>vue给我们封装了许多指令，react没有</li></ul> <h3 id="_32-v-html有什么问题"><a href="#_32-v-html有什么问题" class="header-anchor">#</a> 32.v-html有什么问题？</h3> <p>很容易导致xss攻击，不能用于用户提交的内容上</p> <h3 id="_33-v-if和v-for为什么不建议混合使用"><a href="#_33-v-if和v-for为什么不建议混合使用" class="header-anchor">#</a> 33.v-if和v-for为什么不建议混合使用？</h3> <p>被渲染的dom会重复一个创建销毁的过程=&gt;v-for优先级更高，如果数组很大，而实际要展示的很少，造成性能浪费
(当v-for和v-if处于同一个节点时，v-for的优先级比v-if更高)=&gt;通过computed先对要展示的数据进行过滤，再进行v-for</p> <h3 id="_34-vue2和vue3区别"><a href="#_34-vue2和vue3区别" class="header-anchor">#</a> 34.vue2和vue3区别？</h3> <ul><li>双向绑定原理不同=》vue2通过Object.defineProperty做数据劫持,vue3通过proxy进行代理。defineProperty不能监听数据对象新增的属性=&gt;proxy可以(需要手动$set)</li> <li>vue2是option API vue3是Composition API</li> <li>生命周期改变(beforeCreate,created-&gt;setup(),beforeMount-&gt;onBeforeMount,mounted-&gt;onMounted,beforeUpdate-&gt;onBeforeUpdate,
updated-&gt;onUpdated,beforeDestroy-&gt;onBeforeUnMount,destroyed-&gt;onUnMounted,errCaptured-&gt;onErrorCaptured)
=&gt;把beforeCreate和created合并成setup()，挂载和更新的钩子前面都加上了on，beforeDestroy变成onBeforeUnMount，destroyed变成onUnMounted</li> <li>vue3不使用this，避免了this指向问题。(vue2通过this去指向当前组件实例，vue3没有对this进行绑定)</li> <li>template里面可以使用多个子节点(和react一样，有fragment)</li> <li>vue3更小(移除不常用API，引入tree-shaking)更快(diff算法优化)</li> <li>vue3基于ts编写的，对ts的提示更友好</li></ul> <h3 id="_35-计算属性-computed-和实例方法-method-有什么区别"><a href="#_35-计算属性-computed-和实例方法-method-有什么区别" class="header-anchor">#</a> *35.计算属性(computed)和实例方法(method)有什么区别？</h3> <ul><li>计算属性有缓存，实例方法没有</li> <li>计算属性不能传参数，实例方法可以</li></ul> <h3 id="_36-父子组件生命周期"><a href="#_36-父子组件生命周期" class="header-anchor">#</a> 36.父子组件生命周期？</h3> <ul><li>父beforeCreate=&gt;父created=&gt;父beforeMount=&gt;子beforeCreate=&gt;子created=&gt;子beforeMount=&gt;子mounted=&gt;父mounted</li> <li>父组件先执行，在beforeMount和mounted之间，子组件执行beforeCreated到mounted</li> <li>更新过程：父beforeUpdate=&gt;子beforeUpdate=&gt;子updated=&gt;父updated(如果不互相影响，各自执行各自的。如父beforeUpdate=&gt;父updated)</li> <li>销毁过程: 父beforeDestroy=&gt;子beforeDestroy=&gt;子destroyed=&gt;父destroyed</li></ul> <h3 id="_37-非props属性有什么特点-如何解决props层级过深的问题"><a href="#_37-非props属性有什么特点-如何解决props层级过深的问题" class="header-anchor">#</a> 37.非props属性有什么特点，如何解决props层级过深的问题？</h3> <p>非props属性的子属性不能使用该属性
可以使用Vuex解决层级过深</p> <h3 id="_38-如何编写可复用的组件"><a href="#_38-如何编写可复用的组件" class="header-anchor">#</a> 38.如何编写可复用的组件？</h3> <p>组件只负责UI的展示和交互，不做具体数据处理，尽可能减少外部依赖</p> <h3 id="_39-插槽slot"><a href="#_39-插槽slot" class="header-anchor">#</a> 39.插槽slot？</h3> <p>子组件定义插槽，父组件提供内容去填补插槽</p> <ul><li>默认插槽(匿名插槽)一个组件只能有一个，相对应的是具名插槽，一个组件可以有多个，但是每个名称不同</li> <li>匿名插槽和具名插槽不绑定数据，作用域插槽要在slot上绑定数据</li></ul> <h3 id="_40-如何声明一个过滤器"><a href="#_40-如何声明一个过滤器" class="header-anchor">#</a> 40.如何声明一个过滤器？</h3> <p>全局过滤器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vue.filter(‘gettime’,function(date){
    Var time=new date(date)
    return time.getFullyear()+’/’+time.getMonth()+1’/’+getDate() }
)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_41-react-vue的router实现原理"><a href="#_41-react-vue的router实现原理" class="header-anchor">#</a> 41.react/vue的router实现原理？</h3> <p>主要有两种实现方式：</p> <ul><li><p>history API：
history.pushState()跳转路由
通过popstate事件监听路由变化(无法监听到history.pushState()的路由变化)</p></li> <li><p>hash：
location.hash跳转路由
通过hashchange事件监听路由变化</p></li></ul> <h4 id="区别"><a href="#区别" class="header-anchor">#</a> 区别：</h4> <p>hash只能修改#后的值，history可以随意设置同源url
hash的历史记录只显示之前的网址不会显示hash值，而history每条记录都会进入历史记录
hash无需后端配置，而history需要后端配合。比如需要设置一个页面用来匹配找不到资源的情况</p> <h3 id="_42-mixin作用"><a href="#_42-mixin作用" class="header-anchor">#</a> 42.mixin作用？</h3> <p>作用是抽离公共业务逻辑
(本质就是个js对象，将公共功能传入mixins，组件会将mixins对象中的选项和组件本身的合并，就是混入)
混入数据和本身组件数据有冲突，以本身为准</p> <h4 id="mixin原理"><a href="#mixin原理" class="header-anchor">#</a> mixin原理？</h4> <p>主要是调用mergeOptions方法，mergeOptions会先递归处理mixin的数据，赋值给parent
=&gt;然后再遍历mergeFiled parent的key，最后再遍历child，如果parent已经处理过这个key，就不处理</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}
// 局部混入
Vue.component('componentA',{
  mixins: [myMixin]
})
// 全局混入 =&gt; 会影响到第三方组件，比较适合用在插件里
Vue.mixin({
  created: function () {
      console.log(&quot;全局混入&quot;)
    }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="_43-vue-use作用"><a href="#_43-vue-use作用" class="header-anchor">#</a> 43.vue.use作用？</h3> <p>是用来使用第三方库的
内部有install方法传入vue(构造函数)=》内部使用vue</p> <h3 id="_44-vue中使用的设计模式"><a href="#_44-vue中使用的设计模式" class="header-anchor">#</a> 44.vue中使用的设计模式？</h3> <ol><li>单例模式 =》只有一个实例</li> <li>工厂模式 =》传入参数就可以创建实例</li> <li>观察者模式 =》依赖收集</li> <li>代理模式 =》proxy</li></ol> <h3 id="_45-vue脚手架"><a href="#_45-vue脚手架" class="header-anchor">#</a> 45.vue脚手架？</h3> <p>vue-cli=&gt;create-vue</p> <h3 id="_46-为什么使用-set"><a href="#_46-为什么使用-set" class="header-anchor">#</a> 46.为什么使用$set？</h3> <p>vue不能监测到对象属性的添加或删除，需要通过$set来实现</p> <p><img src="/reactive.png" alt="Image text"></p> <p>vue初始化流程图
<img src="/vue-init.svg" alt="Image text"></p> <h3 id="_47-常用修饰符"><a href="#_47-常用修饰符" class="header-anchor">#</a> 47.常用修饰符？</h3> <p>表单修饰符</p> <ul><li>lazy(光标离开才赋值，@change事件触发后)、trim、number
事件修饰符</li> <li>stop、prevent、self、once、capture、passive、native
鼠标按钮修饰符</li> <li>left、right、middle
键盘修饰符</li> <li>onkeyup、onkeydown、enter等</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a4ba95f7.js" defer></script><script src="/assets/js/2.67e62386.js" defer></script><script src="/assets/js/27.eafd817a.js" defer></script>
  </body>
</html>
